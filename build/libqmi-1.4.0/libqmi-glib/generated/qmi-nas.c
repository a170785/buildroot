
/* GENERATED CODE... DO NOT EDIT */

/*
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301 USA.
 *
 * Copyright (C) 2012 Lanedo GmbH
 */


#include <string.h>

#include "qmi-nas.h"
#include "qmi-enum-types.h"
#include "qmi-enum-types-private.h"
#include "qmi-flags64-types.h"
#include "qmi-error-types.h"
#include "qmi-device.h"
#include "qmi-utils.h"

#define QMI_STATUS_SUCCESS 0x0000
#define QMI_STATUS_FAILURE 0x0001


typedef enum {
    QMI_MESSAGE_NAS_RESET = 0x0000,
    QMI_MESSAGE_NAS_ABORT = 0x0001,
    QMI_MESSAGE_NAS_SET_EVENT_REPORT = 0x0002,
    QMI_MESSAGE_NAS_REGISTER_INDICATIONS = 0x0003,
    QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH = 0x0020,
    QMI_MESSAGE_NAS_NETWORK_SCAN = 0x0021,
    QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER = 0x0022,
    QMI_MESSAGE_NAS_GET_SERVING_SYSTEM = 0x0024,
    QMI_MESSAGE_NAS_GET_HOME_NETWORK = 0x0025,
    QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE = 0x002A,
    QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE = 0x002B,
    QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION = 0x0031,
    QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE = 0x0033,
    QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE = 0x0034,
    QMI_MESSAGE_NAS_GET_SYSTEM_INFO = 0x004D,
    QMI_MESSAGE_NAS_GET_SIGNAL_INFO = 0x004F,
    QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO = 0x0050,
    QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO = 0x0065,
} QmiMessageNas;


typedef enum {
    QMI_INDICATION_NAS_EVENT_REPORT = 0x0002,
    QMI_INDICATION_NAS_SERVING_SYSTEM = 0x0024,
    QMI_INDICATION_NAS_NETWORK_TIME = 0x004C,
    QMI_INDICATION_NAS_SYSTEM_INFO = 0x004E,
    QMI_INDICATION_NAS_SIGNAL_INFO = 0x0051,
} QmiIndicationNas;


/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Reset */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_reset_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_RESET);

    return self;
}

/* --- Output -- */

/**
 * QmiMessageResult:
 * @error_status: a #guint16.
 * @error_code: a #guint16.
 *
 * A QmiMessageResult struct.
 */
typedef struct _QmiMessageResult {
    guint16 error_status;
    guint16 error_code;
} QmiMessageResult;

struct _QmiMessageNasResetOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_RESET_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_nas_reset_output_get_result:
 * @self: a QmiMessageNasResetOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_reset_output_get_result (
    QmiMessageNasResetOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_reset_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasResetOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_reset_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_reset_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_reset_output_ref:
 * @self: a #QmiMessageNasResetOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasResetOutput *
qmi_message_nas_reset_output_ref (QmiMessageNasResetOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_reset_output_unref:
 * @self: a #QmiMessageNasResetOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_reset_output_unref (QmiMessageNasResetOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasResetOutput, self);
    }
}

static gboolean
qmi_message_result_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    static const guint expected_len = 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Result' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    return TRUE;
}

static gchar *
qmi_message_result_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (self,
                                      QMI_MESSAGE_NAS_RESET_OUTPUT_TLV_RESULT,
                                      &buffer_len);
    if (buffer) {
        GString *printable;
        guint16 error_status;
        guint16 error_code;

        printable = g_string_new ("");
        qmi_utils_read_guint16_from_buffer (
            &buffer,
            &buffer_len,
            QMI_ENDIAN_LITTLE,
            &error_status);
        qmi_utils_read_guint16_from_buffer (
            &buffer,
            &buffer_len,
            QMI_ENDIAN_LITTLE,
            &error_code);

        g_warn_if_fail (buffer_len == 0);

        if (error_status == QMI_STATUS_SUCCESS)
            g_string_append (printable, "SUCCESS");
        else
            g_string_append_printf (printable,
                                    "FAILURE: %s",
                                    qmi_protocol_error_get_string ((QmiProtocolError) error_code));

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_reset_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_reset_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_reset_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_RESET_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_reset_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Reset\" (0x0000)\n",
                            line_prefix);

    {
        struct message_reset_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_reset_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasResetOutput *
__qmi_message_nas_reset_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasResetOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_RESET, NULL);

    self = g_slice_new0 (QmiMessageNasResetOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_RESET_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_reset_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Abort */


/* --- Input -- */

/**
 * QmiMessageNasAbortInput:
 *
 * The #QmiMessageNasAbortInput structure contains private data and should only be accessed
 * using the provided API.
 */
typedef struct _QmiMessageNasAbortInput QmiMessageNasAbortInput;
static GType qmi_message_nas_abort_input_get_type (void) G_GNUC_CONST;
#define QMI_TYPE_MESSAGE_NAS_ABORT_INPUT (qmi_message_nas_abort_input_get_type ())

struct _QmiMessageNasAbortInput {
    volatile gint ref_count;

    /* Transaction ID */
    gboolean arg_transaction_id_set;
    guint16 arg_transaction_id;
};

#define QMI_MESSAGE_NAS_ABORT_INPUT_TLV_TRANSACTION_ID 0x01

static gboolean qmi_message_nas_abort_input_get_transaction_id (
    QmiMessageNasAbortInput *self,
    guint16 *transaction_id,
    GError **error);

/**
 * qmi_message_nas_abort_input_get_transaction_id:
 * @self: a #QmiMessageNasAbortInput.
 * @transaction_id: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Transaction ID' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
static gboolean
qmi_message_nas_abort_input_get_transaction_id (
    QmiMessageNasAbortInput *self,
    guint16 *transaction_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_transaction_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Transaction ID' was not found in the message");
        return FALSE;
    }

    if (transaction_id)
        *transaction_id = self->arg_transaction_id;

    return TRUE;
}

static gboolean qmi_message_nas_abort_input_set_transaction_id (
    QmiMessageNasAbortInput *self,
    guint16 transaction_id,
    GError **error);

/**
 * qmi_message_nas_abort_input_set_transaction_id:
 * @self: a #QmiMessageNasAbortInput.
 * @transaction_id: a #guint16.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Transaction ID' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
static gboolean
qmi_message_nas_abort_input_set_transaction_id (
    QmiMessageNasAbortInput *self,
    guint16 transaction_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_transaction_id = transaction_id;
    self->arg_transaction_id_set = TRUE;

    return TRUE;
}

static QmiMessageNasAbortInput *qmi_message_nas_abort_input_ref (QmiMessageNasAbortInput *self);
static void qmi_message_nas_abort_input_unref (QmiMessageNasAbortInput *self);
static QmiMessageNasAbortInput *qmi_message_nas_abort_input_new (void);

static GType
qmi_message_nas_abort_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasAbortInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_abort_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_abort_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_abort_input_ref:
 * @self: a #QmiMessageNasAbortInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
static QmiMessageNasAbortInput *
qmi_message_nas_abort_input_ref (QmiMessageNasAbortInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_abort_input_unref:
 * @self: a #QmiMessageNasAbortInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
static void
qmi_message_nas_abort_input_unref (QmiMessageNasAbortInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasAbortInput, self);
    }
}

/**
 * qmi_message_nas_abort_input_new:
 *
 * Allocates a new #QmiMessageNasAbortInput.
 *
 * Returns: the newly created #QmiMessageNasAbortInput. The returned value should be freed with qmi_message_nas_abort_input_unref().
 */
static QmiMessageNasAbortInput *
qmi_message_nas_abort_input_new (void)
{
    QmiMessageNasAbortInput *self;

    self = g_slice_new0 (QmiMessageNasAbortInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_abort_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageNasAbortInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_ABORT);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Abort' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Transaction ID' TLV */
    if (input->arg_transaction_id_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the guint16 variable to the buffer */
        qmi_utils_write_guint16_to_buffer (
            &buffer_aux,
            &buffer_len,
            QMI_ENDIAN_LITTLE,
            &(input->arg_transaction_id));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_ABORT_INPUT_TLV_TRANSACTION_ID,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Transaction ID TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Transaction ID' in message 'Abort'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

/**
 * QmiMessageNasAbortOutput:
 *
 * The #QmiMessageNasAbortOutput structure contains private data and should only be accessed
 * using the provided API.
 */
typedef struct _QmiMessageNasAbortOutput QmiMessageNasAbortOutput;
static GType qmi_message_nas_abort_output_get_type (void) G_GNUC_CONST;
#define QMI_TYPE_MESSAGE_NAS_ABORT_OUTPUT (qmi_message_nas_abort_output_get_type ())

struct _QmiMessageNasAbortOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_ABORT_OUTPUT_TLV_RESULT 0x02

gboolean qmi_message_nas_abort_output_get_result (
    QmiMessageNasAbortOutput *self,
    GError **error);

/**
 * qmi_message_nas_abort_output_get_result:
 * @self: a QmiMessageNasAbortOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_abort_output_get_result (
    QmiMessageNasAbortOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

static QmiMessageNasAbortOutput *qmi_message_nas_abort_output_ref (QmiMessageNasAbortOutput *self);
static void qmi_message_nas_abort_output_unref (QmiMessageNasAbortOutput *self);

static GType
qmi_message_nas_abort_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasAbortOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_abort_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_abort_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_abort_output_ref:
 * @self: a #QmiMessageNasAbortOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
static QmiMessageNasAbortOutput *
qmi_message_nas_abort_output_ref (QmiMessageNasAbortOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_abort_output_unref:
 * @self: a #QmiMessageNasAbortOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
static void
qmi_message_nas_abort_output_unref (QmiMessageNasAbortOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasAbortOutput, self);
    }
}

static gboolean
qmi_message_nas_abort_input_transaction_id_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Transaction ID' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Transaction ID' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_abort_input_transaction_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_ABORT_INPUT_TLV_TRANSACTION_ID,
                                      &buffer_len);
    if (buffer && qmi_message_nas_abort_input_transaction_id_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Transaction ID' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_abort_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_abort_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_abort_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_ABORT_INPUT_TLV_TRANSACTION_ID:
            tlv_type_str = "Transaction ID";
            translated_value = qmi_message_nas_abort_input_transaction_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_ABORT_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_abort_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Abort\" (0x0001)\n",
                            line_prefix);

    {
        struct message_abort_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_abort_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasAbortOutput *
__qmi_message_nas_abort_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasAbortOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_ABORT, NULL);

    self = g_slice_new0 (QmiMessageNasAbortOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_ABORT_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_abort_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Set Event Report */


/* --- Input -- */

struct _QmiMessageNasSetEventReportInput {
    volatile gint ref_count;

    /* LTE RSRP Delta */
    gboolean arg_lte_rsrp_delta_set;
    guint8 arg_lte_rsrp_delta_report;
    guint8 arg_lte_rsrp_delta_rsrp_delta;

    /* LTE SNR Delta */
    gboolean arg_lte_snr_delta_set;
    guint8 arg_lte_snr_delta_report;
    guint8 arg_lte_snr_delta_snr_delta;

    /* SINR Threshold */
    gboolean arg_sinr_threshold_set;
    guint8 arg_sinr_threshold_report;
    GArray *arg_sinr_threshold_thresholds;

    /* ECIO Threshold */
    gboolean arg_ecio_threshold_set;
    guint8 arg_ecio_threshold_report;
    GArray *arg_ecio_threshold_thresholds;

    /* Error Rate Indicator */
    gboolean arg_error_rate_indicator_set;
    guint8 arg_error_rate_indicator;

    /* SINR Indicator */
    gboolean arg_sinr_indicator_set;
    guint8 arg_sinr_indicator_report;
    guint8 arg_sinr_indicator_sinr_delta;

    /* IO Indicator */
    gboolean arg_io_indicator_set;
    guint8 arg_io_indicator_report;
    guint8 arg_io_indicator_io_delta;

    /* ECIO Indicator */
    gboolean arg_ecio_indicator_set;
    guint8 arg_ecio_indicator_report;
    guint8 arg_ecio_indicator_ecio_delta;

    /* RSSI Indicator */
    gboolean arg_rssi_indicator_set;
    guint8 arg_rssi_indicator_report;
    guint8 arg_rssi_indicator_rssi_delta;

    /* Registration Reject Reason */
    gboolean arg_registration_reject_reason_set;
    guint8 arg_registration_reject_reason;

    /* RF Band Information */
    gboolean arg_rf_band_information_set;
    guint8 arg_rf_band_information;

    /* Signal Strength Indicator */
    gboolean arg_signal_strength_indicator_set;
    guint8 arg_signal_strength_indicator_report;
    GArray *arg_signal_strength_indicator_thresholds;
};

#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_RSRP_DELTA 0x1C
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_SNR_DELTA 0x1B
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_THRESHOLD 0x1A
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_THRESHOLD 0x19
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ERROR_RATE_INDICATOR 0x17
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_INDICATOR 0x16
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_IO_INDICATOR 0x15
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_INDICATOR 0x14
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RSSI_INDICATOR 0x13
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_REGISTRATION_REJECT_REASON 0x12
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RF_BAND_INFORMATION 0x11
#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SIGNAL_STRENGTH_INDICATOR 0x10

/**
 * qmi_message_nas_set_event_report_input_get_lte_rsrp_delta:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @lte_rsrp_delta_report: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_rsrp_delta_rsrp_delta: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE RSRP Delta' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_lte_rsrp_delta (
    QmiMessageNasSetEventReportInput *self,
    gboolean *lte_rsrp_delta_report,
    guint8 *lte_rsrp_delta_rsrp_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_rsrp_delta_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE RSRP Delta' was not found in the message");
        return FALSE;
    }

    if (lte_rsrp_delta_report)
        *lte_rsrp_delta_report = (gboolean)(self->arg_lte_rsrp_delta_report);
    if (lte_rsrp_delta_rsrp_delta)
        *lte_rsrp_delta_rsrp_delta = self->arg_lte_rsrp_delta_rsrp_delta;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_lte_rsrp_delta:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @lte_rsrp_delta_report: a #gboolean.
 * @lte_rsrp_delta_rsrp_delta: a #guint8.
 * @error: Return location for error or %NULL.
 *
 * Set the 'LTE RSRP Delta' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_lte_rsrp_delta (
    QmiMessageNasSetEventReportInput *self,
    gboolean lte_rsrp_delta_report,
    guint8 lte_rsrp_delta_rsrp_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_lte_rsrp_delta_report = (guint8)(lte_rsrp_delta_report);
    self->arg_lte_rsrp_delta_rsrp_delta = lte_rsrp_delta_rsrp_delta;
    self->arg_lte_rsrp_delta_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_lte_snr_delta:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @lte_snr_delta_report: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_snr_delta_snr_delta: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE SNR Delta' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_lte_snr_delta (
    QmiMessageNasSetEventReportInput *self,
    gboolean *lte_snr_delta_report,
    guint8 *lte_snr_delta_snr_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_snr_delta_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE SNR Delta' was not found in the message");
        return FALSE;
    }

    if (lte_snr_delta_report)
        *lte_snr_delta_report = (gboolean)(self->arg_lte_snr_delta_report);
    if (lte_snr_delta_snr_delta)
        *lte_snr_delta_snr_delta = self->arg_lte_snr_delta_snr_delta;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_lte_snr_delta:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @lte_snr_delta_report: a #gboolean.
 * @lte_snr_delta_snr_delta: a #guint8.
 * @error: Return location for error or %NULL.
 *
 * Set the 'LTE SNR Delta' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_lte_snr_delta (
    QmiMessageNasSetEventReportInput *self,
    gboolean lte_snr_delta_report,
    guint8 lte_snr_delta_snr_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_lte_snr_delta_report = (guint8)(lte_snr_delta_report);
    self->arg_lte_snr_delta_snr_delta = lte_snr_delta_snr_delta;
    self->arg_lte_snr_delta_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_sinr_threshold:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @sinr_threshold_report: a placeholder for the output #gboolean, or %NULL if not required.
 * @sinr_threshold_thresholds: a placeholder for the output #GArray of #guint8 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'SINR Threshold' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_sinr_threshold (
    QmiMessageNasSetEventReportInput *self,
    gboolean *sinr_threshold_report,
    GArray **sinr_threshold_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sinr_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SINR Threshold' was not found in the message");
        return FALSE;
    }

    if (sinr_threshold_report)
        *sinr_threshold_report = (gboolean)(self->arg_sinr_threshold_report);
    if (sinr_threshold_thresholds)
        *sinr_threshold_thresholds = self->arg_sinr_threshold_thresholds;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_sinr_threshold:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @sinr_threshold_report: a #gboolean.
 * @sinr_threshold_thresholds: a #GArray of #guint8 elements. A new reference to @sinr_threshold_thresholds will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'SINR Threshold' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_sinr_threshold (
    QmiMessageNasSetEventReportInput *self,
    gboolean sinr_threshold_report,
    GArray *sinr_threshold_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_sinr_threshold_report = (guint8)(sinr_threshold_report);
    if (self->arg_sinr_threshold_thresholds)
        g_array_unref (self->arg_sinr_threshold_thresholds);
    self->arg_sinr_threshold_thresholds = g_array_ref (sinr_threshold_thresholds);
    self->arg_sinr_threshold_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_ecio_threshold:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @ecio_threshold_report: a placeholder for the output #gboolean, or %NULL if not required.
 * @ecio_threshold_thresholds: a placeholder for the output #GArray of #gint16 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'ECIO Threshold' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_ecio_threshold (
    QmiMessageNasSetEventReportInput *self,
    gboolean *ecio_threshold_report,
    GArray **ecio_threshold_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ecio_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ECIO Threshold' was not found in the message");
        return FALSE;
    }

    if (ecio_threshold_report)
        *ecio_threshold_report = (gboolean)(self->arg_ecio_threshold_report);
    if (ecio_threshold_thresholds)
        *ecio_threshold_thresholds = self->arg_ecio_threshold_thresholds;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_ecio_threshold:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @ecio_threshold_report: a #gboolean.
 * @ecio_threshold_thresholds: a #GArray of #gint16 elements. A new reference to @ecio_threshold_thresholds will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'ECIO Threshold' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_ecio_threshold (
    QmiMessageNasSetEventReportInput *self,
    gboolean ecio_threshold_report,
    GArray *ecio_threshold_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_ecio_threshold_report = (guint8)(ecio_threshold_report);
    if (self->arg_ecio_threshold_thresholds)
        g_array_unref (self->arg_ecio_threshold_thresholds);
    self->arg_ecio_threshold_thresholds = g_array_ref (ecio_threshold_thresholds);
    self->arg_ecio_threshold_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_error_rate_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @error_rate_indicator: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Error Rate Indicator' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_error_rate_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *error_rate_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_error_rate_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Error Rate Indicator' was not found in the message");
        return FALSE;
    }

    if (error_rate_indicator)
        *error_rate_indicator = (gboolean)(self->arg_error_rate_indicator);

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_error_rate_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @error_rate_indicator: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Error Rate Indicator' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_error_rate_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean error_rate_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_error_rate_indicator = (guint8)(error_rate_indicator);
    self->arg_error_rate_indicator_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_sinr_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @sinr_indicator_report: a placeholder for the output #gboolean, or %NULL if not required.
 * @sinr_indicator_sinr_delta: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'SINR Indicator' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_sinr_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *sinr_indicator_report,
    guint8 *sinr_indicator_sinr_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sinr_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SINR Indicator' was not found in the message");
        return FALSE;
    }

    if (sinr_indicator_report)
        *sinr_indicator_report = (gboolean)(self->arg_sinr_indicator_report);
    if (sinr_indicator_sinr_delta)
        *sinr_indicator_sinr_delta = self->arg_sinr_indicator_sinr_delta;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_sinr_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @sinr_indicator_report: a #gboolean.
 * @sinr_indicator_sinr_delta: a #guint8.
 * @error: Return location for error or %NULL.
 *
 * Set the 'SINR Indicator' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_sinr_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean sinr_indicator_report,
    guint8 sinr_indicator_sinr_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_sinr_indicator_report = (guint8)(sinr_indicator_report);
    self->arg_sinr_indicator_sinr_delta = sinr_indicator_sinr_delta;
    self->arg_sinr_indicator_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_io_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @io_indicator_report: a placeholder for the output #gboolean, or %NULL if not required.
 * @io_indicator_io_delta: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'IO Indicator' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_io_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *io_indicator_report,
    guint8 *io_indicator_io_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_io_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'IO Indicator' was not found in the message");
        return FALSE;
    }

    if (io_indicator_report)
        *io_indicator_report = (gboolean)(self->arg_io_indicator_report);
    if (io_indicator_io_delta)
        *io_indicator_io_delta = self->arg_io_indicator_io_delta;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_io_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @io_indicator_report: a #gboolean.
 * @io_indicator_io_delta: a #guint8.
 * @error: Return location for error or %NULL.
 *
 * Set the 'IO Indicator' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_io_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean io_indicator_report,
    guint8 io_indicator_io_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_io_indicator_report = (guint8)(io_indicator_report);
    self->arg_io_indicator_io_delta = io_indicator_io_delta;
    self->arg_io_indicator_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_ecio_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @ecio_indicator_report: a placeholder for the output #gboolean, or %NULL if not required.
 * @ecio_indicator_ecio_delta: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'ECIO Indicator' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_ecio_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *ecio_indicator_report,
    guint8 *ecio_indicator_ecio_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ecio_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ECIO Indicator' was not found in the message");
        return FALSE;
    }

    if (ecio_indicator_report)
        *ecio_indicator_report = (gboolean)(self->arg_ecio_indicator_report);
    if (ecio_indicator_ecio_delta)
        *ecio_indicator_ecio_delta = self->arg_ecio_indicator_ecio_delta;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_ecio_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @ecio_indicator_report: a #gboolean.
 * @ecio_indicator_ecio_delta: a #guint8.
 * @error: Return location for error or %NULL.
 *
 * Set the 'ECIO Indicator' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_ecio_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean ecio_indicator_report,
    guint8 ecio_indicator_ecio_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_ecio_indicator_report = (guint8)(ecio_indicator_report);
    self->arg_ecio_indicator_ecio_delta = ecio_indicator_ecio_delta;
    self->arg_ecio_indicator_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_rssi_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @rssi_indicator_report: a placeholder for the output #gboolean, or %NULL if not required.
 * @rssi_indicator_rssi_delta: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RSSI Indicator' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_rssi_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *rssi_indicator_report,
    guint8 *rssi_indicator_rssi_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rssi_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSSI Indicator' was not found in the message");
        return FALSE;
    }

    if (rssi_indicator_report)
        *rssi_indicator_report = (gboolean)(self->arg_rssi_indicator_report);
    if (rssi_indicator_rssi_delta)
        *rssi_indicator_rssi_delta = self->arg_rssi_indicator_rssi_delta;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_rssi_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @rssi_indicator_report: a #gboolean.
 * @rssi_indicator_rssi_delta: a #guint8.
 * @error: Return location for error or %NULL.
 *
 * Set the 'RSSI Indicator' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_rssi_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean rssi_indicator_report,
    guint8 rssi_indicator_rssi_delta,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_rssi_indicator_report = (guint8)(rssi_indicator_report);
    self->arg_rssi_indicator_rssi_delta = rssi_indicator_rssi_delta;
    self->arg_rssi_indicator_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_registration_reject_reason:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @registration_reject_reason: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Registration Reject Reason' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_registration_reject_reason (
    QmiMessageNasSetEventReportInput *self,
    gboolean *registration_reject_reason,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_registration_reject_reason_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Registration Reject Reason' was not found in the message");
        return FALSE;
    }

    if (registration_reject_reason)
        *registration_reject_reason = (gboolean)(self->arg_registration_reject_reason);

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_registration_reject_reason:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @registration_reject_reason: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Registration Reject Reason' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_registration_reject_reason (
    QmiMessageNasSetEventReportInput *self,
    gboolean registration_reject_reason,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_registration_reject_reason = (guint8)(registration_reject_reason);
    self->arg_registration_reject_reason_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_rf_band_information:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @rf_band_information: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RF Band Information' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_rf_band_information (
    QmiMessageNasSetEventReportInput *self,
    gboolean *rf_band_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rf_band_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RF Band Information' was not found in the message");
        return FALSE;
    }

    if (rf_band_information)
        *rf_band_information = (gboolean)(self->arg_rf_band_information);

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_rf_band_information:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @rf_band_information: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'RF Band Information' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_rf_band_information (
    QmiMessageNasSetEventReportInput *self,
    gboolean rf_band_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_rf_band_information = (guint8)(rf_band_information);
    self->arg_rf_band_information_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_get_signal_strength_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @signal_strength_indicator_report: a placeholder for the output #gboolean, or %NULL if not required.
 * @signal_strength_indicator_thresholds: a placeholder for the output #GArray of #gint8 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Signal Strength Indicator' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_get_signal_strength_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean *signal_strength_indicator_report,
    GArray **signal_strength_indicator_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_signal_strength_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Signal Strength Indicator' was not found in the message");
        return FALSE;
    }

    if (signal_strength_indicator_report)
        *signal_strength_indicator_report = (gboolean)(self->arg_signal_strength_indicator_report);
    if (signal_strength_indicator_thresholds)
        *signal_strength_indicator_thresholds = self->arg_signal_strength_indicator_thresholds;

    return TRUE;
}

/**
 * qmi_message_nas_set_event_report_input_set_signal_strength_indicator:
 * @self: a #QmiMessageNasSetEventReportInput.
 * @signal_strength_indicator_report: a #gboolean.
 * @signal_strength_indicator_thresholds: a #GArray of #gint8 elements. A new reference to @signal_strength_indicator_thresholds will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Signal Strength Indicator' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_event_report_input_set_signal_strength_indicator (
    QmiMessageNasSetEventReportInput *self,
    gboolean signal_strength_indicator_report,
    GArray *signal_strength_indicator_thresholds,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_signal_strength_indicator_report = (guint8)(signal_strength_indicator_report);
    if (self->arg_signal_strength_indicator_thresholds)
        g_array_unref (self->arg_signal_strength_indicator_thresholds);
    self->arg_signal_strength_indicator_thresholds = g_array_ref (signal_strength_indicator_thresholds);
    self->arg_signal_strength_indicator_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_set_event_report_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetEventReportInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_event_report_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_event_report_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_set_event_report_input_ref:
 * @self: a #QmiMessageNasSetEventReportInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasSetEventReportInput *
qmi_message_nas_set_event_report_input_ref (QmiMessageNasSetEventReportInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_set_event_report_input_unref:
 * @self: a #QmiMessageNasSetEventReportInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_set_event_report_input_unref (QmiMessageNasSetEventReportInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_sinr_threshold_thresholds)
            g_array_unref (self->arg_sinr_threshold_thresholds);
        if (self->arg_ecio_threshold_thresholds)
            g_array_unref (self->arg_ecio_threshold_thresholds);
        if (self->arg_signal_strength_indicator_thresholds)
            g_array_unref (self->arg_signal_strength_indicator_thresholds);
        g_slice_free (QmiMessageNasSetEventReportInput, self);
    }
}

/**
 * qmi_message_nas_set_event_report_input_new:
 *
 * Allocates a new #QmiMessageNasSetEventReportInput.
 *
 * Returns: the newly created #QmiMessageNasSetEventReportInput. The returned value should be freed with qmi_message_nas_set_event_report_input_unref().
 */
QmiMessageNasSetEventReportInput *
qmi_message_nas_set_event_report_input_new (void)
{
    QmiMessageNasSetEventReportInput *self;

    self = g_slice_new0 (QmiMessageNasSetEventReportInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_set_event_report_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageNasSetEventReportInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_SET_EVENT_REPORT);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return self;

    /* Try to add the 'LTE RSRP Delta' TLV */
    if (input->arg_lte_rsrp_delta_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_lte_rsrp_delta_report;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_lte_rsrp_delta_rsrp_delta));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_RSRP_DELTA,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the LTE RSRP Delta TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'LTE SNR Delta' TLV */
    if (input->arg_lte_snr_delta_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_lte_snr_delta_report;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_lte_snr_delta_snr_delta));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_SNR_DELTA,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the LTE SNR Delta TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'SINR Threshold' TLV */
    if (input->arg_sinr_threshold_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_sinr_threshold_report;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        {
            guint thresholds_i;
            guint8 thresholds_n_items;

            /* Write the number of items in the array first */
            thresholds_n_items = (guint8) input->arg_sinr_threshold_thresholds->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(thresholds_n_items));

            for (thresholds_i = 0; thresholds_i < input->arg_sinr_threshold_thresholds->len; thresholds_i++) {
                /* Write the guint8 variable to the buffer */
                qmi_utils_write_guint8_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    &(g_array_index (input->arg_sinr_threshold_thresholds, guint8,thresholds_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_THRESHOLD,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the SINR Threshold TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'ECIO Threshold' TLV */
    if (input->arg_ecio_threshold_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_ecio_threshold_report;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        {
            guint thresholds_i;
            guint8 thresholds_n_items;

            /* Write the number of items in the array first */
            thresholds_n_items = (guint8) input->arg_ecio_threshold_thresholds->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(thresholds_n_items));

            for (thresholds_i = 0; thresholds_i < input->arg_ecio_threshold_thresholds->len; thresholds_i++) {
                /* Write the gint16 variable to the buffer */
                qmi_utils_write_gint16_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(g_array_index (input->arg_ecio_threshold_thresholds, gint16,thresholds_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_THRESHOLD,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the ECIO Threshold TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Error Rate Indicator' TLV */
    if (input->arg_error_rate_indicator_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_error_rate_indicator;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ERROR_RATE_INDICATOR,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Error Rate Indicator TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'SINR Indicator' TLV */
    if (input->arg_sinr_indicator_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_sinr_indicator_report;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_sinr_indicator_sinr_delta));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_INDICATOR,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the SINR Indicator TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'IO Indicator' TLV */
    if (input->arg_io_indicator_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_io_indicator_report;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_io_indicator_io_delta));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_IO_INDICATOR,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the IO Indicator TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'ECIO Indicator' TLV */
    if (input->arg_ecio_indicator_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_ecio_indicator_report;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_ecio_indicator_ecio_delta));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_INDICATOR,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the ECIO Indicator TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'RSSI Indicator' TLV */
    if (input->arg_rssi_indicator_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_rssi_indicator_report;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_rssi_indicator_rssi_delta));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RSSI_INDICATOR,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the RSSI Indicator TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Registration Reject Reason' TLV */
    if (input->arg_registration_reject_reason_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_registration_reject_reason;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_REGISTRATION_REJECT_REASON,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Registration Reject Reason TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'RF Band Information' TLV */
    if (input->arg_rf_band_information_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_rf_band_information;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RF_BAND_INFORMATION,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the RF Band Information TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Signal Strength Indicator' TLV */
    if (input->arg_signal_strength_indicator_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_signal_strength_indicator_report;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        {
            guint thresholds_i;
            guint8 thresholds_n_items;

            /* Write the number of items in the array first */
            thresholds_n_items = (guint8) input->arg_signal_strength_indicator_thresholds->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(thresholds_n_items));

            for (thresholds_i = 0; thresholds_i < input->arg_signal_strength_indicator_thresholds->len; thresholds_i++) {
                /* Write the gint8 variable to the buffer */
                qmi_utils_write_gint8_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    &(g_array_index (input->arg_signal_strength_indicator_thresholds, gint8,thresholds_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SIGNAL_STRENGTH_INDICATOR,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Signal Strength Indicator TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageNasSetEventReportOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_SET_EVENT_REPORT_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_nas_set_event_report_output_get_result:
 * @self: a QmiMessageNasSetEventReportOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_set_event_report_output_get_result (
    QmiMessageNasSetEventReportOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_set_event_report_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetEventReportOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_event_report_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_event_report_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_set_event_report_output_ref:
 * @self: a #QmiMessageNasSetEventReportOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasSetEventReportOutput *
qmi_message_nas_set_event_report_output_ref (QmiMessageNasSetEventReportOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_set_event_report_output_unref:
 * @self: a #QmiMessageNasSetEventReportOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_set_event_report_output_unref (QmiMessageNasSetEventReportOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSetEventReportOutput, self);
    }
}

static gboolean
qmi_message_nas_set_event_report_input_lte_rsrp_delta_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE RSRP Delta' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE RSRP Delta' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_lte_rsrp_delta_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_RSRP_DELTA,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_lte_rsrp_delta_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " report = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " rsrp_delta = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE RSRP Delta' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_lte_snr_delta_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE SNR Delta' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE SNR Delta' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_lte_snr_delta_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_SNR_DELTA,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_lte_snr_delta_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " report = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " snr_delta = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE SNR Delta' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_sinr_threshold_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    {
        guint thresholds_i;
        guint8 thresholds_n_items;
        const guint8 *thresholds_aux_buffer = &buffer[expected_len];
        guint16 thresholds_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &thresholds_aux_buffer,
            &thresholds_aux_buffer_len,
            &(thresholds_n_items));
        for (thresholds_i = 0; thresholds_i < thresholds_n_items; thresholds_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'SINR Threshold' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'SINR Threshold' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_sinr_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_THRESHOLD,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_sinr_threshold_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " report = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " thresholds = '");
        {
            guint thresholds_i;
            guint8 thresholds_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(thresholds_n_items));

            g_string_append (printable, "{");

            for (thresholds_i = 0; thresholds_i < thresholds_n_items; thresholds_i++) {
                g_string_append_printf (printable, " [%u] = '", thresholds_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%u", (guint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'SINR Threshold' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_ecio_threshold_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    {
        guint thresholds_i;
        guint8 thresholds_n_items;
        const guint8 *thresholds_aux_buffer = &buffer[expected_len];
        guint16 thresholds_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &thresholds_aux_buffer,
            &thresholds_aux_buffer_len,
            &(thresholds_n_items));
        for (thresholds_i = 0; thresholds_i < thresholds_n_items; thresholds_i++) {

            expected_len += 2;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'ECIO Threshold' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'ECIO Threshold' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_ecio_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_THRESHOLD,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_ecio_threshold_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " report = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " thresholds = '");
        {
            guint thresholds_i;
            guint8 thresholds_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(thresholds_n_items));

            g_string_append (printable, "{");

            for (thresholds_i = 0; thresholds_i < thresholds_n_items; thresholds_i++) {
                g_string_append_printf (printable, " [%u] = '", thresholds_i);

                {
                    gint16 tmp;

                    /* Read the gint16 variable from the buffer */
                    qmi_utils_read_gint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'ECIO Threshold' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_error_rate_indicator_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Error Rate Indicator' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Error Rate Indicator' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_error_rate_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ERROR_RATE_INDICATOR,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_error_rate_indicator_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Error Rate Indicator' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_sinr_indicator_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'SINR Indicator' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'SINR Indicator' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_sinr_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_INDICATOR,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_sinr_indicator_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " report = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " sinr_delta = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'SINR Indicator' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_io_indicator_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'IO Indicator' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'IO Indicator' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_io_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_IO_INDICATOR,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_io_indicator_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " report = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " io_delta = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'IO Indicator' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_ecio_indicator_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'ECIO Indicator' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'ECIO Indicator' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_ecio_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_INDICATOR,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_ecio_indicator_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " report = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ecio_delta = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'ECIO Indicator' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_rssi_indicator_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RSSI Indicator' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RSSI Indicator' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_rssi_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RSSI_INDICATOR,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_rssi_indicator_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " report = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " rssi_delta = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RSSI Indicator' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_registration_reject_reason_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Registration Reject Reason' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Registration Reject Reason' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_registration_reject_reason_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_REGISTRATION_REJECT_REASON,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_registration_reject_reason_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Registration Reject Reason' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_rf_band_information_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RF Band Information' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RF Band Information' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_rf_band_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RF_BAND_INFORMATION,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_rf_band_information_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RF Band Information' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_event_report_input_signal_strength_indicator_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    {
        guint thresholds_i;
        guint8 thresholds_n_items;
        const guint8 *thresholds_aux_buffer = &buffer[expected_len];
        guint16 thresholds_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &thresholds_aux_buffer,
            &thresholds_aux_buffer_len,
            &(thresholds_n_items));
        for (thresholds_i = 0; thresholds_i < thresholds_n_items; thresholds_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Signal Strength Indicator' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Signal Strength Indicator' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_event_report_input_signal_strength_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SIGNAL_STRENGTH_INDICATOR,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_event_report_input_signal_strength_indicator_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " report = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " thresholds = '");
        {
            guint thresholds_i;
            guint8 thresholds_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(thresholds_n_items));

            g_string_append (printable, "{");

            for (thresholds_i = 0; thresholds_i < thresholds_n_items; thresholds_i++) {
                g_string_append_printf (printable, " [%u] = '", thresholds_i);

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%d", (gint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Signal Strength Indicator' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_event_report_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_event_report_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_event_report_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_RSRP_DELTA:
            tlv_type_str = "LTE RSRP Delta";
            translated_value = qmi_message_nas_set_event_report_input_lte_rsrp_delta_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_LTE_SNR_DELTA:
            tlv_type_str = "LTE SNR Delta";
            translated_value = qmi_message_nas_set_event_report_input_lte_snr_delta_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_THRESHOLD:
            tlv_type_str = "SINR Threshold";
            translated_value = qmi_message_nas_set_event_report_input_sinr_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_THRESHOLD:
            tlv_type_str = "ECIO Threshold";
            translated_value = qmi_message_nas_set_event_report_input_ecio_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ERROR_RATE_INDICATOR:
            tlv_type_str = "Error Rate Indicator";
            translated_value = qmi_message_nas_set_event_report_input_error_rate_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SINR_INDICATOR:
            tlv_type_str = "SINR Indicator";
            translated_value = qmi_message_nas_set_event_report_input_sinr_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_IO_INDICATOR:
            tlv_type_str = "IO Indicator";
            translated_value = qmi_message_nas_set_event_report_input_io_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_ECIO_INDICATOR:
            tlv_type_str = "ECIO Indicator";
            translated_value = qmi_message_nas_set_event_report_input_ecio_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RSSI_INDICATOR:
            tlv_type_str = "RSSI Indicator";
            translated_value = qmi_message_nas_set_event_report_input_rssi_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_REGISTRATION_REJECT_REASON:
            tlv_type_str = "Registration Reject Reason";
            translated_value = qmi_message_nas_set_event_report_input_registration_reject_reason_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_RF_BAND_INFORMATION:
            tlv_type_str = "RF Band Information";
            translated_value = qmi_message_nas_set_event_report_input_rf_band_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_INPUT_TLV_SIGNAL_STRENGTH_INDICATOR:
            tlv_type_str = "Signal Strength Indicator";
            translated_value = qmi_message_nas_set_event_report_input_signal_strength_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_event_report_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Event Report\" (0x0002)\n",
                            line_prefix);

    {
        struct message_set_event_report_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_event_report_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasSetEventReportOutput *
__qmi_message_nas_set_event_report_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasSetEventReportOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_SET_EVENT_REPORT, NULL);

    self = g_slice_new0 (QmiMessageNasSetEventReportOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_SET_EVENT_REPORT_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_set_event_report_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS Event Report */


/* --- Output -- */

struct _QmiIndicationNasEventReportOutput {
    volatile gint ref_count;

    /* LTE RSRP */
    gboolean arg_lte_rsrp_set;
    gint16 arg_lte_rsrp;

    /* LTE SNR */
    gboolean arg_lte_snr_set;
    gint16 arg_lte_snr;

    /* RSRQ */
    gboolean arg_rsrq_set;
    gint8 arg_rsrq_rsrq;
    gint8 arg_rsrq_radio_interface;

    /* Error Rate */
    gboolean arg_error_rate_set;
    guint16 arg_error_rate_rate;
    gint8 arg_error_rate_radio_interface;

    /* SINR */
    gboolean arg_sinr_set;
    guint8 arg_sinr;

    /* IO */
    gboolean arg_io_set;
    gint32 arg_io;

    /* ECIO */
    gboolean arg_ecio_set;
    gint8 arg_ecio_ecio;
    gint8 arg_ecio_radio_interface;

    /* RSSI */
    gboolean arg_rssi_set;
    guint8 arg_rssi_rssi;
    gint8 arg_rssi_radio_interface;

    /* Registration Reject Reason */
    gboolean arg_registration_reject_reason_set;
    guint8 arg_registration_reject_reason_service_domain;
    guint16 arg_registration_reject_reason_reject_cause;

    /* RF Band Information */
    gboolean arg_rf_band_information_set;
    GArray *arg_rf_band_information;

    /* Signal Strength */
    gboolean arg_signal_strength_set;
    gint8 arg_signal_strength_strength;
    gint8 arg_signal_strength_radio_interface;
};

#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_RSRP 0x1A
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_SNR 0x19
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSRQ 0x18
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ERROR_RATE 0x17
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SINR 0x16
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_IO 0x15
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ECIO 0x14
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSSI 0x13
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_REGISTRATION_REJECT_REASON 0x12
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RF_BAND_INFORMATION 0x11
#define QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SIGNAL_STRENGTH 0x10

/**
 * qmi_indication_nas_event_report_output_get_lte_rsrp:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @lte_rsrp: a placeholder for the output #gint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE RSRP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_lte_rsrp (
    QmiIndicationNasEventReportOutput *self,
    gint16 *lte_rsrp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_rsrp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE RSRP' was not found in the message");
        return FALSE;
    }

    if (lte_rsrp)
        *lte_rsrp = self->arg_lte_rsrp;

    return TRUE;
}

/**
 * qmi_indication_nas_event_report_output_get_lte_snr:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @lte_snr: a placeholder for the output #gint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE SNR' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_lte_snr (
    QmiIndicationNasEventReportOutput *self,
    gint16 *lte_snr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_snr_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE SNR' was not found in the message");
        return FALSE;
    }

    if (lte_snr)
        *lte_snr = self->arg_lte_snr;

    return TRUE;
}

/**
 * qmi_indication_nas_event_report_output_get_rsrq:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @rsrq_rsrq: a placeholder for the output #gint8, or %NULL if not required.
 * @rsrq_radio_interface: a placeholder for the output #QmiNasRadioInterface, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RSRQ' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_rsrq (
    QmiIndicationNasEventReportOutput *self,
    gint8 *rsrq_rsrq,
    QmiNasRadioInterface *rsrq_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rsrq_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSRQ' was not found in the message");
        return FALSE;
    }

    if (rsrq_rsrq)
        *rsrq_rsrq = self->arg_rsrq_rsrq;
    if (rsrq_radio_interface)
        *rsrq_radio_interface = (QmiNasRadioInterface)(self->arg_rsrq_radio_interface);

    return TRUE;
}

/**
 * qmi_indication_nas_event_report_output_get_error_rate:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @error_rate_rate: a placeholder for the output #guint16, or %NULL if not required.
 * @error_rate_radio_interface: a placeholder for the output #QmiNasRadioInterface, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Error Rate' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_error_rate (
    QmiIndicationNasEventReportOutput *self,
    guint16 *error_rate_rate,
    QmiNasRadioInterface *error_rate_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_error_rate_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Error Rate' was not found in the message");
        return FALSE;
    }

    if (error_rate_rate)
        *error_rate_rate = self->arg_error_rate_rate;
    if (error_rate_radio_interface)
        *error_rate_radio_interface = (QmiNasRadioInterface)(self->arg_error_rate_radio_interface);

    return TRUE;
}

/**
 * qmi_indication_nas_event_report_output_get_sinr:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @sinr: a placeholder for the output #QmiNasEvdoSinrLevel, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'SINR' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_sinr (
    QmiIndicationNasEventReportOutput *self,
    QmiNasEvdoSinrLevel *sinr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sinr_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SINR' was not found in the message");
        return FALSE;
    }

    if (sinr)
        *sinr = (QmiNasEvdoSinrLevel)(self->arg_sinr);

    return TRUE;
}

/**
 * qmi_indication_nas_event_report_output_get_io:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @io: a placeholder for the output #gint32, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'IO' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_io (
    QmiIndicationNasEventReportOutput *self,
    gint32 *io,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_io_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'IO' was not found in the message");
        return FALSE;
    }

    if (io)
        *io = self->arg_io;

    return TRUE;
}

/**
 * qmi_indication_nas_event_report_output_get_ecio:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @ecio_ecio: a placeholder for the output #gint8, or %NULL if not required.
 * @ecio_radio_interface: a placeholder for the output #QmiNasRadioInterface, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'ECIO' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_ecio (
    QmiIndicationNasEventReportOutput *self,
    gint8 *ecio_ecio,
    QmiNasRadioInterface *ecio_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ecio_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ECIO' was not found in the message");
        return FALSE;
    }

    if (ecio_ecio)
        *ecio_ecio = self->arg_ecio_ecio;
    if (ecio_radio_interface)
        *ecio_radio_interface = (QmiNasRadioInterface)(self->arg_ecio_radio_interface);

    return TRUE;
}

/**
 * qmi_indication_nas_event_report_output_get_rssi:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @rssi_rssi: a placeholder for the output #guint8, or %NULL if not required.
 * @rssi_radio_interface: a placeholder for the output #QmiNasRadioInterface, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RSSI' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_rssi (
    QmiIndicationNasEventReportOutput *self,
    guint8 *rssi_rssi,
    QmiNasRadioInterface *rssi_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rssi_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSSI' was not found in the message");
        return FALSE;
    }

    if (rssi_rssi)
        *rssi_rssi = self->arg_rssi_rssi;
    if (rssi_radio_interface)
        *rssi_radio_interface = (QmiNasRadioInterface)(self->arg_rssi_radio_interface);

    return TRUE;
}

/**
 * qmi_indication_nas_event_report_output_get_registration_reject_reason:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @registration_reject_reason_service_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @registration_reject_reason_reject_cause: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Registration Reject Reason' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_registration_reject_reason (
    QmiIndicationNasEventReportOutput *self,
    QmiNasNetworkServiceDomain *registration_reject_reason_service_domain,
    guint16 *registration_reject_reason_reject_cause,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_registration_reject_reason_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Registration Reject Reason' was not found in the message");
        return FALSE;
    }

    if (registration_reject_reason_service_domain)
        *registration_reject_reason_service_domain = (QmiNasNetworkServiceDomain)(self->arg_registration_reject_reason_service_domain);
    if (registration_reject_reason_reject_cause)
        *registration_reject_reason_reject_cause = self->arg_registration_reject_reason_reject_cause;

    return TRUE;
}

/**
 * qmi_indication_nas_event_report_output_get_rf_band_information:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @rf_band_information: a placeholder for the output #GArray of #QmiIndicationNasEventReportOutputRfBandInformationElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RF Band Information' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_rf_band_information (
    QmiIndicationNasEventReportOutput *self,
    GArray **rf_band_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rf_band_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RF Band Information' was not found in the message");
        return FALSE;
    }

    if (rf_band_information)
        *rf_band_information = self->arg_rf_band_information;

    return TRUE;
}

/**
 * qmi_indication_nas_event_report_output_get_signal_strength:
 * @self: a #QmiIndicationNasEventReportOutput.
 * @signal_strength_strength: a placeholder for the output #gint8, or %NULL if not required.
 * @signal_strength_radio_interface: a placeholder for the output #QmiNasRadioInterface, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_event_report_output_get_signal_strength (
    QmiIndicationNasEventReportOutput *self,
    gint8 *signal_strength_strength,
    QmiNasRadioInterface *signal_strength_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Signal Strength' was not found in the message");
        return FALSE;
    }

    if (signal_strength_strength)
        *signal_strength_strength = self->arg_signal_strength_strength;
    if (signal_strength_radio_interface)
        *signal_strength_radio_interface = (QmiNasRadioInterface)(self->arg_signal_strength_radio_interface);

    return TRUE;
}

GType
qmi_indication_nas_event_report_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasEventReportOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_event_report_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_event_report_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_indication_nas_event_report_output_ref:
 * @self: a #QmiIndicationNasEventReportOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiIndicationNasEventReportOutput *
qmi_indication_nas_event_report_output_ref (QmiIndicationNasEventReportOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_indication_nas_event_report_output_unref:
 * @self: a #QmiIndicationNasEventReportOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_indication_nas_event_report_output_unref (QmiIndicationNasEventReportOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_rf_band_information)
            g_array_unref (self->arg_rf_band_information);
        g_slice_free (QmiIndicationNasEventReportOutput, self);
    }
}

static gboolean
qmi_indication_nas_event_report_output_lte_rsrp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE RSRP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE RSRP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_lte_rsrp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_RSRP,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_lte_rsrp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE RSRP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_event_report_output_lte_snr_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE SNR' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE SNR' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_lte_snr_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_SNR,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_lte_snr_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE SNR' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_event_report_output_rsrq_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RSRQ' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RSRQ' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_rsrq_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSRQ,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_rsrq_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rsrq = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interface = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RSRQ' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_event_report_output_error_rate_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Error Rate' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Error Rate' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_error_rate_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ERROR_RATE,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_error_rate_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rate = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interface = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Error Rate' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_event_report_output_sinr_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'SINR' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'SINR' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_sinr_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SINR,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_sinr_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_evdo_sinr_level_get_string ((QmiNasEvdoSinrLevel)tmp));
#elif defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_evdo_sinr_level_build_string_from_mask ((QmiNasEvdoSinrLevel)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasEvdoSinrLevel
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'SINR' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_event_report_output_io_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'IO' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'IO' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_io_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_IO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_io_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'IO' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_event_report_output_ecio_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'ECIO' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'ECIO' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_ecio_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ECIO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_ecio_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " ecio = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interface = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'ECIO' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_event_report_output_rssi_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RSSI' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RSSI' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_rssi_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSSI,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_rssi_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rssi = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interface = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RSSI' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_event_report_output_registration_reject_reason_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Registration Reject Reason' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Registration Reject Reason' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_registration_reject_reason_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_REGISTRATION_REJECT_REASON,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_registration_reject_reason_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " reject_cause = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Registration Reject Reason' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_event_report_output_rf_band_information_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint rf_band_information_i;
        guint8 rf_band_information_n_items;
        const guint8 *rf_band_information_aux_buffer = &buffer[expected_len];
        guint16 rf_band_information_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &rf_band_information_aux_buffer,
            &rf_band_information_aux_buffer_len,
            &(rf_band_information_n_items));
        for (rf_band_information_i = 0; rf_band_information_i < rf_band_information_n_items; rf_band_information_i++) {

            expected_len += 1;
            expected_len += 2;
            expected_len += 2;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RF Band Information' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RF Band Information' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_rf_band_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RF_BAND_INFORMATION,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_rf_band_information_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint rf_band_information_i;
            guint8 rf_band_information_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(rf_band_information_n_items));

            g_string_append (printable, "{");

            for (rf_band_information_i = 0; rf_band_information_i < rf_band_information_n_items; rf_band_information_i++) {
                g_string_append_printf (printable, " [%u] = '", rf_band_information_i);
                g_string_append (printable, "[");
                g_string_append (printable, " radio_interface = '");

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " active_band_class = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

#if defined  __QMI_NAS_ACTIVE_BAND_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_active_band_get_string ((QmiNasActiveBand)tmp));
#elif defined  __QMI_NAS_ACTIVE_BAND_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_active_band_build_string_from_mask ((QmiNasActiveBand)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasActiveBand
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " active_channel = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RF Band Information' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_event_report_output_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_event_report_output_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_event_report_output_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " strength = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interface = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct indication_event_report_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_event_report_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_event_report_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    {
        switch (type) {
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_RSRP:
            tlv_type_str = "LTE RSRP";
            translated_value = qmi_indication_nas_event_report_output_lte_rsrp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_SNR:
            tlv_type_str = "LTE SNR";
            translated_value = qmi_indication_nas_event_report_output_lte_snr_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSRQ:
            tlv_type_str = "RSRQ";
            translated_value = qmi_indication_nas_event_report_output_rsrq_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ERROR_RATE:
            tlv_type_str = "Error Rate";
            translated_value = qmi_indication_nas_event_report_output_error_rate_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SINR:
            tlv_type_str = "SINR";
            translated_value = qmi_indication_nas_event_report_output_sinr_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_IO:
            tlv_type_str = "IO";
            translated_value = qmi_indication_nas_event_report_output_io_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ECIO:
            tlv_type_str = "ECIO";
            translated_value = qmi_indication_nas_event_report_output_ecio_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSSI:
            tlv_type_str = "RSSI";
            translated_value = qmi_indication_nas_event_report_output_rssi_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_REGISTRATION_REJECT_REASON:
            tlv_type_str = "Registration Reject Reason";
            translated_value = qmi_indication_nas_event_report_output_registration_reject_reason_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RF_BAND_INFORMATION:
            tlv_type_str = "RF Band Information";
            translated_value = qmi_indication_nas_event_report_output_rf_band_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SIGNAL_STRENGTH:
            tlv_type_str = "Signal Strength";
            translated_value = qmi_indication_nas_event_report_output_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
indication_event_report_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Event Report\" (0x0002)\n",
                            line_prefix);

    {
        struct indication_event_report_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_event_report_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasEventReportOutput *
__qmi_indication_nas_event_report_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasEventReportOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_INDICATION_NAS_EVENT_REPORT, NULL);

    self = g_slice_new0 (QmiIndicationNasEventReportOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_RSRP,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_lte_rsrp_validate (buffer, buffer_len)) {
                self->arg_lte_rsrp_set = TRUE;

                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_rsrp));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE RSRP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_LTE_SNR,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_lte_snr_validate (buffer, buffer_len)) {
                self->arg_lte_snr_set = TRUE;

                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_snr));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE SNR' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSRQ,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_rsrq_validate (buffer, buffer_len)) {
                self->arg_rsrq_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_rsrq_rsrq));
                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_rsrq_radio_interface = (QmiNasRadioInterface)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'RSRQ' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ERROR_RATE,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_error_rate_validate (buffer, buffer_len)) {
                self->arg_error_rate_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_error_rate_rate));
                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_error_rate_radio_interface = (QmiNasRadioInterface)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Error Rate' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SINR,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_sinr_validate (buffer, buffer_len)) {
                self->arg_sinr_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_sinr = (QmiNasEvdoSinrLevel)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'SINR' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_IO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_io_validate (buffer, buffer_len)) {
                self->arg_io_set = TRUE;

                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_io));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'IO' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_ECIO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_ecio_validate (buffer, buffer_len)) {
                self->arg_ecio_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_ecio_ecio));
                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_ecio_radio_interface = (QmiNasRadioInterface)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'ECIO' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RSSI,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_rssi_validate (buffer, buffer_len)) {
                self->arg_rssi_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_rssi_rssi));
                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_rssi_radio_interface = (QmiNasRadioInterface)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'RSSI' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_REGISTRATION_REJECT_REASON,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_registration_reject_reason_validate (buffer, buffer_len)) {
                self->arg_registration_reject_reason_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_registration_reject_reason_service_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_registration_reject_reason_reject_cause));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Registration Reject Reason' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_RF_BAND_INFORMATION,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_rf_band_information_validate (buffer, buffer_len)) {
                self->arg_rf_band_information_set = TRUE;

                {
                    guint rf_band_information_i;
                    guint8 rf_band_information_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(rf_band_information_n_items));

                    self->arg_rf_band_information = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiIndicationNasEventReportOutputRfBandInformationElement),
                        (guint)rf_band_information_n_items);

                    for (rf_band_information_i = 0; rf_band_information_i < rf_band_information_n_items; rf_band_information_i++) {
                        QmiIndicationNasEventReportOutputRfBandInformationElement rf_band_information_aux;

                        {
                            gint8 tmp;

                            /* Read the gint8 variable from the buffer */
                            qmi_utils_read_gint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            rf_band_information_aux.radio_interface = (QmiNasRadioInterface)tmp;
                        }
                        {
                            guint16 tmp;

                            /* Read the guint16 variable from the buffer */
                            qmi_utils_read_guint16_from_buffer (
                                &buffer,
                                &buffer_len,
                                QMI_ENDIAN_LITTLE,
                                &tmp);
                            rf_band_information_aux.active_band_class = (QmiNasActiveBand)tmp;
                        }
                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(rf_band_information_aux.active_channel));
                        g_array_insert_val (self->arg_rf_band_information, rf_band_information_i, rf_band_information_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'RF Band Information' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_EVENT_REPORT_OUTPUT_TLV_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_event_report_output_signal_strength_validate (buffer, buffer_len)) {
                self->arg_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_signal_strength_strength));
                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_signal_strength_radio_interface = (QmiNasRadioInterface)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Register Indications */


/* --- Input -- */

struct _QmiMessageNasRegisterIndicationsInput {
    volatile gint ref_count;

    /* RF Band Information */
    gboolean arg_rf_band_information_set;
    guint8 arg_rf_band_information;

    /* eMBMS Status */
    gboolean arg_embms_status_set;
    guint8 arg_embms_status;

    /* Current PLMN Name */
    gboolean arg_current_plmn_name_set;
    guint8 arg_current_plmn_name;

    /* Managed Roaming */
    gboolean arg_managed_roaming_set;
    guint8 arg_managed_roaming;

    /* HDR Session Closed */
    gboolean arg_hdr_session_closed_set;
    guint8 arg_hdr_session_closed;

    /* HDR New UATI Assigned */
    gboolean arg_hdr_new_uati_assigned_set;
    guint8 arg_hdr_new_uati_assigned;

    /* Error Rate */
    gboolean arg_error_rate_set;
    guint8 arg_error_rate;

    /* Signal Info */
    gboolean arg_signal_info_set;
    guint8 arg_signal_info;

    /* System Info */
    gboolean arg_system_info_set;
    guint8 arg_system_info;

    /* Network Time */
    gboolean arg_network_time_set;
    guint8 arg_network_time;

    /* Subscription Info */
    gboolean arg_subscription_info_set;
    guint8 arg_subscription_info;

    /* Dual Standby Preference */
    gboolean arg_dual_standby_preference_set;
    guint8 arg_dual_standby_preference;

    /* Serving System Events */
    gboolean arg_serving_system_events_set;
    guint8 arg_serving_system_events;

    /* DDTM Events */
    gboolean arg_ddtm_events_set;
    guint8 arg_ddtm_events;

    /* System Selection Preference */
    gboolean arg_system_selection_preference_set;
    guint8 arg_system_selection_preference;
};

#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_RF_BAND_INFORMATION 0x20
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_EMBMS_STATUS 0x1F
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_CURRENT_PLMN_NAME 0x1E
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_MANAGED_ROAMING 0x1D
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_SESSION_CLOSED 0x1C
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_NEW_UATI_ASSIGNED 0x1B
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_ERROR_RATE 0x1A
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SIGNAL_INFO 0x19
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_INFO 0x18
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_TIME 0x17
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SUBSCRIPTION_INFO 0x15
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DUAL_STANDBY_PREFERENCE 0x14
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SERVING_SYSTEM_EVENTS 0x13
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DDTM_EVENTS 0x12
#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_SELECTION_PREFERENCE 0x10

/**
 * qmi_message_nas_register_indications_input_get_rf_band_information:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @rf_band_information: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RF Band Information' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_rf_band_information (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *rf_band_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rf_band_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RF Band Information' was not found in the message");
        return FALSE;
    }

    if (rf_band_information)
        *rf_band_information = (gboolean)(self->arg_rf_band_information);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_rf_band_information:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @rf_band_information: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'RF Band Information' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_rf_band_information (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean rf_band_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_rf_band_information = (guint8)(rf_band_information);
    self->arg_rf_band_information_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_embms_status:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @embms_status: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'eMBMS Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_embms_status (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *embms_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_embms_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'eMBMS Status' was not found in the message");
        return FALSE;
    }

    if (embms_status)
        *embms_status = (gboolean)(self->arg_embms_status);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_embms_status:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @embms_status: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'eMBMS Status' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_embms_status (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean embms_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_embms_status = (guint8)(embms_status);
    self->arg_embms_status_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_current_plmn_name:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @current_plmn_name: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Current PLMN Name' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_current_plmn_name (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *current_plmn_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_current_plmn_name_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Current PLMN Name' was not found in the message");
        return FALSE;
    }

    if (current_plmn_name)
        *current_plmn_name = (gboolean)(self->arg_current_plmn_name);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_current_plmn_name:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @current_plmn_name: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Current PLMN Name' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_current_plmn_name (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean current_plmn_name,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_current_plmn_name = (guint8)(current_plmn_name);
    self->arg_current_plmn_name_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_managed_roaming:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @managed_roaming: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Managed Roaming' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_managed_roaming (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *managed_roaming,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_managed_roaming_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Managed Roaming' was not found in the message");
        return FALSE;
    }

    if (managed_roaming)
        *managed_roaming = (gboolean)(self->arg_managed_roaming);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_managed_roaming:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @managed_roaming: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Managed Roaming' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_managed_roaming (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean managed_roaming,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_managed_roaming = (guint8)(managed_roaming);
    self->arg_managed_roaming_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_hdr_session_closed:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @hdr_session_closed: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'HDR Session Closed' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_hdr_session_closed (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *hdr_session_closed,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_session_closed_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Session Closed' was not found in the message");
        return FALSE;
    }

    if (hdr_session_closed)
        *hdr_session_closed = (gboolean)(self->arg_hdr_session_closed);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_hdr_session_closed:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @hdr_session_closed: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'HDR Session Closed' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_hdr_session_closed (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean hdr_session_closed,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_hdr_session_closed = (guint8)(hdr_session_closed);
    self->arg_hdr_session_closed_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_hdr_new_uati_assigned:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @hdr_new_uati_assigned: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'HDR New UATI Assigned' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_hdr_new_uati_assigned (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *hdr_new_uati_assigned,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_new_uati_assigned_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR New UATI Assigned' was not found in the message");
        return FALSE;
    }

    if (hdr_new_uati_assigned)
        *hdr_new_uati_assigned = (gboolean)(self->arg_hdr_new_uati_assigned);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_hdr_new_uati_assigned:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @hdr_new_uati_assigned: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'HDR New UATI Assigned' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_hdr_new_uati_assigned (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean hdr_new_uati_assigned,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_hdr_new_uati_assigned = (guint8)(hdr_new_uati_assigned);
    self->arg_hdr_new_uati_assigned_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_error_rate:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @error_rate: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Error Rate' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_error_rate (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *error_rate,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_error_rate_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Error Rate' was not found in the message");
        return FALSE;
    }

    if (error_rate)
        *error_rate = (gboolean)(self->arg_error_rate);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_error_rate:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @error_rate: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Error Rate' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_error_rate (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean error_rate,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_error_rate = (guint8)(error_rate);
    self->arg_error_rate_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_signal_info:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @signal_info: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Signal Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_signal_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *signal_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_signal_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Signal Info' was not found in the message");
        return FALSE;
    }

    if (signal_info)
        *signal_info = (gboolean)(self->arg_signal_info);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_signal_info:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @signal_info: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Signal Info' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_signal_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean signal_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_signal_info = (guint8)(signal_info);
    self->arg_signal_info_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_system_info:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @system_info: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_system_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *system_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'System Info' was not found in the message");
        return FALSE;
    }

    if (system_info)
        *system_info = (gboolean)(self->arg_system_info);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_system_info:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @system_info: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'System Info' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_system_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean system_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_system_info = (guint8)(system_info);
    self->arg_system_info_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_network_time:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @network_time: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Network Time' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_network_time (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *network_time,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_time_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Time' was not found in the message");
        return FALSE;
    }

    if (network_time)
        *network_time = (gboolean)(self->arg_network_time);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_network_time:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @network_time: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Network Time' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_network_time (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean network_time,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_network_time = (guint8)(network_time);
    self->arg_network_time_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_subscription_info:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @subscription_info: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Subscription Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_subscription_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *subscription_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_subscription_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Subscription Info' was not found in the message");
        return FALSE;
    }

    if (subscription_info)
        *subscription_info = (gboolean)(self->arg_subscription_info);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_subscription_info:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @subscription_info: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Subscription Info' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_subscription_info (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean subscription_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_subscription_info = (guint8)(subscription_info);
    self->arg_subscription_info_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_dual_standby_preference:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @dual_standby_preference: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Dual Standby Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_dual_standby_preference (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *dual_standby_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_dual_standby_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Dual Standby Preference' was not found in the message");
        return FALSE;
    }

    if (dual_standby_preference)
        *dual_standby_preference = (gboolean)(self->arg_dual_standby_preference);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_dual_standby_preference:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @dual_standby_preference: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Dual Standby Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_dual_standby_preference (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean dual_standby_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_dual_standby_preference = (guint8)(dual_standby_preference);
    self->arg_dual_standby_preference_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_serving_system_events:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @serving_system_events: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Serving System Events' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_serving_system_events (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *serving_system_events,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_serving_system_events_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Serving System Events' was not found in the message");
        return FALSE;
    }

    if (serving_system_events)
        *serving_system_events = (gboolean)(self->arg_serving_system_events);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_serving_system_events:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @serving_system_events: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Serving System Events' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_serving_system_events (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean serving_system_events,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_serving_system_events = (guint8)(serving_system_events);
    self->arg_serving_system_events_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_ddtm_events:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @ddtm_events: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'DDTM Events' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_ddtm_events (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *ddtm_events,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ddtm_events_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'DDTM Events' was not found in the message");
        return FALSE;
    }

    if (ddtm_events)
        *ddtm_events = (gboolean)(self->arg_ddtm_events);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_ddtm_events:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @ddtm_events: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'DDTM Events' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_ddtm_events (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean ddtm_events,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_ddtm_events = (guint8)(ddtm_events);
    self->arg_ddtm_events_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_get_system_selection_preference:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @system_selection_preference: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'System Selection Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_get_system_selection_preference (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean *system_selection_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_system_selection_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'System Selection Preference' was not found in the message");
        return FALSE;
    }

    if (system_selection_preference)
        *system_selection_preference = (gboolean)(self->arg_system_selection_preference);

    return TRUE;
}

/**
 * qmi_message_nas_register_indications_input_set_system_selection_preference:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 * @system_selection_preference: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'System Selection Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_register_indications_input_set_system_selection_preference (
    QmiMessageNasRegisterIndicationsInput *self,
    gboolean system_selection_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_system_selection_preference = (guint8)(system_selection_preference);
    self->arg_system_selection_preference_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_register_indications_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasRegisterIndicationsInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_register_indications_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_register_indications_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_register_indications_input_ref:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasRegisterIndicationsInput *
qmi_message_nas_register_indications_input_ref (QmiMessageNasRegisterIndicationsInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_register_indications_input_unref:
 * @self: a #QmiMessageNasRegisterIndicationsInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_register_indications_input_unref (QmiMessageNasRegisterIndicationsInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasRegisterIndicationsInput, self);
    }
}

/**
 * qmi_message_nas_register_indications_input_new:
 *
 * Allocates a new #QmiMessageNasRegisterIndicationsInput.
 *
 * Returns: the newly created #QmiMessageNasRegisterIndicationsInput. The returned value should be freed with qmi_message_nas_register_indications_input_unref().
 */
QmiMessageNasRegisterIndicationsInput *
qmi_message_nas_register_indications_input_new (void)
{
    QmiMessageNasRegisterIndicationsInput *self;

    self = g_slice_new0 (QmiMessageNasRegisterIndicationsInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_register_indications_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageNasRegisterIndicationsInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_REGISTER_INDICATIONS);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return self;

    /* Try to add the 'RF Band Information' TLV */
    if (input->arg_rf_band_information_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_rf_band_information;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_RF_BAND_INFORMATION,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the RF Band Information TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'eMBMS Status' TLV */
    if (input->arg_embms_status_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_embms_status;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_EMBMS_STATUS,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the eMBMS Status TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Current PLMN Name' TLV */
    if (input->arg_current_plmn_name_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_current_plmn_name;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_CURRENT_PLMN_NAME,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Current PLMN Name TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Managed Roaming' TLV */
    if (input->arg_managed_roaming_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_managed_roaming;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_MANAGED_ROAMING,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Managed Roaming TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'HDR Session Closed' TLV */
    if (input->arg_hdr_session_closed_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_hdr_session_closed;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_SESSION_CLOSED,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the HDR Session Closed TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'HDR New UATI Assigned' TLV */
    if (input->arg_hdr_new_uati_assigned_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_hdr_new_uati_assigned;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_NEW_UATI_ASSIGNED,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the HDR New UATI Assigned TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Error Rate' TLV */
    if (input->arg_error_rate_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_error_rate;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_ERROR_RATE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Error Rate TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Signal Info' TLV */
    if (input->arg_signal_info_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_signal_info;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SIGNAL_INFO,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Signal Info TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'System Info' TLV */
    if (input->arg_system_info_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_system_info;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_INFO,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the System Info TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Network Time' TLV */
    if (input->arg_network_time_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_network_time;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_TIME,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Network Time TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Subscription Info' TLV */
    if (input->arg_subscription_info_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_subscription_info;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SUBSCRIPTION_INFO,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Subscription Info TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Dual Standby Preference' TLV */
    if (input->arg_dual_standby_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_dual_standby_preference;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DUAL_STANDBY_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Dual Standby Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Serving System Events' TLV */
    if (input->arg_serving_system_events_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_serving_system_events;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SERVING_SYSTEM_EVENTS,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Serving System Events TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'DDTM Events' TLV */
    if (input->arg_ddtm_events_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_ddtm_events;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DDTM_EVENTS,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the DDTM Events TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'System Selection Preference' TLV */
    if (input->arg_system_selection_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_system_selection_preference;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_SELECTION_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the System Selection Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageNasRegisterIndicationsOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_REGISTER_INDICATIONS_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_nas_register_indications_output_get_result:
 * @self: a QmiMessageNasRegisterIndicationsOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_register_indications_output_get_result (
    QmiMessageNasRegisterIndicationsOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_register_indications_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasRegisterIndicationsOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_register_indications_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_register_indications_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_register_indications_output_ref:
 * @self: a #QmiMessageNasRegisterIndicationsOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasRegisterIndicationsOutput *
qmi_message_nas_register_indications_output_ref (QmiMessageNasRegisterIndicationsOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_register_indications_output_unref:
 * @self: a #QmiMessageNasRegisterIndicationsOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_register_indications_output_unref (QmiMessageNasRegisterIndicationsOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasRegisterIndicationsOutput, self);
    }
}

static gboolean
qmi_message_nas_register_indications_input_rf_band_information_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RF Band Information' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RF Band Information' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_rf_band_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_RF_BAND_INFORMATION,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_rf_band_information_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RF Band Information' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_embms_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'eMBMS Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'eMBMS Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_embms_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_EMBMS_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_embms_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'eMBMS Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_current_plmn_name_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Current PLMN Name' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Current PLMN Name' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_current_plmn_name_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_CURRENT_PLMN_NAME,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_current_plmn_name_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Current PLMN Name' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_managed_roaming_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Managed Roaming' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Managed Roaming' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_managed_roaming_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_MANAGED_ROAMING,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_managed_roaming_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Managed Roaming' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_hdr_session_closed_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'HDR Session Closed' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'HDR Session Closed' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_hdr_session_closed_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_SESSION_CLOSED,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_hdr_session_closed_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'HDR Session Closed' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_hdr_new_uati_assigned_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'HDR New UATI Assigned' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'HDR New UATI Assigned' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_hdr_new_uati_assigned_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_NEW_UATI_ASSIGNED,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_hdr_new_uati_assigned_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'HDR New UATI Assigned' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_error_rate_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Error Rate' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Error Rate' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_error_rate_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_ERROR_RATE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_error_rate_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Error Rate' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_signal_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Signal Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Signal Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_signal_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SIGNAL_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_signal_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Signal Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_network_time_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Network Time' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Network Time' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_network_time_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_TIME,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_network_time_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Network Time' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_subscription_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Subscription Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Subscription Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_subscription_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SUBSCRIPTION_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_subscription_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Subscription Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_dual_standby_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Dual Standby Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Dual Standby Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_dual_standby_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DUAL_STANDBY_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_dual_standby_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Dual Standby Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_serving_system_events_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Serving System Events' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Serving System Events' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_serving_system_events_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SERVING_SYSTEM_EVENTS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_serving_system_events_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Serving System Events' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_ddtm_events_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'DDTM Events' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'DDTM Events' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_ddtm_events_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DDTM_EVENTS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_ddtm_events_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'DDTM Events' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_register_indications_input_system_selection_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'System Selection Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'System Selection Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_register_indications_input_system_selection_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_SELECTION_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_register_indications_input_system_selection_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'System Selection Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_register_indications_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_register_indications_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_register_indications_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_RF_BAND_INFORMATION:
            tlv_type_str = "RF Band Information";
            translated_value = qmi_message_nas_register_indications_input_rf_band_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_EMBMS_STATUS:
            tlv_type_str = "eMBMS Status";
            translated_value = qmi_message_nas_register_indications_input_embms_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_CURRENT_PLMN_NAME:
            tlv_type_str = "Current PLMN Name";
            translated_value = qmi_message_nas_register_indications_input_current_plmn_name_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_MANAGED_ROAMING:
            tlv_type_str = "Managed Roaming";
            translated_value = qmi_message_nas_register_indications_input_managed_roaming_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_SESSION_CLOSED:
            tlv_type_str = "HDR Session Closed";
            translated_value = qmi_message_nas_register_indications_input_hdr_session_closed_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_HDR_NEW_UATI_ASSIGNED:
            tlv_type_str = "HDR New UATI Assigned";
            translated_value = qmi_message_nas_register_indications_input_hdr_new_uati_assigned_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_ERROR_RATE:
            tlv_type_str = "Error Rate";
            translated_value = qmi_message_nas_register_indications_input_error_rate_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SIGNAL_INFO:
            tlv_type_str = "Signal Info";
            translated_value = qmi_message_nas_register_indications_input_signal_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_INFO:
            tlv_type_str = "System Info";
            translated_value = qmi_message_nas_register_indications_input_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_NETWORK_TIME:
            tlv_type_str = "Network Time";
            translated_value = qmi_message_nas_register_indications_input_network_time_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SUBSCRIPTION_INFO:
            tlv_type_str = "Subscription Info";
            translated_value = qmi_message_nas_register_indications_input_subscription_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DUAL_STANDBY_PREFERENCE:
            tlv_type_str = "Dual Standby Preference";
            translated_value = qmi_message_nas_register_indications_input_dual_standby_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SERVING_SYSTEM_EVENTS:
            tlv_type_str = "Serving System Events";
            translated_value = qmi_message_nas_register_indications_input_serving_system_events_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_DDTM_EVENTS:
            tlv_type_str = "DDTM Events";
            translated_value = qmi_message_nas_register_indications_input_ddtm_events_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_INPUT_TLV_SYSTEM_SELECTION_PREFERENCE:
            tlv_type_str = "System Selection Preference";
            translated_value = qmi_message_nas_register_indications_input_system_selection_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_register_indications_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Register Indications\" (0x0003)\n",
                            line_prefix);

    {
        struct message_register_indications_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_register_indications_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasRegisterIndicationsOutput *
__qmi_message_nas_register_indications_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasRegisterIndicationsOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_REGISTER_INDICATIONS, NULL);

    self = g_slice_new0 (QmiMessageNasRegisterIndicationsOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_REGISTER_INDICATIONS_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_register_indications_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Signal Strength */


/* --- Input -- */

struct _QmiMessageNasGetSignalStrengthInput {
    volatile gint ref_count;

    /* Request Mask */
    gboolean arg_request_mask_set;
    guint16 arg_request_mask;
};

#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_INPUT_TLV_REQUEST_MASK 0x10

/**
 * qmi_message_nas_get_signal_strength_input_get_request_mask:
 * @self: a #QmiMessageNasGetSignalStrengthInput.
 * @request_mask: a placeholder for the output #QmiNasSignalStrengthRequest, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Request Mask' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_input_get_request_mask (
    QmiMessageNasGetSignalStrengthInput *self,
    QmiNasSignalStrengthRequest *request_mask,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_request_mask_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Request Mask' was not found in the message");
        return FALSE;
    }

    if (request_mask)
        *request_mask = (QmiNasSignalStrengthRequest)(self->arg_request_mask);

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_strength_input_set_request_mask:
 * @self: a #QmiMessageNasGetSignalStrengthInput.
 * @request_mask: a #QmiNasSignalStrengthRequest.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Request Mask' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_input_set_request_mask (
    QmiMessageNasGetSignalStrengthInput *self,
    QmiNasSignalStrengthRequest request_mask,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_request_mask = (guint16)(request_mask);
    self->arg_request_mask_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_get_signal_strength_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSignalStrengthInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_signal_strength_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_signal_strength_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_get_signal_strength_input_ref:
 * @self: a #QmiMessageNasGetSignalStrengthInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasGetSignalStrengthInput *
qmi_message_nas_get_signal_strength_input_ref (QmiMessageNasGetSignalStrengthInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_get_signal_strength_input_unref:
 * @self: a #QmiMessageNasGetSignalStrengthInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_get_signal_strength_input_unref (QmiMessageNasGetSignalStrengthInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetSignalStrengthInput, self);
    }
}

/**
 * qmi_message_nas_get_signal_strength_input_new:
 *
 * Allocates a new #QmiMessageNasGetSignalStrengthInput.
 *
 * Returns: the newly created #QmiMessageNasGetSignalStrengthInput. The returned value should be freed with qmi_message_nas_get_signal_strength_input_unref().
 */
QmiMessageNasGetSignalStrengthInput *
qmi_message_nas_get_signal_strength_input_new (void)
{
    QmiMessageNasGetSignalStrengthInput *self;

    self = g_slice_new0 (QmiMessageNasGetSignalStrengthInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_get_signal_strength_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageNasGetSignalStrengthInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return self;

    /* Try to add the 'Request Mask' TLV */
    if (input->arg_request_mask_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint16 tmp;

            tmp = (guint16)input->arg_request_mask;
            /* Write the guint16 variable to the buffer */
            qmi_utils_write_guint16_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_INPUT_TLV_REQUEST_MASK,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Request Mask TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageNasGetSignalStrengthOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* LTE RSRP */
    gboolean arg_lte_rsrp_set;
    gint16 arg_lte_rsrp;

    /* LTE SNR */
    gboolean arg_lte_snr_set;
    gint16 arg_lte_snr;

    /* RSRQ */
    gboolean arg_rsrq_set;
    gint8 arg_rsrq_rsrq;
    gint8 arg_rsrq_radio_interface;

    /* Error Rate List */
    gboolean arg_error_rate_list_set;
    GArray *arg_error_rate_list;

    /* SINR */
    gboolean arg_sinr_set;
    guint8 arg_sinr;

    /* IO */
    gboolean arg_io_set;
    gint32 arg_io;

    /* ECIO List */
    gboolean arg_ecio_list_set;
    GArray *arg_ecio_list;

    /* RSSI List */
    gboolean arg_rssi_list_set;
    GArray *arg_rssi_list;

    /* Strength List */
    gboolean arg_strength_list_set;
    GArray *arg_strength_list;

    /* Signal Strength */
    gboolean arg_signal_strength_set;
    gint8 arg_signal_strength_strength;
    gint8 arg_signal_strength_radio_interface;
};

#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_RSRP 0x18
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_SNR 0x17
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSRQ 0x16
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ERROR_RATE_LIST 0x15
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SINR 0x14
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_IO 0x13
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ECIO_LIST 0x12
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSSI_LIST 0x11
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_STRENGTH_LIST 0x10
#define QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SIGNAL_STRENGTH 0x01

/**
 * qmi_message_nas_get_signal_strength_output_get_result:
 * @self: a QmiMessageNasGetSignalStrengthOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_result (
    QmiMessageNasGetSignalStrengthOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_nas_get_signal_strength_output_get_lte_rsrp:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 * @lte_rsrp: a placeholder for the output #gint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE RSRP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_lte_rsrp (
    QmiMessageNasGetSignalStrengthOutput *self,
    gint16 *lte_rsrp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_rsrp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE RSRP' was not found in the message");
        return FALSE;
    }

    if (lte_rsrp)
        *lte_rsrp = self->arg_lte_rsrp;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_strength_output_get_lte_snr:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 * @lte_snr: a placeholder for the output #gint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE SNR' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_lte_snr (
    QmiMessageNasGetSignalStrengthOutput *self,
    gint16 *lte_snr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_snr_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE SNR' was not found in the message");
        return FALSE;
    }

    if (lte_snr)
        *lte_snr = self->arg_lte_snr;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_strength_output_get_rsrq:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 * @rsrq_rsrq: a placeholder for the output #gint8, or %NULL if not required.
 * @rsrq_radio_interface: a placeholder for the output #QmiNasRadioInterface, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RSRQ' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_rsrq (
    QmiMessageNasGetSignalStrengthOutput *self,
    gint8 *rsrq_rsrq,
    QmiNasRadioInterface *rsrq_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rsrq_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSRQ' was not found in the message");
        return FALSE;
    }

    if (rsrq_rsrq)
        *rsrq_rsrq = self->arg_rsrq_rsrq;
    if (rsrq_radio_interface)
        *rsrq_radio_interface = (QmiNasRadioInterface)(self->arg_rsrq_radio_interface);

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_strength_output_get_error_rate_list:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 * @error_rate_list: a placeholder for the output #GArray of #QmiMessageNasGetSignalStrengthOutputErrorRateListElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Error Rate List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_error_rate_list (
    QmiMessageNasGetSignalStrengthOutput *self,
    GArray **error_rate_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_error_rate_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Error Rate List' was not found in the message");
        return FALSE;
    }

    if (error_rate_list)
        *error_rate_list = self->arg_error_rate_list;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_strength_output_get_sinr:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 * @sinr: a placeholder for the output #QmiNasEvdoSinrLevel, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'SINR' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_sinr (
    QmiMessageNasGetSignalStrengthOutput *self,
    QmiNasEvdoSinrLevel *sinr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sinr_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SINR' was not found in the message");
        return FALSE;
    }

    if (sinr)
        *sinr = (QmiNasEvdoSinrLevel)(self->arg_sinr);

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_strength_output_get_io:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 * @io: a placeholder for the output #gint32, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'IO' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_io (
    QmiMessageNasGetSignalStrengthOutput *self,
    gint32 *io,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_io_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'IO' was not found in the message");
        return FALSE;
    }

    if (io)
        *io = self->arg_io;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_strength_output_get_ecio_list:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 * @ecio_list: a placeholder for the output #GArray of #QmiMessageNasGetSignalStrengthOutputEcioListElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'ECIO List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_ecio_list (
    QmiMessageNasGetSignalStrengthOutput *self,
    GArray **ecio_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ecio_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ECIO List' was not found in the message");
        return FALSE;
    }

    if (ecio_list)
        *ecio_list = self->arg_ecio_list;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_strength_output_get_rssi_list:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 * @rssi_list: a placeholder for the output #GArray of #QmiMessageNasGetSignalStrengthOutputRssiListElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RSSI List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_rssi_list (
    QmiMessageNasGetSignalStrengthOutput *self,
    GArray **rssi_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rssi_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSSI List' was not found in the message");
        return FALSE;
    }

    if (rssi_list)
        *rssi_list = self->arg_rssi_list;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_strength_output_get_strength_list:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 * @strength_list: a placeholder for the output #GArray of #QmiMessageNasGetSignalStrengthOutputStrengthListElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Strength List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_strength_list (
    QmiMessageNasGetSignalStrengthOutput *self,
    GArray **strength_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_strength_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Strength List' was not found in the message");
        return FALSE;
    }

    if (strength_list)
        *strength_list = self->arg_strength_list;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_strength_output_get_signal_strength:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 * @signal_strength_strength: a placeholder for the output #gint8, or %NULL if not required.
 * @signal_strength_radio_interface: a placeholder for the output #QmiNasRadioInterface, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_strength_output_get_signal_strength (
    QmiMessageNasGetSignalStrengthOutput *self,
    gint8 *signal_strength_strength,
    QmiNasRadioInterface *signal_strength_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Signal Strength' was not found in the message");
        return FALSE;
    }

    if (signal_strength_strength)
        *signal_strength_strength = self->arg_signal_strength_strength;
    if (signal_strength_radio_interface)
        *signal_strength_radio_interface = (QmiNasRadioInterface)(self->arg_signal_strength_radio_interface);

    return TRUE;
}

GType
qmi_message_nas_get_signal_strength_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSignalStrengthOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_signal_strength_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_signal_strength_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_get_signal_strength_output_ref:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasGetSignalStrengthOutput *
qmi_message_nas_get_signal_strength_output_ref (QmiMessageNasGetSignalStrengthOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_get_signal_strength_output_unref:
 * @self: a #QmiMessageNasGetSignalStrengthOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_get_signal_strength_output_unref (QmiMessageNasGetSignalStrengthOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_error_rate_list)
            g_array_unref (self->arg_error_rate_list);
        if (self->arg_ecio_list)
            g_array_unref (self->arg_ecio_list);
        if (self->arg_rssi_list)
            g_array_unref (self->arg_rssi_list);
        if (self->arg_strength_list)
            g_array_unref (self->arg_strength_list);
        g_slice_free (QmiMessageNasGetSignalStrengthOutput, self);
    }
}

static gboolean
qmi_message_nas_get_signal_strength_input_request_mask_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Request Mask' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Request Mask' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_input_request_mask_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_INPUT_TLV_REQUEST_MASK,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_input_request_mask_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_SIGNAL_STRENGTH_REQUEST_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_signal_strength_request_get_string ((QmiNasSignalStrengthRequest)tmp));
#elif defined  __QMI_NAS_SIGNAL_STRENGTH_REQUEST_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_signal_strength_request_build_string_from_mask ((QmiNasSignalStrengthRequest)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasSignalStrengthRequest
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Request Mask' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_strength_output_lte_rsrp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE RSRP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE RSRP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_output_lte_rsrp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_RSRP,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_output_lte_rsrp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE RSRP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_strength_output_lte_snr_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE SNR' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE SNR' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_output_lte_snr_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_SNR,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_output_lte_snr_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE SNR' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_strength_output_rsrq_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RSRQ' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RSRQ' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_output_rsrq_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSRQ,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_output_rsrq_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rsrq = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interface = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RSRQ' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_strength_output_error_rate_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint error_rate_list_i;
        guint16 error_rate_list_n_items;
        const guint8 *error_rate_list_aux_buffer = &buffer[expected_len];
        guint16 error_rate_list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 2;

        /* Read the guint16 variable from the buffer */
        qmi_utils_read_guint16_from_buffer (
            &error_rate_list_aux_buffer,
            &error_rate_list_aux_buffer_len,
            QMI_ENDIAN_LITTLE,
            &(error_rate_list_n_items));
        for (error_rate_list_i = 0; error_rate_list_i < error_rate_list_n_items; error_rate_list_i++) {

            expected_len += 2;
            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Error Rate List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Error Rate List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_output_error_rate_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ERROR_RATE_LIST,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_output_error_rate_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint error_rate_list_i;
            guint16 error_rate_list_n_items;

            /* Read number of items in the array */
            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(error_rate_list_n_items));

            g_string_append (printable, "{");

            for (error_rate_list_i = 0; error_rate_list_i < error_rate_list_n_items; error_rate_list_i++) {
                g_string_append_printf (printable, " [%u] = '", error_rate_list_i);
                g_string_append (printable, "[");
                g_string_append (printable, " rate = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " radio_interface = '");

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Error Rate List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_strength_output_sinr_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'SINR' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'SINR' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_output_sinr_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SINR,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_output_sinr_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_evdo_sinr_level_get_string ((QmiNasEvdoSinrLevel)tmp));
#elif defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_evdo_sinr_level_build_string_from_mask ((QmiNasEvdoSinrLevel)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasEvdoSinrLevel
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'SINR' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_strength_output_io_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'IO' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'IO' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_output_io_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_IO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_output_io_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'IO' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_strength_output_ecio_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint ecio_list_i;
        guint16 ecio_list_n_items;
        const guint8 *ecio_list_aux_buffer = &buffer[expected_len];
        guint16 ecio_list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 2;

        /* Read the guint16 variable from the buffer */
        qmi_utils_read_guint16_from_buffer (
            &ecio_list_aux_buffer,
            &ecio_list_aux_buffer_len,
            QMI_ENDIAN_LITTLE,
            &(ecio_list_n_items));
        for (ecio_list_i = 0; ecio_list_i < ecio_list_n_items; ecio_list_i++) {

            expected_len += 1;
            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'ECIO List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'ECIO List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_output_ecio_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ECIO_LIST,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_output_ecio_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint ecio_list_i;
            guint16 ecio_list_n_items;

            /* Read number of items in the array */
            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(ecio_list_n_items));

            g_string_append (printable, "{");

            for (ecio_list_i = 0; ecio_list_i < ecio_list_n_items; ecio_list_i++) {
                g_string_append_printf (printable, " [%u] = '", ecio_list_i);
                g_string_append (printable, "[");
                g_string_append (printable, " ecio = '");

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%d", (gint)tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " radio_interface = '");

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'ECIO List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_strength_output_rssi_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint rssi_list_i;
        guint16 rssi_list_n_items;
        const guint8 *rssi_list_aux_buffer = &buffer[expected_len];
        guint16 rssi_list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 2;

        /* Read the guint16 variable from the buffer */
        qmi_utils_read_guint16_from_buffer (
            &rssi_list_aux_buffer,
            &rssi_list_aux_buffer_len,
            QMI_ENDIAN_LITTLE,
            &(rssi_list_n_items));
        for (rssi_list_i = 0; rssi_list_i < rssi_list_n_items; rssi_list_i++) {

            expected_len += 1;
            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RSSI List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RSSI List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_output_rssi_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSSI_LIST,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_output_rssi_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint rssi_list_i;
            guint16 rssi_list_n_items;

            /* Read number of items in the array */
            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(rssi_list_n_items));

            g_string_append (printable, "{");

            for (rssi_list_i = 0; rssi_list_i < rssi_list_n_items; rssi_list_i++) {
                g_string_append_printf (printable, " [%u] = '", rssi_list_i);
                g_string_append (printable, "[");
                g_string_append (printable, " rssi = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%u", (guint)tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " radio_interface = '");

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RSSI List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_strength_output_strength_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint strength_list_i;
        guint16 strength_list_n_items;
        const guint8 *strength_list_aux_buffer = &buffer[expected_len];
        guint16 strength_list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 2;

        /* Read the guint16 variable from the buffer */
        qmi_utils_read_guint16_from_buffer (
            &strength_list_aux_buffer,
            &strength_list_aux_buffer_len,
            QMI_ENDIAN_LITTLE,
            &(strength_list_n_items));
        for (strength_list_i = 0; strength_list_i < strength_list_n_items; strength_list_i++) {

            expected_len += 1;
            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Strength List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Strength List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_output_strength_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_STRENGTH_LIST,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_output_strength_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint strength_list_i;
            guint16 strength_list_n_items;

            /* Read number of items in the array */
            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(strength_list_n_items));

            g_string_append (printable, "{");

            for (strength_list_i = 0; strength_list_i < strength_list_n_items; strength_list_i++) {
                g_string_append_printf (printable, " [%u] = '", strength_list_i);
                g_string_append (printable, "[");
                g_string_append (printable, " strength = '");

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%d", (gint)tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " radio_interface = '");

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Strength List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_strength_output_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_strength_output_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_strength_output_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " strength = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interface = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_signal_strength_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_signal_strength_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_signal_strength_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_INPUT_TLV_REQUEST_MASK:
            tlv_type_str = "Request Mask";
            translated_value = qmi_message_nas_get_signal_strength_input_request_mask_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_RSRP:
            tlv_type_str = "LTE RSRP";
            translated_value = qmi_message_nas_get_signal_strength_output_lte_rsrp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_SNR:
            tlv_type_str = "LTE SNR";
            translated_value = qmi_message_nas_get_signal_strength_output_lte_snr_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSRQ:
            tlv_type_str = "RSRQ";
            translated_value = qmi_message_nas_get_signal_strength_output_rsrq_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ERROR_RATE_LIST:
            tlv_type_str = "Error Rate List";
            translated_value = qmi_message_nas_get_signal_strength_output_error_rate_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SINR:
            tlv_type_str = "SINR";
            translated_value = qmi_message_nas_get_signal_strength_output_sinr_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_IO:
            tlv_type_str = "IO";
            translated_value = qmi_message_nas_get_signal_strength_output_io_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ECIO_LIST:
            tlv_type_str = "ECIO List";
            translated_value = qmi_message_nas_get_signal_strength_output_ecio_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSSI_LIST:
            tlv_type_str = "RSSI List";
            translated_value = qmi_message_nas_get_signal_strength_output_rssi_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_STRENGTH_LIST:
            tlv_type_str = "Strength List";
            translated_value = qmi_message_nas_get_signal_strength_output_strength_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SIGNAL_STRENGTH:
            tlv_type_str = "Signal Strength";
            translated_value = qmi_message_nas_get_signal_strength_output_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_signal_strength_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Signal Strength\" (0x0020)\n",
                            line_prefix);

    {
        struct message_get_signal_strength_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_signal_strength_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetSignalStrengthOutput *
__qmi_message_nas_get_signal_strength_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetSignalStrengthOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH, NULL);

    self = g_slice_new0 (QmiMessageNasGetSignalStrengthOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_get_signal_strength_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_RSRP,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_strength_output_lte_rsrp_validate (buffer, buffer_len)) {
                self->arg_lte_rsrp_set = TRUE;

                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_rsrp));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE RSRP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_LTE_SNR,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_strength_output_lte_snr_validate (buffer, buffer_len)) {
                self->arg_lte_snr_set = TRUE;

                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_snr));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE SNR' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSRQ,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_strength_output_rsrq_validate (buffer, buffer_len)) {
                self->arg_rsrq_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_rsrq_rsrq));
                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_rsrq_radio_interface = (QmiNasRadioInterface)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'RSRQ' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ERROR_RATE_LIST,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_strength_output_error_rate_list_validate (buffer, buffer_len)) {
                self->arg_error_rate_list_set = TRUE;

                {
                    guint error_rate_list_i;
                    guint16 error_rate_list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &(error_rate_list_n_items));

                    self->arg_error_rate_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageNasGetSignalStrengthOutputErrorRateListElement),
                        (guint)error_rate_list_n_items);

                    for (error_rate_list_i = 0; error_rate_list_i < error_rate_list_n_items; error_rate_list_i++) {
                        QmiMessageNasGetSignalStrengthOutputErrorRateListElement error_rate_list_aux;

                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(error_rate_list_aux.rate));
                        {
                            gint8 tmp;

                            /* Read the gint8 variable from the buffer */
                            qmi_utils_read_gint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            error_rate_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                        }
                        g_array_insert_val (self->arg_error_rate_list, error_rate_list_i, error_rate_list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Error Rate List' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SINR,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_strength_output_sinr_validate (buffer, buffer_len)) {
                self->arg_sinr_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_sinr = (QmiNasEvdoSinrLevel)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'SINR' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_IO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_strength_output_io_validate (buffer, buffer_len)) {
                self->arg_io_set = TRUE;

                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_io));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'IO' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_ECIO_LIST,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_strength_output_ecio_list_validate (buffer, buffer_len)) {
                self->arg_ecio_list_set = TRUE;

                {
                    guint ecio_list_i;
                    guint16 ecio_list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &(ecio_list_n_items));

                    self->arg_ecio_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageNasGetSignalStrengthOutputEcioListElement),
                        (guint)ecio_list_n_items);

                    for (ecio_list_i = 0; ecio_list_i < ecio_list_n_items; ecio_list_i++) {
                        QmiMessageNasGetSignalStrengthOutputEcioListElement ecio_list_aux;

                        /* Read the gint8 variable from the buffer */
                        qmi_utils_read_gint8_from_buffer (
                            &buffer,
                            &buffer_len,
                            &(ecio_list_aux.ecio));
                        {
                            gint8 tmp;

                            /* Read the gint8 variable from the buffer */
                            qmi_utils_read_gint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            ecio_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                        }
                        g_array_insert_val (self->arg_ecio_list, ecio_list_i, ecio_list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'ECIO List' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_RSSI_LIST,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_strength_output_rssi_list_validate (buffer, buffer_len)) {
                self->arg_rssi_list_set = TRUE;

                {
                    guint rssi_list_i;
                    guint16 rssi_list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &(rssi_list_n_items));

                    self->arg_rssi_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageNasGetSignalStrengthOutputRssiListElement),
                        (guint)rssi_list_n_items);

                    for (rssi_list_i = 0; rssi_list_i < rssi_list_n_items; rssi_list_i++) {
                        QmiMessageNasGetSignalStrengthOutputRssiListElement rssi_list_aux;

                        /* Read the guint8 variable from the buffer */
                        qmi_utils_read_guint8_from_buffer (
                            &buffer,
                            &buffer_len,
                            &(rssi_list_aux.rssi));
                        {
                            gint8 tmp;

                            /* Read the gint8 variable from the buffer */
                            qmi_utils_read_gint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            rssi_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                        }
                        g_array_insert_val (self->arg_rssi_list, rssi_list_i, rssi_list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'RSSI List' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_STRENGTH_LIST,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_strength_output_strength_list_validate (buffer, buffer_len)) {
                self->arg_strength_list_set = TRUE;

                {
                    guint strength_list_i;
                    guint16 strength_list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &(strength_list_n_items));

                    self->arg_strength_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageNasGetSignalStrengthOutputStrengthListElement),
                        (guint)strength_list_n_items);

                    for (strength_list_i = 0; strength_list_i < strength_list_n_items; strength_list_i++) {
                        QmiMessageNasGetSignalStrengthOutputStrengthListElement strength_list_aux;

                        /* Read the gint8 variable from the buffer */
                        qmi_utils_read_gint8_from_buffer (
                            &buffer,
                            &buffer_len,
                            &(strength_list_aux.strength));
                        {
                            gint8 tmp;

                            /* Read the gint8 variable from the buffer */
                            qmi_utils_read_gint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            strength_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                        }
                        g_array_insert_val (self->arg_strength_list, strength_list_i, strength_list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Strength List' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH_OUTPUT_TLV_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_strength_output_signal_strength_validate (buffer, buffer_len)) {
                self->arg_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_signal_strength_strength));
                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_signal_strength_radio_interface = (QmiNasRadioInterface)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Signal Strength' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Signal Strength TLV: Not found");
                qmi_message_nas_get_signal_strength_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Network Scan */


/* --- Input -- */

struct _QmiMessageNasNetworkScanInput {
    volatile gint ref_count;

    /* Network Type */
    gboolean arg_network_type_set;
    guint8 arg_network_type;
};

#define QMI_MESSAGE_NAS_NETWORK_SCAN_INPUT_TLV_NETWORK_TYPE 0x10

/**
 * qmi_message_nas_network_scan_input_get_network_type:
 * @self: a #QmiMessageNasNetworkScanInput.
 * @network_type: a placeholder for the output #QmiNasNetworkScanType, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Network Type' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_network_scan_input_get_network_type (
    QmiMessageNasNetworkScanInput *self,
    QmiNasNetworkScanType *network_type,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_type_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Type' was not found in the message");
        return FALSE;
    }

    if (network_type)
        *network_type = (QmiNasNetworkScanType)(self->arg_network_type);

    return TRUE;
}

/**
 * qmi_message_nas_network_scan_input_set_network_type:
 * @self: a #QmiMessageNasNetworkScanInput.
 * @network_type: a #QmiNasNetworkScanType.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Network Type' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_network_scan_input_set_network_type (
    QmiMessageNasNetworkScanInput *self,
    QmiNasNetworkScanType network_type,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_network_type = (guint8)(network_type);
    self->arg_network_type_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_network_scan_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasNetworkScanInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_network_scan_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_network_scan_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_network_scan_input_ref:
 * @self: a #QmiMessageNasNetworkScanInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasNetworkScanInput *
qmi_message_nas_network_scan_input_ref (QmiMessageNasNetworkScanInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_network_scan_input_unref:
 * @self: a #QmiMessageNasNetworkScanInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_network_scan_input_unref (QmiMessageNasNetworkScanInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasNetworkScanInput, self);
    }
}

/**
 * qmi_message_nas_network_scan_input_new:
 *
 * Allocates a new #QmiMessageNasNetworkScanInput.
 *
 * Returns: the newly created #QmiMessageNasNetworkScanInput. The returned value should be freed with qmi_message_nas_network_scan_input_unref().
 */
QmiMessageNasNetworkScanInput *
qmi_message_nas_network_scan_input_new (void)
{
    QmiMessageNasNetworkScanInput *self;

    self = g_slice_new0 (QmiMessageNasNetworkScanInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_network_scan_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageNasNetworkScanInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_NETWORK_SCAN);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return self;

    /* Try to add the 'Network Type' TLV */
    if (input->arg_network_type_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_network_type;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_NETWORK_SCAN_INPUT_TLV_NETWORK_TYPE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Network Type TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    return self;
}

/* --- Output -- */

static void
network_information_qmimessagenasnetworkscanoutputnetworkinformationelement_clear (QmiMessageNasNetworkScanOutputNetworkInformationElement *p)
{
    g_free ((*p).description);
}

struct _QmiMessageNasNetworkScanOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    GArray *arg_mnc_pcs_digit_include_status;

    /* Radio Access Technology */
    gboolean arg_radio_access_technology_set;
    GArray *arg_radio_access_technology;

    /* Network Information */
    gboolean arg_network_information_set;
    GArray *arg_network_information;
};

#define QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x12
#define QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RADIO_ACCESS_TECHNOLOGY 0x11
#define QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_INFORMATION 0x10

/**
 * qmi_message_nas_network_scan_output_get_result:
 * @self: a QmiMessageNasNetworkScanOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_network_scan_output_get_result (
    QmiMessageNasNetworkScanOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_nas_network_scan_output_get_mnc_pcs_digit_include_status:
 * @self: a #QmiMessageNasNetworkScanOutput.
 * @mnc_pcs_digit_include_status: a placeholder for the output #GArray of #QmiMessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'MNC PCS Digit Include Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_network_scan_output_get_mnc_pcs_digit_include_status (
    QmiMessageNasNetworkScanOutput *self,
    GArray **mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (mnc_pcs_digit_include_status)
        *mnc_pcs_digit_include_status = self->arg_mnc_pcs_digit_include_status;

    return TRUE;
}

/**
 * qmi_message_nas_network_scan_output_get_radio_access_technology:
 * @self: a #QmiMessageNasNetworkScanOutput.
 * @radio_access_technology: a placeholder for the output #GArray of #QmiMessageNasNetworkScanOutputRadioAccessTechnologyElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Radio Access Technology' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_network_scan_output_get_radio_access_technology (
    QmiMessageNasNetworkScanOutput *self,
    GArray **radio_access_technology,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_radio_access_technology_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Radio Access Technology' was not found in the message");
        return FALSE;
    }

    if (radio_access_technology)
        *radio_access_technology = self->arg_radio_access_technology;

    return TRUE;
}

/**
 * qmi_message_nas_network_scan_output_get_network_information:
 * @self: a #QmiMessageNasNetworkScanOutput.
 * @network_information: a placeholder for the output #GArray of #QmiMessageNasNetworkScanOutputNetworkInformationElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Network Information' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_network_scan_output_get_network_information (
    QmiMessageNasNetworkScanOutput *self,
    GArray **network_information,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_information_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Information' was not found in the message");
        return FALSE;
    }

    if (network_information)
        *network_information = self->arg_network_information;

    return TRUE;
}

GType
qmi_message_nas_network_scan_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasNetworkScanOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_network_scan_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_network_scan_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_network_scan_output_ref:
 * @self: a #QmiMessageNasNetworkScanOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasNetworkScanOutput *
qmi_message_nas_network_scan_output_ref (QmiMessageNasNetworkScanOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_network_scan_output_unref:
 * @self: a #QmiMessageNasNetworkScanOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_network_scan_output_unref (QmiMessageNasNetworkScanOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_mnc_pcs_digit_include_status)
            g_array_unref (self->arg_mnc_pcs_digit_include_status);
        if (self->arg_radio_access_technology)
            g_array_unref (self->arg_radio_access_technology);
        if (self->arg_network_information)
            g_array_unref (self->arg_network_information);
        g_slice_free (QmiMessageNasNetworkScanOutput, self);
    }
}

static gboolean
qmi_message_nas_network_scan_input_network_type_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Network Type' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Network Type' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_network_scan_input_network_type_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_NETWORK_SCAN_INPUT_TLV_NETWORK_TYPE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_network_scan_input_network_type_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SCAN_TYPE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_scan_type_get_string ((QmiNasNetworkScanType)tmp));
#elif defined  __QMI_NAS_NETWORK_SCAN_TYPE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_scan_type_build_string_from_mask ((QmiNasNetworkScanType)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkScanType
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Network Type' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint mnc_pcs_digit_include_status_i;
        guint16 mnc_pcs_digit_include_status_n_items;
        const guint8 *mnc_pcs_digit_include_status_aux_buffer = &buffer[expected_len];
        guint16 mnc_pcs_digit_include_status_aux_buffer_len = buffer_len - expected_len;

        expected_len += 2;

        /* Read the guint16 variable from the buffer */
        qmi_utils_read_guint16_from_buffer (
            &mnc_pcs_digit_include_status_aux_buffer,
            &mnc_pcs_digit_include_status_aux_buffer_len,
            QMI_ENDIAN_LITTLE,
            &(mnc_pcs_digit_include_status_n_items));
        for (mnc_pcs_digit_include_status_i = 0; mnc_pcs_digit_include_status_i < mnc_pcs_digit_include_status_n_items; mnc_pcs_digit_include_status_i++) {

            expected_len += 2;
            expected_len += 2;
            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'MNC PCS Digit Include Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'MNC PCS Digit Include Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint mnc_pcs_digit_include_status_i;
            guint16 mnc_pcs_digit_include_status_n_items;

            /* Read number of items in the array */
            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(mnc_pcs_digit_include_status_n_items));

            g_string_append (printable, "{");

            for (mnc_pcs_digit_include_status_i = 0; mnc_pcs_digit_include_status_i < mnc_pcs_digit_include_status_n_items; mnc_pcs_digit_include_status_i++) {
                g_string_append_printf (printable, " [%u] = '", mnc_pcs_digit_include_status_i);
                g_string_append (printable, "[");
                g_string_append (printable, " mcc = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " mnc = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " includes_pcs_digit = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'MNC PCS Digit Include Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_network_scan_output_radio_access_technology_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint radio_access_technology_i;
        guint16 radio_access_technology_n_items;
        const guint8 *radio_access_technology_aux_buffer = &buffer[expected_len];
        guint16 radio_access_technology_aux_buffer_len = buffer_len - expected_len;

        expected_len += 2;

        /* Read the guint16 variable from the buffer */
        qmi_utils_read_guint16_from_buffer (
            &radio_access_technology_aux_buffer,
            &radio_access_technology_aux_buffer_len,
            QMI_ENDIAN_LITTLE,
            &(radio_access_technology_n_items));
        for (radio_access_technology_i = 0; radio_access_technology_i < radio_access_technology_n_items; radio_access_technology_i++) {

            expected_len += 2;
            expected_len += 2;
            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Radio Access Technology' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Radio Access Technology' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_network_scan_output_radio_access_technology_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RADIO_ACCESS_TECHNOLOGY,
                                      &buffer_len);
    if (buffer && qmi_message_nas_network_scan_output_radio_access_technology_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint radio_access_technology_i;
            guint16 radio_access_technology_n_items;

            /* Read number of items in the array */
            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(radio_access_technology_n_items));

            g_string_append (printable, "{");

            for (radio_access_technology_i = 0; radio_access_technology_i < radio_access_technology_n_items; radio_access_technology_i++) {
                g_string_append_printf (printable, " [%u] = '", radio_access_technology_i);
                g_string_append (printable, "[");
                g_string_append (printable, " mcc = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " mnc = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " radio_interface = '");

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Radio Access Technology' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_network_scan_output_network_information_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint network_information_i;
        guint16 network_information_n_items;
        const guint8 *network_information_aux_buffer = &buffer[expected_len];
        guint16 network_information_aux_buffer_len = buffer_len - expected_len;

        expected_len += 2;

        /* Read the guint16 variable from the buffer */
        qmi_utils_read_guint16_from_buffer (
            &network_information_aux_buffer,
            &network_information_aux_buffer_len,
            QMI_ENDIAN_LITTLE,
            &(network_information_n_items));
        for (network_information_i = 0; network_information_i < network_information_n_items; network_information_i++) {

            expected_len += 2;
            expected_len += 2;
            expected_len += 1;
            {
                guint8 size8;
                const guint8 *aux_buffer = &buffer[expected_len];
                guint16 aux_buffer_len = buffer_len - expected_len;

                qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
                expected_len += (1 + size8);
            }
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Network Information' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Network Information' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_network_scan_output_network_information_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_INFORMATION,
                                      &buffer_len);
    if (buffer && qmi_message_nas_network_scan_output_network_information_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint network_information_i;
            guint16 network_information_n_items;

            /* Read number of items in the array */
            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(network_information_n_items));

            g_string_append (printable, "{");

            for (network_information_i = 0; network_information_i < network_information_n_items; network_information_i++) {
                g_string_append_printf (printable, " [%u] = '", network_information_i);
                g_string_append (printable, "[");
                g_string_append (printable, " mcc = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " mnc = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " network_status = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_NETWORK_STATUS_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_network_status_get_string ((QmiNasNetworkStatus)tmp));
#elif defined  __QMI_NAS_NETWORK_STATUS_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_network_status_build_string_from_mask ((QmiNasNetworkStatus)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasNetworkStatus
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " description = '");

                {
                    gchar *tmp;

                    /* Read the string variable from the buffer */
                    qmi_utils_read_string_from_buffer (
                        &buffer,
                        &buffer_len,
                        8,
                        0,
                        &tmp);

                    g_string_append_printf (printable, "%s", tmp);
                    g_free (tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Network Information' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_network_scan_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_network_scan_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_network_scan_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_NETWORK_SCAN_INPUT_TLV_NETWORK_TYPE:
            tlv_type_str = "Network Type";
            translated_value = qmi_message_nas_network_scan_input_network_type_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RADIO_ACCESS_TECHNOLOGY:
            tlv_type_str = "Radio Access Technology";
            translated_value = qmi_message_nas_network_scan_output_radio_access_technology_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_INFORMATION:
            tlv_type_str = "Network Information";
            translated_value = qmi_message_nas_network_scan_output_network_information_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_network_scan_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Network Scan\" (0x0021)\n",
                            line_prefix);

    {
        struct message_network_scan_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_network_scan_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasNetworkScanOutput *
__qmi_message_nas_network_scan_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasNetworkScanOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_NETWORK_SCAN, NULL);

    self = g_slice_new0 (QmiMessageNasNetworkScanOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_network_scan_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_network_scan_output_mnc_pcs_digit_include_status_validate (buffer, buffer_len)) {
                self->arg_mnc_pcs_digit_include_status_set = TRUE;

                {
                    guint mnc_pcs_digit_include_status_i;
                    guint16 mnc_pcs_digit_include_status_n_items;

                    /* Read number of items in the array */
                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &(mnc_pcs_digit_include_status_n_items));

                    self->arg_mnc_pcs_digit_include_status = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement),
                        (guint)mnc_pcs_digit_include_status_n_items);

                    for (mnc_pcs_digit_include_status_i = 0; mnc_pcs_digit_include_status_i < mnc_pcs_digit_include_status_n_items; mnc_pcs_digit_include_status_i++) {
                        QmiMessageNasNetworkScanOutputMncPcsDigitIncludeStatusElement mnc_pcs_digit_include_status_aux;

                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(mnc_pcs_digit_include_status_aux.mcc));
                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(mnc_pcs_digit_include_status_aux.mnc));
                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            mnc_pcs_digit_include_status_aux.includes_pcs_digit = (gboolean)tmp;
                        }
                        g_array_insert_val (self->arg_mnc_pcs_digit_include_status, mnc_pcs_digit_include_status_i, mnc_pcs_digit_include_status_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'MNC PCS Digit Include Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_RADIO_ACCESS_TECHNOLOGY,
                                              &buffer_len);
            if (buffer && qmi_message_nas_network_scan_output_radio_access_technology_validate (buffer, buffer_len)) {
                self->arg_radio_access_technology_set = TRUE;

                {
                    guint radio_access_technology_i;
                    guint16 radio_access_technology_n_items;

                    /* Read number of items in the array */
                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &(radio_access_technology_n_items));

                    self->arg_radio_access_technology = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageNasNetworkScanOutputRadioAccessTechnologyElement),
                        (guint)radio_access_technology_n_items);

                    for (radio_access_technology_i = 0; radio_access_technology_i < radio_access_technology_n_items; radio_access_technology_i++) {
                        QmiMessageNasNetworkScanOutputRadioAccessTechnologyElement radio_access_technology_aux;

                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(radio_access_technology_aux.mcc));
                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(radio_access_technology_aux.mnc));
                        {
                            gint8 tmp;

                            /* Read the gint8 variable from the buffer */
                            qmi_utils_read_gint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            radio_access_technology_aux.radio_interface = (QmiNasRadioInterface)tmp;
                        }
                        g_array_insert_val (self->arg_radio_access_technology, radio_access_technology_i, radio_access_technology_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Radio Access Technology' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_NETWORK_SCAN_OUTPUT_TLV_NETWORK_INFORMATION,
                                              &buffer_len);
            if (buffer && qmi_message_nas_network_scan_output_network_information_validate (buffer, buffer_len)) {
                self->arg_network_information_set = TRUE;

                {
                    guint network_information_i;
                    guint16 network_information_n_items;

                    /* Read number of items in the array */
                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &(network_information_n_items));

                    self->arg_network_information = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageNasNetworkScanOutputNetworkInformationElement),
                        (guint)network_information_n_items);

                    g_array_set_clear_func (self->arg_network_information,
                                            (GDestroyNotify)network_information_qmimessagenasnetworkscanoutputnetworkinformationelement_clear);

                    for (network_information_i = 0; network_information_i < network_information_n_items; network_information_i++) {
                        QmiMessageNasNetworkScanOutputNetworkInformationElement network_information_aux;

                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(network_information_aux.mcc));
                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(network_information_aux.mnc));
                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            network_information_aux.network_status = (QmiNasNetworkStatus)tmp;
                        }
                        /* Read the string variable from the buffer */
                        qmi_utils_read_string_from_buffer (
                            &buffer,
                            &buffer_len,
                            8,
                            0,
                            &(network_information_aux.description));
                        g_array_insert_val (self->arg_network_information, network_information_i, network_information_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Network Information' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Initiate Network Register */


/* --- Input -- */

struct _QmiMessageNasInitiateNetworkRegisterInput {
    volatile gint ref_count;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    guint8 arg_mnc_pcs_digit_include_status;

    /* Change Duration */
    gboolean arg_change_duration_set;
    guint8 arg_change_duration;

    /* Manual Registration Info 3GPP */
    gboolean arg_manual_registration_info_3gpp_set;
    guint16 arg_manual_registration_info_3gpp_mcc;
    guint16 arg_manual_registration_info_3gpp_mnc;
    gint8 arg_manual_registration_info_3gpp_radio_interface;

    /* Action */
    gboolean arg_action_set;
    guint8 arg_action;
};

#define QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x12
#define QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_CHANGE_DURATION 0x11
#define QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MANUAL_REGISTRATION_INFO_3GPP 0x10
#define QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_ACTION 0x01

/**
 * qmi_message_nas_initiate_network_register_input_get_mnc_pcs_digit_include_status:
 * @self: a #QmiMessageNasInitiateNetworkRegisterInput.
 * @mnc_pcs_digit_include_status: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'MNC PCS Digit Include Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_initiate_network_register_input_get_mnc_pcs_digit_include_status (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    gboolean *mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (mnc_pcs_digit_include_status)
        *mnc_pcs_digit_include_status = (gboolean)(self->arg_mnc_pcs_digit_include_status);

    return TRUE;
}

/**
 * qmi_message_nas_initiate_network_register_input_set_mnc_pcs_digit_include_status:
 * @self: a #QmiMessageNasInitiateNetworkRegisterInput.
 * @mnc_pcs_digit_include_status: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'MNC PCS Digit Include Status' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_initiate_network_register_input_set_mnc_pcs_digit_include_status (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    gboolean mnc_pcs_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_mnc_pcs_digit_include_status = (guint8)(mnc_pcs_digit_include_status);
    self->arg_mnc_pcs_digit_include_status_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_initiate_network_register_input_get_change_duration:
 * @self: a #QmiMessageNasInitiateNetworkRegisterInput.
 * @change_duration: a placeholder for the output #QmiNasChangeDuration, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Change Duration' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_initiate_network_register_input_get_change_duration (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    QmiNasChangeDuration *change_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_change_duration_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Change Duration' was not found in the message");
        return FALSE;
    }

    if (change_duration)
        *change_duration = (QmiNasChangeDuration)(self->arg_change_duration);

    return TRUE;
}

/**
 * qmi_message_nas_initiate_network_register_input_set_change_duration:
 * @self: a #QmiMessageNasInitiateNetworkRegisterInput.
 * @change_duration: a #QmiNasChangeDuration.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Change Duration' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_initiate_network_register_input_set_change_duration (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    QmiNasChangeDuration change_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_change_duration = (guint8)(change_duration);
    self->arg_change_duration_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_initiate_network_register_input_get_manual_registration_info_3gpp:
 * @self: a #QmiMessageNasInitiateNetworkRegisterInput.
 * @manual_registration_info_3gpp_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @manual_registration_info_3gpp_mnc: a placeholder for the output #guint16, or %NULL if not required.
 * @manual_registration_info_3gpp_radio_interface: a placeholder for the output #QmiNasRadioInterface, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Manual Registration Info 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_initiate_network_register_input_get_manual_registration_info_3gpp (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    guint16 *manual_registration_info_3gpp_mcc,
    guint16 *manual_registration_info_3gpp_mnc,
    QmiNasRadioInterface *manual_registration_info_3gpp_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_manual_registration_info_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Manual Registration Info 3GPP' was not found in the message");
        return FALSE;
    }

    if (manual_registration_info_3gpp_mcc)
        *manual_registration_info_3gpp_mcc = self->arg_manual_registration_info_3gpp_mcc;
    if (manual_registration_info_3gpp_mnc)
        *manual_registration_info_3gpp_mnc = self->arg_manual_registration_info_3gpp_mnc;
    if (manual_registration_info_3gpp_radio_interface)
        *manual_registration_info_3gpp_radio_interface = (QmiNasRadioInterface)(self->arg_manual_registration_info_3gpp_radio_interface);

    return TRUE;
}

/**
 * qmi_message_nas_initiate_network_register_input_set_manual_registration_info_3gpp:
 * @self: a #QmiMessageNasInitiateNetworkRegisterInput.
 * @manual_registration_info_3gpp_mcc: a #guint16.
 * @manual_registration_info_3gpp_mnc: a #guint16.
 * @manual_registration_info_3gpp_radio_interface: a #QmiNasRadioInterface.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Manual Registration Info 3GPP' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_initiate_network_register_input_set_manual_registration_info_3gpp (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    guint16 manual_registration_info_3gpp_mcc,
    guint16 manual_registration_info_3gpp_mnc,
    QmiNasRadioInterface manual_registration_info_3gpp_radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_manual_registration_info_3gpp_mcc = manual_registration_info_3gpp_mcc;
    self->arg_manual_registration_info_3gpp_mnc = manual_registration_info_3gpp_mnc;
    self->arg_manual_registration_info_3gpp_radio_interface = (gint8)(manual_registration_info_3gpp_radio_interface);
    self->arg_manual_registration_info_3gpp_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_initiate_network_register_input_get_action:
 * @self: a #QmiMessageNasInitiateNetworkRegisterInput.
 * @action: a placeholder for the output #QmiNasNetworkRegisterType, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Action' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_initiate_network_register_input_get_action (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    QmiNasNetworkRegisterType *action,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_action_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Action' was not found in the message");
        return FALSE;
    }

    if (action)
        *action = (QmiNasNetworkRegisterType)(self->arg_action);

    return TRUE;
}

/**
 * qmi_message_nas_initiate_network_register_input_set_action:
 * @self: a #QmiMessageNasInitiateNetworkRegisterInput.
 * @action: a #QmiNasNetworkRegisterType.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Action' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_initiate_network_register_input_set_action (
    QmiMessageNasInitiateNetworkRegisterInput *self,
    QmiNasNetworkRegisterType action,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_action = (guint8)(action);
    self->arg_action_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_initiate_network_register_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasInitiateNetworkRegisterInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_initiate_network_register_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_initiate_network_register_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_initiate_network_register_input_ref:
 * @self: a #QmiMessageNasInitiateNetworkRegisterInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasInitiateNetworkRegisterInput *
qmi_message_nas_initiate_network_register_input_ref (QmiMessageNasInitiateNetworkRegisterInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_initiate_network_register_input_unref:
 * @self: a #QmiMessageNasInitiateNetworkRegisterInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_initiate_network_register_input_unref (QmiMessageNasInitiateNetworkRegisterInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasInitiateNetworkRegisterInput, self);
    }
}

/**
 * qmi_message_nas_initiate_network_register_input_new:
 *
 * Allocates a new #QmiMessageNasInitiateNetworkRegisterInput.
 *
 * Returns: the newly created #QmiMessageNasInitiateNetworkRegisterInput. The returned value should be freed with qmi_message_nas_initiate_network_register_input_unref().
 */
QmiMessageNasInitiateNetworkRegisterInput *
qmi_message_nas_initiate_network_register_input_new (void)
{
    QmiMessageNasInitiateNetworkRegisterInput *self;

    self = g_slice_new0 (QmiMessageNasInitiateNetworkRegisterInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_initiate_network_register_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageNasInitiateNetworkRegisterInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Initiate Network Register' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'MNC PCS Digit Include Status' TLV */
    if (input->arg_mnc_pcs_digit_include_status_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_mnc_pcs_digit_include_status;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the MNC PCS Digit Include Status TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Change Duration' TLV */
    if (input->arg_change_duration_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_change_duration;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_CHANGE_DURATION,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Change Duration TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Manual Registration Info 3GPP' TLV */
    if (input->arg_manual_registration_info_3gpp_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the guint16 variable to the buffer */
        qmi_utils_write_guint16_to_buffer (
            &buffer_aux,
            &buffer_len,
            QMI_ENDIAN_LITTLE,
            &(input->arg_manual_registration_info_3gpp_mcc));
        /* Write the guint16 variable to the buffer */
        qmi_utils_write_guint16_to_buffer (
            &buffer_aux,
            &buffer_len,
            QMI_ENDIAN_LITTLE,
            &(input->arg_manual_registration_info_3gpp_mnc));
        {
            gint8 tmp;

            tmp = (gint8)input->arg_manual_registration_info_3gpp_radio_interface;
            /* Write the gint8 variable to the buffer */
            qmi_utils_write_gint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MANUAL_REGISTRATION_INFO_3GPP,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Manual Registration Info 3GPP TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Action' TLV */
    if (input->arg_action_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_action;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_ACTION,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Action TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Action' in message 'Initiate Network Register'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageNasInitiateNetworkRegisterOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_nas_initiate_network_register_output_get_result:
 * @self: a QmiMessageNasInitiateNetworkRegisterOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_initiate_network_register_output_get_result (
    QmiMessageNasInitiateNetworkRegisterOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_initiate_network_register_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasInitiateNetworkRegisterOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_initiate_network_register_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_initiate_network_register_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_initiate_network_register_output_ref:
 * @self: a #QmiMessageNasInitiateNetworkRegisterOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasInitiateNetworkRegisterOutput *
qmi_message_nas_initiate_network_register_output_ref (QmiMessageNasInitiateNetworkRegisterOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_initiate_network_register_output_unref:
 * @self: a #QmiMessageNasInitiateNetworkRegisterOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_initiate_network_register_output_unref (QmiMessageNasInitiateNetworkRegisterOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasInitiateNetworkRegisterOutput, self);
    }
}

static gboolean
qmi_message_nas_initiate_network_register_input_mnc_pcs_digit_include_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'MNC PCS Digit Include Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'MNC PCS Digit Include Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_initiate_network_register_input_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_initiate_network_register_input_mnc_pcs_digit_include_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'MNC PCS Digit Include Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_initiate_network_register_input_change_duration_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Change Duration' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Change Duration' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_initiate_network_register_input_change_duration_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_CHANGE_DURATION,
                                      &buffer_len);
    if (buffer && qmi_message_nas_initiate_network_register_input_change_duration_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_CHANGE_DURATION_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_change_duration_get_string ((QmiNasChangeDuration)tmp));
#elif defined  __QMI_NAS_CHANGE_DURATION_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_change_duration_build_string_from_mask ((QmiNasChangeDuration)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasChangeDuration
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Change Duration' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_initiate_network_register_input_manual_registration_info_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Manual Registration Info 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Manual Registration Info 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_initiate_network_register_input_manual_registration_info_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MANUAL_REGISTRATION_INFO_3GPP,
                                      &buffer_len);
    if (buffer && qmi_message_nas_initiate_network_register_input_manual_registration_info_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interface = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Manual Registration Info 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_initiate_network_register_input_action_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Action' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Action' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_initiate_network_register_input_action_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_ACTION,
                                      &buffer_len);
    if (buffer && qmi_message_nas_initiate_network_register_input_action_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_REGISTER_TYPE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_register_type_get_string ((QmiNasNetworkRegisterType)tmp));
#elif defined  __QMI_NAS_NETWORK_REGISTER_TYPE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_register_type_build_string_from_mask ((QmiNasNetworkRegisterType)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkRegisterType
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Action' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_initiate_network_register_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_initiate_network_register_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_initiate_network_register_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_message_nas_initiate_network_register_input_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_CHANGE_DURATION:
            tlv_type_str = "Change Duration";
            translated_value = qmi_message_nas_initiate_network_register_input_change_duration_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_MANUAL_REGISTRATION_INFO_3GPP:
            tlv_type_str = "Manual Registration Info 3GPP";
            translated_value = qmi_message_nas_initiate_network_register_input_manual_registration_info_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_INPUT_TLV_ACTION:
            tlv_type_str = "Action";
            translated_value = qmi_message_nas_initiate_network_register_input_action_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_initiate_network_register_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Initiate Network Register\" (0x0022)\n",
                            line_prefix);

    {
        struct message_initiate_network_register_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_initiate_network_register_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasInitiateNetworkRegisterOutput *
__qmi_message_nas_initiate_network_register_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasInitiateNetworkRegisterOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER, NULL);

    self = g_slice_new0 (QmiMessageNasInitiateNetworkRegisterOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_initiate_network_register_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Serving System */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_serving_system_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SERVING_SYSTEM);

    return self;
}

/* --- Output -- */

struct _QmiMessageNasGetServingSystemOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    guint16 arg_mnc_pcs_digit_include_status_mcc;
    guint16 arg_mnc_pcs_digit_include_status_mnc;
    guint8 arg_mnc_pcs_digit_include_status_includes_pcs_digit;

    /* UMTS Primary Scrambling Code */
    gboolean arg_umts_primary_scrambling_code_set;
    guint16 arg_umts_primary_scrambling_code;

    /* Call Barring Status */
    gboolean arg_call_barring_status_set;
    gint32 arg_call_barring_status_cs_status;
    gint32 arg_call_barring_status_ps_status;

    /* LTE TAC */
    gboolean arg_lte_tac_set;
    guint16 arg_lte_tac;

    /* HDR Personality */
    gboolean arg_hdr_personality_set;
    guint8 arg_hdr_personality;

    /* CDMA System Info */
    gboolean arg_cdma_system_info_set;
    guint16 arg_cdma_system_info_mcc;
    guint8 arg_cdma_system_info_imsi_11_12;

    /* Detailed Service Status */
    gboolean arg_detailed_service_status_set;
    guint8 arg_detailed_service_status_status;
    guint8 arg_detailed_service_status_capability;
    guint8 arg_detailed_service_status_hdr_status;
    guint8 arg_detailed_service_status_hdr_hybrid;
    guint8 arg_detailed_service_status_forbidden;

    /* DTM Support */
    gboolean arg_dtm_support_set;
    guint8 arg_dtm_support;

    /* PRL Indicator 3GPP2 */
    gboolean arg_prl_indicator_3gpp2_set;
    guint8 arg_prl_indicator_3gpp2;

    /* Concurrent Service Info 3GPP2 */
    gboolean arg_concurrent_service_info_3gpp2_set;
    guint8 arg_concurrent_service_info_3gpp2;

    /* CID 3GPP */
    gboolean arg_cid_3gpp_set;
    guint32 arg_cid_3gpp;

    /* LAC 3GPP */
    gboolean arg_lac_3gpp_set;
    guint16 arg_lac_3gpp;

    /* Daylight Saving Time Adjustment 3GPP */
    gboolean arg_daylight_saving_time_adjustment_3gpp_set;
    guint8 arg_daylight_saving_time_adjustment_3gpp;

    /* Time Zone 3GPP */
    gboolean arg_time_zone_3gpp_set;
    gint8 arg_time_zone_3gpp;

    /* CDMA P Rev */
    gboolean arg_cdma_p_rev_set;
    guint8 arg_cdma_p_rev;

    /* Time Zone 3GPP2 */
    gboolean arg_time_zone_3gpp2_set;
    guint8 arg_time_zone_3gpp2_leap_seconds;
    gint8 arg_time_zone_3gpp2_local_time_offset;
    guint8 arg_time_zone_3gpp2_daylight_saving_time;

    /* Default Roaming Indicator */
    gboolean arg_default_roaming_indicator_set;
    guint8 arg_default_roaming_indicator;

    /* Roaming Indicator List */
    gboolean arg_roaming_indicator_list_set;
    GArray *arg_roaming_indicator_list;

    /* CDMA Base Station Info */
    gboolean arg_cdma_base_station_info_set;
    guint16 arg_cdma_base_station_info_base_station_id;
    gint32 arg_cdma_base_station_info_base_station_latitude;
    gint32 arg_cdma_base_station_info_base_station_longitude;

    /* CDMA System ID */
    gboolean arg_cdma_system_id_set;
    guint16 arg_cdma_system_id_sid;
    guint16 arg_cdma_system_id_nid;

    /* Current PLMN */
    gboolean arg_current_plmn_set;
    guint16 arg_current_plmn_mcc;
    guint16 arg_current_plmn_mnc;
    gchar *arg_current_plmn_description;

    /* Data Service Capability */
    gboolean arg_data_service_capability_set;
    GArray *arg_data_service_capability;

    /* Roaming Indicator */
    gboolean arg_roaming_indicator_set;
    guint8 arg_roaming_indicator;

    /* Serving System */
    gboolean arg_serving_system_set;
    guint8 arg_serving_system_registration_state;
    guint8 arg_serving_system_cs_attach_state;
    guint8 arg_serving_system_ps_attach_state;
    guint8 arg_serving_system_selected_network;
    GArray *arg_serving_system_radio_interfaces;
};

#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x27
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE 0x26
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS 0x25
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC 0x24
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY 0x23
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO 0x22
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS 0x21
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT 0x20
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2 0x1F
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2 0x1E
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP 0x1D
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP 0x1C
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP 0x1B
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP 0x1A
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV 0x18
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2 0x17
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR 0x16
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST 0x15
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO 0x14
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID 0x13
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN 0x12
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY 0x11
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR 0x10
#define QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM 0x01

/**
 * qmi_message_nas_get_serving_system_output_get_result:
 * @self: a QmiMessageNasGetServingSystemOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_result (
    QmiMessageNasGetServingSystemOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_mnc_pcs_digit_include_status:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @mnc_pcs_digit_include_status_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @mnc_pcs_digit_include_status_mnc: a placeholder for the output #guint16, or %NULL if not required.
 * @mnc_pcs_digit_include_status_includes_pcs_digit: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'MNC PCS Digit Include Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_mnc_pcs_digit_include_status (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *mnc_pcs_digit_include_status_mcc,
    guint16 *mnc_pcs_digit_include_status_mnc,
    gboolean *mnc_pcs_digit_include_status_includes_pcs_digit,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (mnc_pcs_digit_include_status_mcc)
        *mnc_pcs_digit_include_status_mcc = self->arg_mnc_pcs_digit_include_status_mcc;
    if (mnc_pcs_digit_include_status_mnc)
        *mnc_pcs_digit_include_status_mnc = self->arg_mnc_pcs_digit_include_status_mnc;
    if (mnc_pcs_digit_include_status_includes_pcs_digit)
        *mnc_pcs_digit_include_status_includes_pcs_digit = (gboolean)(self->arg_mnc_pcs_digit_include_status_includes_pcs_digit);

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_umts_primary_scrambling_code:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @umts_primary_scrambling_code: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'UMTS Primary Scrambling Code' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_umts_primary_scrambling_code (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *umts_primary_scrambling_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_umts_primary_scrambling_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'UMTS Primary Scrambling Code' was not found in the message");
        return FALSE;
    }

    if (umts_primary_scrambling_code)
        *umts_primary_scrambling_code = self->arg_umts_primary_scrambling_code;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_call_barring_status:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @call_barring_status_cs_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @call_barring_status_ps_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Call Barring Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_call_barring_status (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasCallBarringStatus *call_barring_status_cs_status,
    QmiNasCallBarringStatus *call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (call_barring_status_cs_status)
        *call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_call_barring_status_cs_status);
    if (call_barring_status_ps_status)
        *call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_call_barring_status_ps_status);

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_lte_tac:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @lte_tac: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE TAC' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_lte_tac (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *lte_tac,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_tac_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE TAC' was not found in the message");
        return FALSE;
    }

    if (lte_tac)
        *lte_tac = self->arg_lte_tac;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_hdr_personality:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @hdr_personality: a placeholder for the output #QmiNasHdrPersonality, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'HDR Personality' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_hdr_personality (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasHdrPersonality *hdr_personality,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_personality_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Personality' was not found in the message");
        return FALSE;
    }

    if (hdr_personality)
        *hdr_personality = (QmiNasHdrPersonality)(self->arg_hdr_personality);

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_cdma_system_info:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @cdma_system_info_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_info_imsi_11_12: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_cdma_system_info (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *cdma_system_info_mcc,
    guint8 *cdma_system_info_imsi_11_12,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (cdma_system_info_mcc)
        *cdma_system_info_mcc = self->arg_cdma_system_info_mcc;
    if (cdma_system_info_imsi_11_12)
        *cdma_system_info_imsi_11_12 = self->arg_cdma_system_info_imsi_11_12;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_detailed_service_status:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @detailed_service_status_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @detailed_service_status_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @detailed_service_status_hdr_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @detailed_service_status_hdr_hybrid: a placeholder for the output #gboolean, or %NULL if not required.
 * @detailed_service_status_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Detailed Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_detailed_service_status (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasServiceStatus *detailed_service_status_status,
    QmiNasNetworkServiceDomain *detailed_service_status_capability,
    QmiNasServiceStatus *detailed_service_status_hdr_status,
    gboolean *detailed_service_status_hdr_hybrid,
    gboolean *detailed_service_status_forbidden,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_detailed_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Detailed Service Status' was not found in the message");
        return FALSE;
    }

    if (detailed_service_status_status)
        *detailed_service_status_status = (QmiNasServiceStatus)(self->arg_detailed_service_status_status);
    if (detailed_service_status_capability)
        *detailed_service_status_capability = (QmiNasNetworkServiceDomain)(self->arg_detailed_service_status_capability);
    if (detailed_service_status_hdr_status)
        *detailed_service_status_hdr_status = (QmiNasServiceStatus)(self->arg_detailed_service_status_hdr_status);
    if (detailed_service_status_hdr_hybrid)
        *detailed_service_status_hdr_hybrid = (gboolean)(self->arg_detailed_service_status_hdr_hybrid);
    if (detailed_service_status_forbidden)
        *detailed_service_status_forbidden = (gboolean)(self->arg_detailed_service_status_forbidden);

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_dtm_support:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @dtm_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'DTM Support' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_dtm_support (
    QmiMessageNasGetServingSystemOutput *self,
    gboolean *dtm_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_dtm_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'DTM Support' was not found in the message");
        return FALSE;
    }

    if (dtm_support)
        *dtm_support = (gboolean)(self->arg_dtm_support);

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_prl_indicator_3gpp2:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @prl_indicator_3gpp2: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PRL Indicator 3GPP2' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_prl_indicator_3gpp2 (
    QmiMessageNasGetServingSystemOutput *self,
    gboolean *prl_indicator_3gpp2,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_prl_indicator_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PRL Indicator 3GPP2' was not found in the message");
        return FALSE;
    }

    if (prl_indicator_3gpp2)
        *prl_indicator_3gpp2 = (gboolean)(self->arg_prl_indicator_3gpp2);

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_concurrent_service_info_3gpp2:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @concurrent_service_info_3gpp2: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Concurrent Service Info 3GPP2' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_concurrent_service_info_3gpp2 (
    QmiMessageNasGetServingSystemOutput *self,
    gboolean *concurrent_service_info_3gpp2,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_concurrent_service_info_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Concurrent Service Info 3GPP2' was not found in the message");
        return FALSE;
    }

    if (concurrent_service_info_3gpp2)
        *concurrent_service_info_3gpp2 = (gboolean)(self->arg_concurrent_service_info_3gpp2);

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_cid_3gpp:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @cid_3gpp: a placeholder for the output #guint32, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CID 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_cid_3gpp (
    QmiMessageNasGetServingSystemOutput *self,
    guint32 *cid_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cid_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CID 3GPP' was not found in the message");
        return FALSE;
    }

    if (cid_3gpp)
        *cid_3gpp = self->arg_cid_3gpp;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_lac_3gpp:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @lac_3gpp: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LAC 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_lac_3gpp (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *lac_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lac_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LAC 3GPP' was not found in the message");
        return FALSE;
    }

    if (lac_3gpp)
        *lac_3gpp = self->arg_lac_3gpp;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_daylight_saving_time_adjustment_3gpp:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @daylight_saving_time_adjustment_3gpp: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Daylight Saving Time Adjustment 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_daylight_saving_time_adjustment_3gpp (
    QmiMessageNasGetServingSystemOutput *self,
    guint8 *daylight_saving_time_adjustment_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_daylight_saving_time_adjustment_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Daylight Saving Time Adjustment 3GPP' was not found in the message");
        return FALSE;
    }

    if (daylight_saving_time_adjustment_3gpp)
        *daylight_saving_time_adjustment_3gpp = self->arg_daylight_saving_time_adjustment_3gpp;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_time_zone_3gpp:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @time_zone_3gpp: a placeholder for the output #gint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Time Zone 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_time_zone_3gpp (
    QmiMessageNasGetServingSystemOutput *self,
    gint8 *time_zone_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_time_zone_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Time Zone 3GPP' was not found in the message");
        return FALSE;
    }

    if (time_zone_3gpp)
        *time_zone_3gpp = self->arg_time_zone_3gpp;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_cdma_p_rev:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @cdma_p_rev: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA P Rev' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_cdma_p_rev (
    QmiMessageNasGetServingSystemOutput *self,
    guint8 *cdma_p_rev,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_p_rev_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA P Rev' was not found in the message");
        return FALSE;
    }

    if (cdma_p_rev)
        *cdma_p_rev = self->arg_cdma_p_rev;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_time_zone_3gpp2:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @time_zone_3gpp2_leap_seconds: a placeholder for the output #guint8, or %NULL if not required.
 * @time_zone_3gpp2_local_time_offset: a placeholder for the output #gint8, or %NULL if not required.
 * @time_zone_3gpp2_daylight_saving_time: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Time Zone 3GPP2' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_time_zone_3gpp2 (
    QmiMessageNasGetServingSystemOutput *self,
    guint8 *time_zone_3gpp2_leap_seconds,
    gint8 *time_zone_3gpp2_local_time_offset,
    gboolean *time_zone_3gpp2_daylight_saving_time,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_time_zone_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Time Zone 3GPP2' was not found in the message");
        return FALSE;
    }

    if (time_zone_3gpp2_leap_seconds)
        *time_zone_3gpp2_leap_seconds = self->arg_time_zone_3gpp2_leap_seconds;
    if (time_zone_3gpp2_local_time_offset)
        *time_zone_3gpp2_local_time_offset = self->arg_time_zone_3gpp2_local_time_offset;
    if (time_zone_3gpp2_daylight_saving_time)
        *time_zone_3gpp2_daylight_saving_time = (gboolean)(self->arg_time_zone_3gpp2_daylight_saving_time);

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_default_roaming_indicator:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @default_roaming_indicator: a placeholder for the output #QmiNasRoamingIndicatorStatus, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Default Roaming Indicator' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_default_roaming_indicator (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasRoamingIndicatorStatus *default_roaming_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_default_roaming_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Default Roaming Indicator' was not found in the message");
        return FALSE;
    }

    if (default_roaming_indicator)
        *default_roaming_indicator = (QmiNasRoamingIndicatorStatus)(self->arg_default_roaming_indicator);

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_roaming_indicator_list:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @roaming_indicator_list: a placeholder for the output #GArray of #QmiMessageNasGetServingSystemOutputRoamingIndicatorListElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Roaming Indicator List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_roaming_indicator_list (
    QmiMessageNasGetServingSystemOutput *self,
    GArray **roaming_indicator_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_indicator_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Indicator List' was not found in the message");
        return FALSE;
    }

    if (roaming_indicator_list)
        *roaming_indicator_list = self->arg_roaming_indicator_list;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_cdma_base_station_info:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @cdma_base_station_info_base_station_id: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_base_station_info_base_station_latitude: a placeholder for the output #gint32, or %NULL if not required.
 * @cdma_base_station_info_base_station_longitude: a placeholder for the output #gint32, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA Base Station Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_cdma_base_station_info (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *cdma_base_station_info_base_station_id,
    gint32 *cdma_base_station_info_base_station_latitude,
    gint32 *cdma_base_station_info_base_station_longitude,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_base_station_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Base Station Info' was not found in the message");
        return FALSE;
    }

    if (cdma_base_station_info_base_station_id)
        *cdma_base_station_info_base_station_id = self->arg_cdma_base_station_info_base_station_id;
    if (cdma_base_station_info_base_station_latitude)
        *cdma_base_station_info_base_station_latitude = self->arg_cdma_base_station_info_base_station_latitude;
    if (cdma_base_station_info_base_station_longitude)
        *cdma_base_station_info_base_station_longitude = self->arg_cdma_base_station_info_base_station_longitude;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_cdma_system_id:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @cdma_system_id_sid: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_id_nid: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA System ID' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_cdma_system_id (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *cdma_system_id_sid,
    guint16 *cdma_system_id_nid,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System ID' was not found in the message");
        return FALSE;
    }

    if (cdma_system_id_sid)
        *cdma_system_id_sid = self->arg_cdma_system_id_sid;
    if (cdma_system_id_nid)
        *cdma_system_id_nid = self->arg_cdma_system_id_nid;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_current_plmn:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @current_plmn_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @current_plmn_mnc: a placeholder for the output #guint16, or %NULL if not required.
 * @current_plmn_description: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Current PLMN' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_current_plmn (
    QmiMessageNasGetServingSystemOutput *self,
    guint16 *current_plmn_mcc,
    guint16 *current_plmn_mnc,
    const gchar **current_plmn_description,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_current_plmn_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Current PLMN' was not found in the message");
        return FALSE;
    }

    if (current_plmn_mcc)
        *current_plmn_mcc = self->arg_current_plmn_mcc;
    if (current_plmn_mnc)
        *current_plmn_mnc = self->arg_current_plmn_mnc;
    if (current_plmn_description)
        *current_plmn_description = self->arg_current_plmn_description;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_data_service_capability:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @data_service_capability: a placeholder for the output #GArray of #QmiNasDataCapability elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Data Service Capability' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_data_service_capability (
    QmiMessageNasGetServingSystemOutput *self,
    GArray **data_service_capability,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_data_service_capability_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Data Service Capability' was not found in the message");
        return FALSE;
    }

    if (data_service_capability)
        *data_service_capability = self->arg_data_service_capability;

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_roaming_indicator:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @roaming_indicator: a placeholder for the output #QmiNasRoamingIndicatorStatus, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Roaming Indicator' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_roaming_indicator (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasRoamingIndicatorStatus *roaming_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Indicator' was not found in the message");
        return FALSE;
    }

    if (roaming_indicator)
        *roaming_indicator = (QmiNasRoamingIndicatorStatus)(self->arg_roaming_indicator);

    return TRUE;
}

/**
 * qmi_message_nas_get_serving_system_output_get_serving_system:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 * @serving_system_registration_state: a placeholder for the output #QmiNasRegistrationState, or %NULL if not required.
 * @serving_system_cs_attach_state: a placeholder for the output #QmiNasAttachState, or %NULL if not required.
 * @serving_system_ps_attach_state: a placeholder for the output #QmiNasAttachState, or %NULL if not required.
 * @serving_system_selected_network: a placeholder for the output #QmiNasNetworkType, or %NULL if not required.
 * @serving_system_radio_interfaces: a placeholder for the output #GArray of #QmiNasRadioInterface elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Serving System' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_serving_system_output_get_serving_system (
    QmiMessageNasGetServingSystemOutput *self,
    QmiNasRegistrationState *serving_system_registration_state,
    QmiNasAttachState *serving_system_cs_attach_state,
    QmiNasAttachState *serving_system_ps_attach_state,
    QmiNasNetworkType *serving_system_selected_network,
    GArray **serving_system_radio_interfaces,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_serving_system_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Serving System' was not found in the message");
        return FALSE;
    }

    if (serving_system_registration_state)
        *serving_system_registration_state = (QmiNasRegistrationState)(self->arg_serving_system_registration_state);
    if (serving_system_cs_attach_state)
        *serving_system_cs_attach_state = (QmiNasAttachState)(self->arg_serving_system_cs_attach_state);
    if (serving_system_ps_attach_state)
        *serving_system_ps_attach_state = (QmiNasAttachState)(self->arg_serving_system_ps_attach_state);
    if (serving_system_selected_network)
        *serving_system_selected_network = (QmiNasNetworkType)(self->arg_serving_system_selected_network);
    if (serving_system_radio_interfaces)
        *serving_system_radio_interfaces = self->arg_serving_system_radio_interfaces;

    return TRUE;
}

GType
qmi_message_nas_get_serving_system_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetServingSystemOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_serving_system_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_serving_system_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_get_serving_system_output_ref:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasGetServingSystemOutput *
qmi_message_nas_get_serving_system_output_ref (QmiMessageNasGetServingSystemOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_get_serving_system_output_unref:
 * @self: a #QmiMessageNasGetServingSystemOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_get_serving_system_output_unref (QmiMessageNasGetServingSystemOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_roaming_indicator_list)
            g_array_unref (self->arg_roaming_indicator_list);
        g_free (self->arg_current_plmn_description);
        if (self->arg_data_service_capability)
            g_array_unref (self->arg_data_service_capability);
        if (self->arg_serving_system_radio_interfaces)
            g_array_unref (self->arg_serving_system_radio_interfaces);
        g_slice_free (QmiMessageNasGetServingSystemOutput, self);
    }
}

static gboolean
qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'MNC PCS Digit Include Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'MNC PCS Digit Include Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " includes_pcs_digit = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'MNC PCS Digit Include Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_umts_primary_scrambling_code_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'UMTS Primary Scrambling Code' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'UMTS Primary Scrambling Code' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_umts_primary_scrambling_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_umts_primary_scrambling_code_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'UMTS Primary Scrambling Code' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_call_barring_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Call Barring Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Call Barring Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_call_barring_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " cs_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Call Barring Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_lte_tac_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE TAC' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE TAC' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_lte_tac_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_lte_tac_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE TAC' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_hdr_personality_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'HDR Personality' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'HDR Personality' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_hdr_personality_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_hdr_personality_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_HDR_PERSONALITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_hdr_personality_get_string ((QmiNasHdrPersonality)tmp));
#elif defined  __QMI_NAS_HDR_PERSONALITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_hdr_personality_build_string_from_mask ((QmiNasHdrPersonality)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasHdrPersonality
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'HDR Personality' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_cdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_cdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " imsi_11_12 = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_detailed_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Detailed Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Detailed Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_detailed_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_detailed_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hdr_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hdr_hybrid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Detailed Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_dtm_support_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'DTM Support' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'DTM Support' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_dtm_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_dtm_support_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'DTM Support' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_prl_indicator_3gpp2_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PRL Indicator 3GPP2' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PRL Indicator 3GPP2' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_prl_indicator_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_prl_indicator_3gpp2_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PRL Indicator 3GPP2' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_concurrent_service_info_3gpp2_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Concurrent Service Info 3GPP2' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Concurrent Service Info 3GPP2' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_concurrent_service_info_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_concurrent_service_info_3gpp2_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Concurrent Service Info 3GPP2' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_cid_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CID 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CID 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_cid_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_cid_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CID 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_lac_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LAC 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LAC 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_lac_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_lac_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LAC 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_daylight_saving_time_adjustment_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Daylight Saving Time Adjustment 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Daylight Saving Time Adjustment 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_daylight_saving_time_adjustment_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_daylight_saving_time_adjustment_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Daylight Saving Time Adjustment 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_time_zone_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Time Zone 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Time Zone 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_time_zone_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_time_zone_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Time Zone 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_cdma_p_rev_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA P Rev' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA P Rev' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_cdma_p_rev_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_cdma_p_rev_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA P Rev' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_time_zone_3gpp2_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Time Zone 3GPP2' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Time Zone 3GPP2' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_time_zone_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_time_zone_3gpp2_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " leap_seconds = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " local_time_offset = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " daylight_saving_time = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Time Zone 3GPP2' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_default_roaming_indicator_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Default Roaming Indicator' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Default Roaming Indicator' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_default_roaming_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_default_roaming_indicator_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Default Roaming Indicator' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_roaming_indicator_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint roaming_indicator_list_i;
        guint8 roaming_indicator_list_n_items;
        const guint8 *roaming_indicator_list_aux_buffer = &buffer[expected_len];
        guint16 roaming_indicator_list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &roaming_indicator_list_aux_buffer,
            &roaming_indicator_list_aux_buffer_len,
            &(roaming_indicator_list_n_items));
        for (roaming_indicator_list_i = 0; roaming_indicator_list_i < roaming_indicator_list_n_items; roaming_indicator_list_i++) {

            expected_len += 1;
            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Roaming Indicator List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Roaming Indicator List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_roaming_indicator_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_roaming_indicator_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint roaming_indicator_list_i;
            guint8 roaming_indicator_list_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(roaming_indicator_list_n_items));

            g_string_append (printable, "{");

            for (roaming_indicator_list_i = 0; roaming_indicator_list_i < roaming_indicator_list_n_items; roaming_indicator_list_i++) {
                g_string_append_printf (printable, " [%u] = '", roaming_indicator_list_i);
                g_string_append (printable, "[");
                g_string_append (printable, " radio_interface = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " roaming_indicator = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Roaming Indicator List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_cdma_base_station_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 4;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA Base Station Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA Base Station Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_cdma_base_station_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_cdma_base_station_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " base_station_id = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_latitude = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_longitude = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA Base Station Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_cdma_system_id_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA System ID' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA System ID' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_cdma_system_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_cdma_system_id_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " sid = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " nid = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA System ID' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_current_plmn_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Current PLMN' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Current PLMN' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_current_plmn_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_current_plmn_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " description = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Current PLMN' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_data_service_capability_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint data_service_capability_i;
        guint8 data_service_capability_n_items;
        const guint8 *data_service_capability_aux_buffer = &buffer[expected_len];
        guint16 data_service_capability_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &data_service_capability_aux_buffer,
            &data_service_capability_aux_buffer_len,
            &(data_service_capability_n_items));
        for (data_service_capability_i = 0; data_service_capability_i < data_service_capability_n_items; data_service_capability_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Data Service Capability' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Data Service Capability' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_data_service_capability_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_data_service_capability_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint data_service_capability_i;
            guint8 data_service_capability_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(data_service_capability_n_items));

            g_string_append (printable, "{");

            for (data_service_capability_i = 0; data_service_capability_i < data_service_capability_n_items; data_service_capability_i++) {
                g_string_append_printf (printable, " [%u] = '", data_service_capability_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_DATA_CAPABILITY_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_data_capability_get_string ((QmiNasDataCapability)tmp));
#elif defined  __QMI_NAS_DATA_CAPABILITY_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_data_capability_build_string_from_mask ((QmiNasDataCapability)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasDataCapability
#endif
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Data Service Capability' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_roaming_indicator_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Roaming Indicator' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Roaming Indicator' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_roaming_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_roaming_indicator_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Roaming Indicator' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_serving_system_output_serving_system_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    {
        guint radio_interfaces_i;
        guint8 radio_interfaces_n_items;
        const guint8 *radio_interfaces_aux_buffer = &buffer[expected_len];
        guint16 radio_interfaces_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &radio_interfaces_aux_buffer,
            &radio_interfaces_aux_buffer_len,
            &(radio_interfaces_n_items));
        for (radio_interfaces_i = 0; radio_interfaces_i < radio_interfaces_n_items; radio_interfaces_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Serving System' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Serving System' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_serving_system_output_serving_system_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_serving_system_output_serving_system_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " registration_state = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_REGISTRATION_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_registration_state_get_string ((QmiNasRegistrationState)tmp));
#elif defined  __QMI_NAS_REGISTRATION_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_registration_state_build_string_from_mask ((QmiNasRegistrationState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRegistrationState
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cs_attach_state = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ATTACH_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_attach_state_get_string ((QmiNasAttachState)tmp));
#elif defined  __QMI_NAS_ATTACH_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_attach_state_build_string_from_mask ((QmiNasAttachState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasAttachState
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_attach_state = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ATTACH_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_attach_state_get_string ((QmiNasAttachState)tmp));
#elif defined  __QMI_NAS_ATTACH_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_attach_state_build_string_from_mask ((QmiNasAttachState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasAttachState
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " selected_network = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_TYPE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_type_get_string ((QmiNasNetworkType)tmp));
#elif defined  __QMI_NAS_NETWORK_TYPE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_type_build_string_from_mask ((QmiNasNetworkType)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkType
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interfaces = '");
        {
            guint radio_interfaces_i;
            guint8 radio_interfaces_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(radio_interfaces_n_items));

            g_string_append (printable, "{");

            for (radio_interfaces_i = 0; radio_interfaces_i < radio_interfaces_n_items; radio_interfaces_i++) {
                g_string_append_printf (printable, " [%u] = '", radio_interfaces_i);

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Serving System' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_serving_system_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_serving_system_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_serving_system_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE:
            tlv_type_str = "UMTS Primary Scrambling Code";
            translated_value = qmi_message_nas_get_serving_system_output_umts_primary_scrambling_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS:
            tlv_type_str = "Call Barring Status";
            translated_value = qmi_message_nas_get_serving_system_output_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC:
            tlv_type_str = "LTE TAC";
            translated_value = qmi_message_nas_get_serving_system_output_lte_tac_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY:
            tlv_type_str = "HDR Personality";
            translated_value = qmi_message_nas_get_serving_system_output_hdr_personality_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO:
            tlv_type_str = "CDMA System Info";
            translated_value = qmi_message_nas_get_serving_system_output_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS:
            tlv_type_str = "Detailed Service Status";
            translated_value = qmi_message_nas_get_serving_system_output_detailed_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT:
            tlv_type_str = "DTM Support";
            translated_value = qmi_message_nas_get_serving_system_output_dtm_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2:
            tlv_type_str = "PRL Indicator 3GPP2";
            translated_value = qmi_message_nas_get_serving_system_output_prl_indicator_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2:
            tlv_type_str = "Concurrent Service Info 3GPP2";
            translated_value = qmi_message_nas_get_serving_system_output_concurrent_service_info_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP:
            tlv_type_str = "CID 3GPP";
            translated_value = qmi_message_nas_get_serving_system_output_cid_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP:
            tlv_type_str = "LAC 3GPP";
            translated_value = qmi_message_nas_get_serving_system_output_lac_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP:
            tlv_type_str = "Daylight Saving Time Adjustment 3GPP";
            translated_value = qmi_message_nas_get_serving_system_output_daylight_saving_time_adjustment_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP:
            tlv_type_str = "Time Zone 3GPP";
            translated_value = qmi_message_nas_get_serving_system_output_time_zone_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV:
            tlv_type_str = "CDMA P Rev";
            translated_value = qmi_message_nas_get_serving_system_output_cdma_p_rev_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2:
            tlv_type_str = "Time Zone 3GPP2";
            translated_value = qmi_message_nas_get_serving_system_output_time_zone_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR:
            tlv_type_str = "Default Roaming Indicator";
            translated_value = qmi_message_nas_get_serving_system_output_default_roaming_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST:
            tlv_type_str = "Roaming Indicator List";
            translated_value = qmi_message_nas_get_serving_system_output_roaming_indicator_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO:
            tlv_type_str = "CDMA Base Station Info";
            translated_value = qmi_message_nas_get_serving_system_output_cdma_base_station_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID:
            tlv_type_str = "CDMA System ID";
            translated_value = qmi_message_nas_get_serving_system_output_cdma_system_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN:
            tlv_type_str = "Current PLMN";
            translated_value = qmi_message_nas_get_serving_system_output_current_plmn_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY:
            tlv_type_str = "Data Service Capability";
            translated_value = qmi_message_nas_get_serving_system_output_data_service_capability_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR:
            tlv_type_str = "Roaming Indicator";
            translated_value = qmi_message_nas_get_serving_system_output_roaming_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM:
            tlv_type_str = "Serving System";
            translated_value = qmi_message_nas_get_serving_system_output_serving_system_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_serving_system_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Serving System\" (0x0024)\n",
                            line_prefix);

    {
        struct message_get_serving_system_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_serving_system_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetServingSystemOutput *
__qmi_message_nas_get_serving_system_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetServingSystemOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_GET_SERVING_SYSTEM, NULL);

    self = g_slice_new0 (QmiMessageNasGetServingSystemOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_get_serving_system_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_mnc_pcs_digit_include_status_validate (buffer, buffer_len)) {
                self->arg_mnc_pcs_digit_include_status_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_mnc_pcs_digit_include_status_mcc));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_mnc_pcs_digit_include_status_mnc));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_mnc_pcs_digit_include_status_includes_pcs_digit = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'MNC PCS Digit Include Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_umts_primary_scrambling_code_validate (buffer, buffer_len)) {
                self->arg_umts_primary_scrambling_code_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_umts_primary_scrambling_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'UMTS Primary Scrambling Code' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_call_barring_status_validate (buffer, buffer_len)) {
                self->arg_call_barring_status_set = TRUE;

                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
                }
                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Call Barring Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_lte_tac_validate (buffer, buffer_len)) {
                self->arg_lte_tac_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_tac));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE TAC' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_hdr_personality_validate (buffer, buffer_len)) {
                self->arg_hdr_personality_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_personality = (QmiNasHdrPersonality)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'HDR Personality' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_cdma_system_info_validate (buffer, buffer_len)) {
                self->arg_cdma_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_mcc));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_system_info_imsi_11_12));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_detailed_service_status_validate (buffer, buffer_len)) {
                self->arg_detailed_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_detailed_service_status_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_detailed_service_status_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_detailed_service_status_hdr_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_detailed_service_status_hdr_hybrid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_detailed_service_status_forbidden = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Detailed Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_dtm_support_validate (buffer, buffer_len)) {
                self->arg_dtm_support_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_dtm_support = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'DTM Support' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_prl_indicator_3gpp2_validate (buffer, buffer_len)) {
                self->arg_prl_indicator_3gpp2_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_prl_indicator_3gpp2 = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PRL Indicator 3GPP2' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_concurrent_service_info_3gpp2_validate (buffer, buffer_len)) {
                self->arg_concurrent_service_info_3gpp2_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_concurrent_service_info_3gpp2 = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Concurrent Service Info 3GPP2' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_cid_3gpp_validate (buffer, buffer_len)) {
                self->arg_cid_3gpp_set = TRUE;

                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cid_3gpp));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CID 3GPP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_lac_3gpp_validate (buffer, buffer_len)) {
                self->arg_lac_3gpp_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lac_3gpp));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LAC 3GPP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_daylight_saving_time_adjustment_3gpp_validate (buffer, buffer_len)) {
                self->arg_daylight_saving_time_adjustment_3gpp_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_daylight_saving_time_adjustment_3gpp));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Daylight Saving Time Adjustment 3GPP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_time_zone_3gpp_validate (buffer, buffer_len)) {
                self->arg_time_zone_3gpp_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_time_zone_3gpp));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Time Zone 3GPP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_cdma_p_rev_validate (buffer, buffer_len)) {
                self->arg_cdma_p_rev_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_p_rev));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA P Rev' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_time_zone_3gpp2_validate (buffer, buffer_len)) {
                self->arg_time_zone_3gpp2_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_time_zone_3gpp2_leap_seconds));
                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_time_zone_3gpp2_local_time_offset));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_time_zone_3gpp2_daylight_saving_time = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Time Zone 3GPP2' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_default_roaming_indicator_validate (buffer, buffer_len)) {
                self->arg_default_roaming_indicator_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_default_roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Default Roaming Indicator' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_roaming_indicator_list_validate (buffer, buffer_len)) {
                self->arg_roaming_indicator_list_set = TRUE;

                {
                    guint roaming_indicator_list_i;
                    guint8 roaming_indicator_list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(roaming_indicator_list_n_items));

                    self->arg_roaming_indicator_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageNasGetServingSystemOutputRoamingIndicatorListElement),
                        (guint)roaming_indicator_list_n_items);

                    for (roaming_indicator_list_i = 0; roaming_indicator_list_i < roaming_indicator_list_n_items; roaming_indicator_list_i++) {
                        QmiMessageNasGetServingSystemOutputRoamingIndicatorListElement roaming_indicator_list_aux;

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            roaming_indicator_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                        }
                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            roaming_indicator_list_aux.roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
                        }
                        g_array_insert_val (self->arg_roaming_indicator_list, roaming_indicator_list_i, roaming_indicator_list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Roaming Indicator List' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_cdma_base_station_info_validate (buffer, buffer_len)) {
                self->arg_cdma_base_station_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_base_station_info_base_station_id));
                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_base_station_info_base_station_latitude));
                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_base_station_info_base_station_longitude));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA Base Station Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_cdma_system_id_validate (buffer, buffer_len)) {
                self->arg_cdma_system_id_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_id_sid));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_id_nid));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA System ID' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_current_plmn_validate (buffer, buffer_len)) {
                self->arg_current_plmn_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_current_plmn_mcc));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_current_plmn_mnc));
                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    8,
                    0,
                    &(self->arg_current_plmn_description));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Current PLMN' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_data_service_capability_validate (buffer, buffer_len)) {
                self->arg_data_service_capability_set = TRUE;

                {
                    guint data_service_capability_i;
                    guint8 data_service_capability_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(data_service_capability_n_items));

                    self->arg_data_service_capability = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiNasDataCapability),
                        (guint)data_service_capability_n_items);

                    for (data_service_capability_i = 0; data_service_capability_i < data_service_capability_n_items; data_service_capability_i++) {
                        QmiNasDataCapability data_service_capability_aux;

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            data_service_capability_aux = (QmiNasDataCapability)tmp;
                        }
                        g_array_insert_val (self->arg_data_service_capability, data_service_capability_i, data_service_capability_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Data Service Capability' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_roaming_indicator_validate (buffer, buffer_len)) {
                self->arg_roaming_indicator_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Roaming Indicator' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_serving_system_output_serving_system_validate (buffer, buffer_len)) {
                self->arg_serving_system_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_serving_system_registration_state = (QmiNasRegistrationState)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_serving_system_cs_attach_state = (QmiNasAttachState)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_serving_system_ps_attach_state = (QmiNasAttachState)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_serving_system_selected_network = (QmiNasNetworkType)tmp;
                }
                {
                    guint radio_interfaces_i;
                    guint8 radio_interfaces_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(radio_interfaces_n_items));

                    self->arg_serving_system_radio_interfaces = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiNasRadioInterface),
                        (guint)radio_interfaces_n_items);

                    for (radio_interfaces_i = 0; radio_interfaces_i < radio_interfaces_n_items; radio_interfaces_i++) {
                        QmiNasRadioInterface radio_interfaces_aux;

                        {
                            gint8 tmp;

                            /* Read the gint8 variable from the buffer */
                            qmi_utils_read_gint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            radio_interfaces_aux = (QmiNasRadioInterface)tmp;
                        }
                        g_array_insert_val (self->arg_serving_system_radio_interfaces, radio_interfaces_i, radio_interfaces_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Serving System' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Serving System TLV: Not found");
                qmi_message_nas_get_serving_system_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS Serving System */


/* --- Output -- */

struct _QmiIndicationNasServingSystemOutput {
    volatile gint ref_count;

    /* MNC PCS Digit Include Status */
    gboolean arg_mnc_pcs_digit_include_status_set;
    guint16 arg_mnc_pcs_digit_include_status_mcc;
    guint16 arg_mnc_pcs_digit_include_status_mnc;
    guint8 arg_mnc_pcs_digit_include_status_includes_pcs_digit;

    /* UMTS Primary Scrambling Code */
    gboolean arg_umts_primary_scrambling_code_set;
    guint16 arg_umts_primary_scrambling_code;

    /* PLMN Not Changed Indication */
    gboolean arg_plmn_not_changed_indication_set;
    guint8 arg_plmn_not_changed_indication;

    /* Call Barring Status */
    gboolean arg_call_barring_status_set;
    gint32 arg_call_barring_status_cs_status;
    gint32 arg_call_barring_status_ps_status;

    /* LTE TAC */
    gboolean arg_lte_tac_set;
    guint16 arg_lte_tac;

    /* HDR Personality */
    gboolean arg_hdr_personality_set;
    guint8 arg_hdr_personality;

    /* CDMA System Info */
    gboolean arg_cdma_system_info_set;
    guint16 arg_cdma_system_info_mcc;
    guint8 arg_cdma_system_info_imsi_11_12;

    /* Detailed Service Status */
    gboolean arg_detailed_service_status_set;
    guint8 arg_detailed_service_status_status;
    guint8 arg_detailed_service_status_capability;
    guint8 arg_detailed_service_status_hdr_status;
    guint8 arg_detailed_service_status_hdr_hybrid;
    guint8 arg_detailed_service_status_forbidden;

    /* DTM Support */
    gboolean arg_dtm_support_set;
    guint8 arg_dtm_support;

    /* PRL Indicator 3GPP2 */
    gboolean arg_prl_indicator_3gpp2_set;
    guint8 arg_prl_indicator_3gpp2;

    /* Concurrent Service Info 3GPP2 */
    gboolean arg_concurrent_service_info_3gpp2_set;
    guint8 arg_concurrent_service_info_3gpp2;

    /* CID 3GPP */
    gboolean arg_cid_3gpp_set;
    guint32 arg_cid_3gpp;

    /* LAC 3GPP */
    gboolean arg_lac_3gpp_set;
    guint16 arg_lac_3gpp;

    /* Universal Time and Local Time Zone 3GPP */
    gboolean arg_universal_time_and_local_time_zone_3gpp_set;
    guint16 arg_universal_time_and_local_time_zone_3gpp_year;
    guint8 arg_universal_time_and_local_time_zone_3gpp_month;
    guint8 arg_universal_time_and_local_time_zone_3gpp_day;
    guint8 arg_universal_time_and_local_time_zone_3gpp_hour;
    guint8 arg_universal_time_and_local_time_zone_3gpp_minute;
    guint8 arg_universal_time_and_local_time_zone_3gpp_second;
    guint8 arg_universal_time_and_local_time_zone_3gpp_time_zone;

    /* Daylight Saving Time Adjustment 3GPP */
    gboolean arg_daylight_saving_time_adjustment_3gpp_set;
    guint8 arg_daylight_saving_time_adjustment_3gpp;

    /* Time Zone 3GPP */
    gboolean arg_time_zone_3gpp_set;
    gint8 arg_time_zone_3gpp;

    /* PLMN Name Flag 3GPP */
    gboolean arg_plmn_name_flag_3gpp_set;
    gint8 arg_plmn_name_flag_3gpp;

    /* CDMA P Rev */
    gboolean arg_cdma_p_rev_set;
    guint8 arg_cdma_p_rev;

    /* Time Zone 3GPP2 */
    gboolean arg_time_zone_3gpp2_set;
    guint8 arg_time_zone_3gpp2_leap_seconds;
    gint8 arg_time_zone_3gpp2_local_time_offset;
    guint8 arg_time_zone_3gpp2_daylight_saving_time;

    /* Default Roaming Indicator */
    gboolean arg_default_roaming_indicator_set;
    guint8 arg_default_roaming_indicator;

    /* Roaming Indicator List */
    gboolean arg_roaming_indicator_list_set;
    GArray *arg_roaming_indicator_list;

    /* CDMA Base Station Info */
    gboolean arg_cdma_base_station_info_set;
    guint16 arg_cdma_base_station_info_base_station_id;
    gint32 arg_cdma_base_station_info_base_station_latitude;
    gint32 arg_cdma_base_station_info_base_station_longitude;

    /* CDMA System ID */
    gboolean arg_cdma_system_id_set;
    guint16 arg_cdma_system_id_sid;
    guint16 arg_cdma_system_id_nid;

    /* Current PLMN */
    gboolean arg_current_plmn_set;
    guint16 arg_current_plmn_mcc;
    guint16 arg_current_plmn_mnc;
    gchar *arg_current_plmn_description;

    /* Data Service Capability */
    gboolean arg_data_service_capability_set;
    GArray *arg_data_service_capability;

    /* Roaming Indicator */
    gboolean arg_roaming_indicator_set;
    guint8 arg_roaming_indicator;

    /* Serving System */
    gboolean arg_serving_system_set;
    guint8 arg_serving_system_registration_state;
    guint8 arg_serving_system_cs_attach_state;
    guint8 arg_serving_system_ps_attach_state;
    guint8 arg_serving_system_selected_network;
    GArray *arg_serving_system_radio_interfaces;
};

#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS 0x29
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE 0x28
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION 0x27
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS 0x26
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC 0x25
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY 0x24
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO 0x23
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS 0x22
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT 0x21
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2 0x20
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2 0x1F
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP 0x1E
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP 0x1D
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UNIVERSAL_TIME_AND_LOCAL_TIME_ZONE_3GPP 0x1C
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP 0x1B
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP 0x1A
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NAME_FLAG_3GPP 0x19
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV 0x18
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2 0x17
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR 0x16
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST 0x15
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO 0x14
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID 0x13
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN 0x12
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY 0x11
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR 0x10
#define QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM 0x01

/**
 * qmi_indication_nas_serving_system_output_get_mnc_pcs_digit_include_status:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @mnc_pcs_digit_include_status_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @mnc_pcs_digit_include_status_mnc: a placeholder for the output #guint16, or %NULL if not required.
 * @mnc_pcs_digit_include_status_includes_pcs_digit: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'MNC PCS Digit Include Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_mnc_pcs_digit_include_status (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *mnc_pcs_digit_include_status_mcc,
    guint16 *mnc_pcs_digit_include_status_mnc,
    gboolean *mnc_pcs_digit_include_status_includes_pcs_digit,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pcs_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PCS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (mnc_pcs_digit_include_status_mcc)
        *mnc_pcs_digit_include_status_mcc = self->arg_mnc_pcs_digit_include_status_mcc;
    if (mnc_pcs_digit_include_status_mnc)
        *mnc_pcs_digit_include_status_mnc = self->arg_mnc_pcs_digit_include_status_mnc;
    if (mnc_pcs_digit_include_status_includes_pcs_digit)
        *mnc_pcs_digit_include_status_includes_pcs_digit = (gboolean)(self->arg_mnc_pcs_digit_include_status_includes_pcs_digit);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_umts_primary_scrambling_code:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @umts_primary_scrambling_code: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'UMTS Primary Scrambling Code' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_umts_primary_scrambling_code (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *umts_primary_scrambling_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_umts_primary_scrambling_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'UMTS Primary Scrambling Code' was not found in the message");
        return FALSE;
    }

    if (umts_primary_scrambling_code)
        *umts_primary_scrambling_code = self->arg_umts_primary_scrambling_code;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_plmn_not_changed_indication:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @plmn_not_changed_indication: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PLMN Not Changed Indication' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_plmn_not_changed_indication (
    QmiIndicationNasServingSystemOutput *self,
    gboolean *plmn_not_changed_indication,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_plmn_not_changed_indication_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PLMN Not Changed Indication' was not found in the message");
        return FALSE;
    }

    if (plmn_not_changed_indication)
        *plmn_not_changed_indication = (gboolean)(self->arg_plmn_not_changed_indication);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_call_barring_status:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @call_barring_status_cs_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @call_barring_status_ps_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Call Barring Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_call_barring_status (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasCallBarringStatus *call_barring_status_cs_status,
    QmiNasCallBarringStatus *call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (call_barring_status_cs_status)
        *call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_call_barring_status_cs_status);
    if (call_barring_status_ps_status)
        *call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_call_barring_status_ps_status);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_lte_tac:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @lte_tac: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE TAC' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_lte_tac (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *lte_tac,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_tac_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE TAC' was not found in the message");
        return FALSE;
    }

    if (lte_tac)
        *lte_tac = self->arg_lte_tac;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_hdr_personality:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @hdr_personality: a placeholder for the output #QmiNasHdrPersonality, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'HDR Personality' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_hdr_personality (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasHdrPersonality *hdr_personality,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_personality_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Personality' was not found in the message");
        return FALSE;
    }

    if (hdr_personality)
        *hdr_personality = (QmiNasHdrPersonality)(self->arg_hdr_personality);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_cdma_system_info:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @cdma_system_info_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_info_imsi_11_12: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_cdma_system_info (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *cdma_system_info_mcc,
    guint8 *cdma_system_info_imsi_11_12,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (cdma_system_info_mcc)
        *cdma_system_info_mcc = self->arg_cdma_system_info_mcc;
    if (cdma_system_info_imsi_11_12)
        *cdma_system_info_imsi_11_12 = self->arg_cdma_system_info_imsi_11_12;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_detailed_service_status:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @detailed_service_status_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @detailed_service_status_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @detailed_service_status_hdr_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @detailed_service_status_hdr_hybrid: a placeholder for the output #gboolean, or %NULL if not required.
 * @detailed_service_status_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Detailed Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_detailed_service_status (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasServiceStatus *detailed_service_status_status,
    QmiNasNetworkServiceDomain *detailed_service_status_capability,
    QmiNasServiceStatus *detailed_service_status_hdr_status,
    gboolean *detailed_service_status_hdr_hybrid,
    gboolean *detailed_service_status_forbidden,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_detailed_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Detailed Service Status' was not found in the message");
        return FALSE;
    }

    if (detailed_service_status_status)
        *detailed_service_status_status = (QmiNasServiceStatus)(self->arg_detailed_service_status_status);
    if (detailed_service_status_capability)
        *detailed_service_status_capability = (QmiNasNetworkServiceDomain)(self->arg_detailed_service_status_capability);
    if (detailed_service_status_hdr_status)
        *detailed_service_status_hdr_status = (QmiNasServiceStatus)(self->arg_detailed_service_status_hdr_status);
    if (detailed_service_status_hdr_hybrid)
        *detailed_service_status_hdr_hybrid = (gboolean)(self->arg_detailed_service_status_hdr_hybrid);
    if (detailed_service_status_forbidden)
        *detailed_service_status_forbidden = (gboolean)(self->arg_detailed_service_status_forbidden);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_dtm_support:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @dtm_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'DTM Support' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_dtm_support (
    QmiIndicationNasServingSystemOutput *self,
    gboolean *dtm_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_dtm_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'DTM Support' was not found in the message");
        return FALSE;
    }

    if (dtm_support)
        *dtm_support = (gboolean)(self->arg_dtm_support);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_prl_indicator_3gpp2:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @prl_indicator_3gpp2: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PRL Indicator 3GPP2' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_prl_indicator_3gpp2 (
    QmiIndicationNasServingSystemOutput *self,
    gboolean *prl_indicator_3gpp2,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_prl_indicator_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PRL Indicator 3GPP2' was not found in the message");
        return FALSE;
    }

    if (prl_indicator_3gpp2)
        *prl_indicator_3gpp2 = (gboolean)(self->arg_prl_indicator_3gpp2);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_concurrent_service_info_3gpp2:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @concurrent_service_info_3gpp2: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Concurrent Service Info 3GPP2' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_concurrent_service_info_3gpp2 (
    QmiIndicationNasServingSystemOutput *self,
    gboolean *concurrent_service_info_3gpp2,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_concurrent_service_info_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Concurrent Service Info 3GPP2' was not found in the message");
        return FALSE;
    }

    if (concurrent_service_info_3gpp2)
        *concurrent_service_info_3gpp2 = (gboolean)(self->arg_concurrent_service_info_3gpp2);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_cid_3gpp:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @cid_3gpp: a placeholder for the output #guint32, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CID 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_cid_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    guint32 *cid_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cid_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CID 3GPP' was not found in the message");
        return FALSE;
    }

    if (cid_3gpp)
        *cid_3gpp = self->arg_cid_3gpp;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_lac_3gpp:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @lac_3gpp: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LAC 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_lac_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *lac_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lac_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LAC 3GPP' was not found in the message");
        return FALSE;
    }

    if (lac_3gpp)
        *lac_3gpp = self->arg_lac_3gpp;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_universal_time_and_local_time_zone_3gpp:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @universal_time_and_local_time_zone_3gpp_year: a placeholder for the output #guint16, or %NULL if not required.
 * @universal_time_and_local_time_zone_3gpp_month: a placeholder for the output #guint8, or %NULL if not required.
 * @universal_time_and_local_time_zone_3gpp_day: a placeholder for the output #guint8, or %NULL if not required.
 * @universal_time_and_local_time_zone_3gpp_hour: a placeholder for the output #guint8, or %NULL if not required.
 * @universal_time_and_local_time_zone_3gpp_minute: a placeholder for the output #guint8, or %NULL if not required.
 * @universal_time_and_local_time_zone_3gpp_second: a placeholder for the output #guint8, or %NULL if not required.
 * @universal_time_and_local_time_zone_3gpp_time_zone: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Universal Time and Local Time Zone 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_universal_time_and_local_time_zone_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *universal_time_and_local_time_zone_3gpp_year,
    guint8 *universal_time_and_local_time_zone_3gpp_month,
    guint8 *universal_time_and_local_time_zone_3gpp_day,
    guint8 *universal_time_and_local_time_zone_3gpp_hour,
    guint8 *universal_time_and_local_time_zone_3gpp_minute,
    guint8 *universal_time_and_local_time_zone_3gpp_second,
    guint8 *universal_time_and_local_time_zone_3gpp_time_zone,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_universal_time_and_local_time_zone_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Universal Time and Local Time Zone 3GPP' was not found in the message");
        return FALSE;
    }

    if (universal_time_and_local_time_zone_3gpp_year)
        *universal_time_and_local_time_zone_3gpp_year = self->arg_universal_time_and_local_time_zone_3gpp_year;
    if (universal_time_and_local_time_zone_3gpp_month)
        *universal_time_and_local_time_zone_3gpp_month = self->arg_universal_time_and_local_time_zone_3gpp_month;
    if (universal_time_and_local_time_zone_3gpp_day)
        *universal_time_and_local_time_zone_3gpp_day = self->arg_universal_time_and_local_time_zone_3gpp_day;
    if (universal_time_and_local_time_zone_3gpp_hour)
        *universal_time_and_local_time_zone_3gpp_hour = self->arg_universal_time_and_local_time_zone_3gpp_hour;
    if (universal_time_and_local_time_zone_3gpp_minute)
        *universal_time_and_local_time_zone_3gpp_minute = self->arg_universal_time_and_local_time_zone_3gpp_minute;
    if (universal_time_and_local_time_zone_3gpp_second)
        *universal_time_and_local_time_zone_3gpp_second = self->arg_universal_time_and_local_time_zone_3gpp_second;
    if (universal_time_and_local_time_zone_3gpp_time_zone)
        *universal_time_and_local_time_zone_3gpp_time_zone = self->arg_universal_time_and_local_time_zone_3gpp_time_zone;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_daylight_saving_time_adjustment_3gpp:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @daylight_saving_time_adjustment_3gpp: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Daylight Saving Time Adjustment 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_daylight_saving_time_adjustment_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    guint8 *daylight_saving_time_adjustment_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_daylight_saving_time_adjustment_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Daylight Saving Time Adjustment 3GPP' was not found in the message");
        return FALSE;
    }

    if (daylight_saving_time_adjustment_3gpp)
        *daylight_saving_time_adjustment_3gpp = self->arg_daylight_saving_time_adjustment_3gpp;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_time_zone_3gpp:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @time_zone_3gpp: a placeholder for the output #gint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Time Zone 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_time_zone_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    gint8 *time_zone_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_time_zone_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Time Zone 3GPP' was not found in the message");
        return FALSE;
    }

    if (time_zone_3gpp)
        *time_zone_3gpp = self->arg_time_zone_3gpp;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_plmn_name_flag_3gpp:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @plmn_name_flag_3gpp: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PLMN Name Flag 3GPP' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_plmn_name_flag_3gpp (
    QmiIndicationNasServingSystemOutput *self,
    gboolean *plmn_name_flag_3gpp,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_plmn_name_flag_3gpp_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PLMN Name Flag 3GPP' was not found in the message");
        return FALSE;
    }

    if (plmn_name_flag_3gpp)
        *plmn_name_flag_3gpp = (gboolean)(self->arg_plmn_name_flag_3gpp);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_cdma_p_rev:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @cdma_p_rev: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA P Rev' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_cdma_p_rev (
    QmiIndicationNasServingSystemOutput *self,
    guint8 *cdma_p_rev,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_p_rev_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA P Rev' was not found in the message");
        return FALSE;
    }

    if (cdma_p_rev)
        *cdma_p_rev = self->arg_cdma_p_rev;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_time_zone_3gpp2:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @time_zone_3gpp2_leap_seconds: a placeholder for the output #guint8, or %NULL if not required.
 * @time_zone_3gpp2_local_time_offset: a placeholder for the output #gint8, or %NULL if not required.
 * @time_zone_3gpp2_daylight_saving_time: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Time Zone 3GPP2' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_time_zone_3gpp2 (
    QmiIndicationNasServingSystemOutput *self,
    guint8 *time_zone_3gpp2_leap_seconds,
    gint8 *time_zone_3gpp2_local_time_offset,
    gboolean *time_zone_3gpp2_daylight_saving_time,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_time_zone_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Time Zone 3GPP2' was not found in the message");
        return FALSE;
    }

    if (time_zone_3gpp2_leap_seconds)
        *time_zone_3gpp2_leap_seconds = self->arg_time_zone_3gpp2_leap_seconds;
    if (time_zone_3gpp2_local_time_offset)
        *time_zone_3gpp2_local_time_offset = self->arg_time_zone_3gpp2_local_time_offset;
    if (time_zone_3gpp2_daylight_saving_time)
        *time_zone_3gpp2_daylight_saving_time = (gboolean)(self->arg_time_zone_3gpp2_daylight_saving_time);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_default_roaming_indicator:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @default_roaming_indicator: a placeholder for the output #QmiNasRoamingIndicatorStatus, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Default Roaming Indicator' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_default_roaming_indicator (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasRoamingIndicatorStatus *default_roaming_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_default_roaming_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Default Roaming Indicator' was not found in the message");
        return FALSE;
    }

    if (default_roaming_indicator)
        *default_roaming_indicator = (QmiNasRoamingIndicatorStatus)(self->arg_default_roaming_indicator);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_roaming_indicator_list:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @roaming_indicator_list: a placeholder for the output #GArray of #QmiIndicationNasServingSystemOutputRoamingIndicatorListElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Roaming Indicator List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_roaming_indicator_list (
    QmiIndicationNasServingSystemOutput *self,
    GArray **roaming_indicator_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_indicator_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Indicator List' was not found in the message");
        return FALSE;
    }

    if (roaming_indicator_list)
        *roaming_indicator_list = self->arg_roaming_indicator_list;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_cdma_base_station_info:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @cdma_base_station_info_base_station_id: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_base_station_info_base_station_latitude: a placeholder for the output #gint32, or %NULL if not required.
 * @cdma_base_station_info_base_station_longitude: a placeholder for the output #gint32, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA Base Station Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_cdma_base_station_info (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *cdma_base_station_info_base_station_id,
    gint32 *cdma_base_station_info_base_station_latitude,
    gint32 *cdma_base_station_info_base_station_longitude,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_base_station_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Base Station Info' was not found in the message");
        return FALSE;
    }

    if (cdma_base_station_info_base_station_id)
        *cdma_base_station_info_base_station_id = self->arg_cdma_base_station_info_base_station_id;
    if (cdma_base_station_info_base_station_latitude)
        *cdma_base_station_info_base_station_latitude = self->arg_cdma_base_station_info_base_station_latitude;
    if (cdma_base_station_info_base_station_longitude)
        *cdma_base_station_info_base_station_longitude = self->arg_cdma_base_station_info_base_station_longitude;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_cdma_system_id:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @cdma_system_id_sid: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_id_nid: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA System ID' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_cdma_system_id (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *cdma_system_id_sid,
    guint16 *cdma_system_id_nid,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System ID' was not found in the message");
        return FALSE;
    }

    if (cdma_system_id_sid)
        *cdma_system_id_sid = self->arg_cdma_system_id_sid;
    if (cdma_system_id_nid)
        *cdma_system_id_nid = self->arg_cdma_system_id_nid;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_current_plmn:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @current_plmn_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @current_plmn_mnc: a placeholder for the output #guint16, or %NULL if not required.
 * @current_plmn_description: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Current PLMN' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_current_plmn (
    QmiIndicationNasServingSystemOutput *self,
    guint16 *current_plmn_mcc,
    guint16 *current_plmn_mnc,
    const gchar **current_plmn_description,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_current_plmn_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Current PLMN' was not found in the message");
        return FALSE;
    }

    if (current_plmn_mcc)
        *current_plmn_mcc = self->arg_current_plmn_mcc;
    if (current_plmn_mnc)
        *current_plmn_mnc = self->arg_current_plmn_mnc;
    if (current_plmn_description)
        *current_plmn_description = self->arg_current_plmn_description;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_data_service_capability:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @data_service_capability: a placeholder for the output #GArray of #QmiNasDataCapability elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Data Service Capability' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_data_service_capability (
    QmiIndicationNasServingSystemOutput *self,
    GArray **data_service_capability,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_data_service_capability_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Data Service Capability' was not found in the message");
        return FALSE;
    }

    if (data_service_capability)
        *data_service_capability = self->arg_data_service_capability;

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_roaming_indicator:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @roaming_indicator: a placeholder for the output #QmiNasRoamingIndicatorStatus, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Roaming Indicator' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_roaming_indicator (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasRoamingIndicatorStatus *roaming_indicator,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_indicator_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Indicator' was not found in the message");
        return FALSE;
    }

    if (roaming_indicator)
        *roaming_indicator = (QmiNasRoamingIndicatorStatus)(self->arg_roaming_indicator);

    return TRUE;
}

/**
 * qmi_indication_nas_serving_system_output_get_serving_system:
 * @self: a #QmiIndicationNasServingSystemOutput.
 * @serving_system_registration_state: a placeholder for the output #QmiNasRegistrationState, or %NULL if not required.
 * @serving_system_cs_attach_state: a placeholder for the output #QmiNasAttachState, or %NULL if not required.
 * @serving_system_ps_attach_state: a placeholder for the output #QmiNasAttachState, or %NULL if not required.
 * @serving_system_selected_network: a placeholder for the output #QmiNasNetworkType, or %NULL if not required.
 * @serving_system_radio_interfaces: a placeholder for the output #GArray of #QmiNasRadioInterface elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Serving System' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_serving_system_output_get_serving_system (
    QmiIndicationNasServingSystemOutput *self,
    QmiNasRegistrationState *serving_system_registration_state,
    QmiNasAttachState *serving_system_cs_attach_state,
    QmiNasAttachState *serving_system_ps_attach_state,
    QmiNasNetworkType *serving_system_selected_network,
    GArray **serving_system_radio_interfaces,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_serving_system_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Serving System' was not found in the message");
        return FALSE;
    }

    if (serving_system_registration_state)
        *serving_system_registration_state = (QmiNasRegistrationState)(self->arg_serving_system_registration_state);
    if (serving_system_cs_attach_state)
        *serving_system_cs_attach_state = (QmiNasAttachState)(self->arg_serving_system_cs_attach_state);
    if (serving_system_ps_attach_state)
        *serving_system_ps_attach_state = (QmiNasAttachState)(self->arg_serving_system_ps_attach_state);
    if (serving_system_selected_network)
        *serving_system_selected_network = (QmiNasNetworkType)(self->arg_serving_system_selected_network);
    if (serving_system_radio_interfaces)
        *serving_system_radio_interfaces = self->arg_serving_system_radio_interfaces;

    return TRUE;
}

GType
qmi_indication_nas_serving_system_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasServingSystemOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_serving_system_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_serving_system_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_indication_nas_serving_system_output_ref:
 * @self: a #QmiIndicationNasServingSystemOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiIndicationNasServingSystemOutput *
qmi_indication_nas_serving_system_output_ref (QmiIndicationNasServingSystemOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_indication_nas_serving_system_output_unref:
 * @self: a #QmiIndicationNasServingSystemOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_indication_nas_serving_system_output_unref (QmiIndicationNasServingSystemOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_roaming_indicator_list)
            g_array_unref (self->arg_roaming_indicator_list);
        g_free (self->arg_current_plmn_description);
        if (self->arg_data_service_capability)
            g_array_unref (self->arg_data_service_capability);
        if (self->arg_serving_system_radio_interfaces)
            g_array_unref (self->arg_serving_system_radio_interfaces);
        g_slice_free (QmiIndicationNasServingSystemOutput, self);
    }
}

static gboolean
qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'MNC PCS Digit Include Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'MNC PCS Digit Include Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " includes_pcs_digit = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'MNC PCS Digit Include Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_umts_primary_scrambling_code_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'UMTS Primary Scrambling Code' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'UMTS Primary Scrambling Code' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_umts_primary_scrambling_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_umts_primary_scrambling_code_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'UMTS Primary Scrambling Code' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_plmn_not_changed_indication_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PLMN Not Changed Indication' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PLMN Not Changed Indication' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_plmn_not_changed_indication_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_plmn_not_changed_indication_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PLMN Not Changed Indication' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_call_barring_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Call Barring Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Call Barring Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_call_barring_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " cs_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Call Barring Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_lte_tac_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE TAC' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE TAC' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_lte_tac_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_lte_tac_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE TAC' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_hdr_personality_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'HDR Personality' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'HDR Personality' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_hdr_personality_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_hdr_personality_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_HDR_PERSONALITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_hdr_personality_get_string ((QmiNasHdrPersonality)tmp));
#elif defined  __QMI_NAS_HDR_PERSONALITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_hdr_personality_build_string_from_mask ((QmiNasHdrPersonality)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasHdrPersonality
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'HDR Personality' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_cdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_cdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " imsi_11_12 = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_detailed_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Detailed Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Detailed Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_detailed_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_detailed_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hdr_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hdr_hybrid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Detailed Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_dtm_support_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'DTM Support' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'DTM Support' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_dtm_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_dtm_support_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'DTM Support' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_prl_indicator_3gpp2_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PRL Indicator 3GPP2' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PRL Indicator 3GPP2' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_prl_indicator_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_prl_indicator_3gpp2_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PRL Indicator 3GPP2' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_concurrent_service_info_3gpp2_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Concurrent Service Info 3GPP2' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Concurrent Service Info 3GPP2' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_concurrent_service_info_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_concurrent_service_info_3gpp2_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Concurrent Service Info 3GPP2' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_cid_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CID 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CID 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_cid_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_cid_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CID 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_lac_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LAC 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LAC 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_lac_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_lac_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LAC 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Universal Time and Local Time Zone 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Universal Time and Local Time Zone 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UNIVERSAL_TIME_AND_LOCAL_TIME_ZONE_3GPP,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " year = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " month = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " day = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hour = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " minute = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " second = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " time_zone = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Universal Time and Local Time Zone 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_daylight_saving_time_adjustment_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Daylight Saving Time Adjustment 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Daylight Saving Time Adjustment 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_daylight_saving_time_adjustment_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_daylight_saving_time_adjustment_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Daylight Saving Time Adjustment 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_time_zone_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Time Zone 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Time Zone 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_time_zone_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_time_zone_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Time Zone 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_plmn_name_flag_3gpp_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PLMN Name Flag 3GPP' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PLMN Name Flag 3GPP' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_plmn_name_flag_3gpp_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NAME_FLAG_3GPP,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_plmn_name_flag_3gpp_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PLMN Name Flag 3GPP' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_cdma_p_rev_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA P Rev' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA P Rev' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_cdma_p_rev_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_cdma_p_rev_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA P Rev' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_time_zone_3gpp2_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Time Zone 3GPP2' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Time Zone 3GPP2' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_time_zone_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_time_zone_3gpp2_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " leap_seconds = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " local_time_offset = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " daylight_saving_time = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Time Zone 3GPP2' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_default_roaming_indicator_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Default Roaming Indicator' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Default Roaming Indicator' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_default_roaming_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_default_roaming_indicator_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Default Roaming Indicator' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_roaming_indicator_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint roaming_indicator_list_i;
        guint8 roaming_indicator_list_n_items;
        const guint8 *roaming_indicator_list_aux_buffer = &buffer[expected_len];
        guint16 roaming_indicator_list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &roaming_indicator_list_aux_buffer,
            &roaming_indicator_list_aux_buffer_len,
            &(roaming_indicator_list_n_items));
        for (roaming_indicator_list_i = 0; roaming_indicator_list_i < roaming_indicator_list_n_items; roaming_indicator_list_i++) {

            expected_len += 1;
            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Roaming Indicator List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Roaming Indicator List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_roaming_indicator_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_roaming_indicator_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint roaming_indicator_list_i;
            guint8 roaming_indicator_list_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(roaming_indicator_list_n_items));

            g_string_append (printable, "{");

            for (roaming_indicator_list_i = 0; roaming_indicator_list_i < roaming_indicator_list_n_items; roaming_indicator_list_i++) {
                g_string_append_printf (printable, " [%u] = '", roaming_indicator_list_i);
                g_string_append (printable, "[");
                g_string_append (printable, " radio_interface = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " roaming_indicator = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Roaming Indicator List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_cdma_base_station_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 4;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA Base Station Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA Base Station Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_cdma_base_station_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_cdma_base_station_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " base_station_id = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_latitude = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_longitude = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA Base Station Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_cdma_system_id_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA System ID' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA System ID' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_cdma_system_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_cdma_system_id_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " sid = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " nid = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA System ID' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_current_plmn_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Current PLMN' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Current PLMN' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_current_plmn_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_current_plmn_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " description = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Current PLMN' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_data_service_capability_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint data_service_capability_i;
        guint8 data_service_capability_n_items;
        const guint8 *data_service_capability_aux_buffer = &buffer[expected_len];
        guint16 data_service_capability_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &data_service_capability_aux_buffer,
            &data_service_capability_aux_buffer_len,
            &(data_service_capability_n_items));
        for (data_service_capability_i = 0; data_service_capability_i < data_service_capability_n_items; data_service_capability_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Data Service Capability' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Data Service Capability' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_data_service_capability_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_data_service_capability_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint data_service_capability_i;
            guint8 data_service_capability_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(data_service_capability_n_items));

            g_string_append (printable, "{");

            for (data_service_capability_i = 0; data_service_capability_i < data_service_capability_n_items; data_service_capability_i++) {
                g_string_append_printf (printable, " [%u] = '", data_service_capability_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_DATA_CAPABILITY_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_data_capability_get_string ((QmiNasDataCapability)tmp));
#elif defined  __QMI_NAS_DATA_CAPABILITY_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_data_capability_build_string_from_mask ((QmiNasDataCapability)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasDataCapability
#endif
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Data Service Capability' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_roaming_indicator_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Roaming Indicator' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Roaming Indicator' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_roaming_indicator_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_roaming_indicator_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_indicator_status_get_string ((QmiNasRoamingIndicatorStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_INDICATOR_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_indicator_status_build_string_from_mask ((QmiNasRoamingIndicatorStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingIndicatorStatus
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Roaming Indicator' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_serving_system_output_serving_system_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    {
        guint radio_interfaces_i;
        guint8 radio_interfaces_n_items;
        const guint8 *radio_interfaces_aux_buffer = &buffer[expected_len];
        guint16 radio_interfaces_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &radio_interfaces_aux_buffer,
            &radio_interfaces_aux_buffer_len,
            &(radio_interfaces_n_items));
        for (radio_interfaces_i = 0; radio_interfaces_i < radio_interfaces_n_items; radio_interfaces_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Serving System' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Serving System' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_serving_system_output_serving_system_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_serving_system_output_serving_system_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " registration_state = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_REGISTRATION_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_registration_state_get_string ((QmiNasRegistrationState)tmp));
#elif defined  __QMI_NAS_REGISTRATION_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_registration_state_build_string_from_mask ((QmiNasRegistrationState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRegistrationState
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cs_attach_state = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ATTACH_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_attach_state_get_string ((QmiNasAttachState)tmp));
#elif defined  __QMI_NAS_ATTACH_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_attach_state_build_string_from_mask ((QmiNasAttachState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasAttachState
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_attach_state = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ATTACH_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_attach_state_get_string ((QmiNasAttachState)tmp));
#elif defined  __QMI_NAS_ATTACH_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_attach_state_build_string_from_mask ((QmiNasAttachState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasAttachState
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " selected_network = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_TYPE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_type_get_string ((QmiNasNetworkType)tmp));
#elif defined  __QMI_NAS_NETWORK_TYPE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_type_build_string_from_mask ((QmiNasNetworkType)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkType
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interfaces = '");
        {
            guint radio_interfaces_i;
            guint8 radio_interfaces_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(radio_interfaces_n_items));

            g_string_append (printable, "{");

            for (radio_interfaces_i = 0; radio_interfaces_i < radio_interfaces_n_items; radio_interfaces_i++) {
                g_string_append_printf (printable, " [%u] = '", radio_interfaces_i);

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Serving System' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct indication_serving_system_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_serving_system_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_serving_system_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    {
        switch (type) {
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PCS Digit Include Status";
            translated_value = qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE:
            tlv_type_str = "UMTS Primary Scrambling Code";
            translated_value = qmi_indication_nas_serving_system_output_umts_primary_scrambling_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION:
            tlv_type_str = "PLMN Not Changed Indication";
            translated_value = qmi_indication_nas_serving_system_output_plmn_not_changed_indication_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS:
            tlv_type_str = "Call Barring Status";
            translated_value = qmi_indication_nas_serving_system_output_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC:
            tlv_type_str = "LTE TAC";
            translated_value = qmi_indication_nas_serving_system_output_lte_tac_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY:
            tlv_type_str = "HDR Personality";
            translated_value = qmi_indication_nas_serving_system_output_hdr_personality_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO:
            tlv_type_str = "CDMA System Info";
            translated_value = qmi_indication_nas_serving_system_output_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS:
            tlv_type_str = "Detailed Service Status";
            translated_value = qmi_indication_nas_serving_system_output_detailed_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT:
            tlv_type_str = "DTM Support";
            translated_value = qmi_indication_nas_serving_system_output_dtm_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2:
            tlv_type_str = "PRL Indicator 3GPP2";
            translated_value = qmi_indication_nas_serving_system_output_prl_indicator_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2:
            tlv_type_str = "Concurrent Service Info 3GPP2";
            translated_value = qmi_indication_nas_serving_system_output_concurrent_service_info_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP:
            tlv_type_str = "CID 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_cid_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP:
            tlv_type_str = "LAC 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_lac_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UNIVERSAL_TIME_AND_LOCAL_TIME_ZONE_3GPP:
            tlv_type_str = "Universal Time and Local Time Zone 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP:
            tlv_type_str = "Daylight Saving Time Adjustment 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_daylight_saving_time_adjustment_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP:
            tlv_type_str = "Time Zone 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_time_zone_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NAME_FLAG_3GPP:
            tlv_type_str = "PLMN Name Flag 3GPP";
            translated_value = qmi_indication_nas_serving_system_output_plmn_name_flag_3gpp_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV:
            tlv_type_str = "CDMA P Rev";
            translated_value = qmi_indication_nas_serving_system_output_cdma_p_rev_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2:
            tlv_type_str = "Time Zone 3GPP2";
            translated_value = qmi_indication_nas_serving_system_output_time_zone_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR:
            tlv_type_str = "Default Roaming Indicator";
            translated_value = qmi_indication_nas_serving_system_output_default_roaming_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST:
            tlv_type_str = "Roaming Indicator List";
            translated_value = qmi_indication_nas_serving_system_output_roaming_indicator_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO:
            tlv_type_str = "CDMA Base Station Info";
            translated_value = qmi_indication_nas_serving_system_output_cdma_base_station_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID:
            tlv_type_str = "CDMA System ID";
            translated_value = qmi_indication_nas_serving_system_output_cdma_system_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN:
            tlv_type_str = "Current PLMN";
            translated_value = qmi_indication_nas_serving_system_output_current_plmn_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY:
            tlv_type_str = "Data Service Capability";
            translated_value = qmi_indication_nas_serving_system_output_data_service_capability_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR:
            tlv_type_str = "Roaming Indicator";
            translated_value = qmi_indication_nas_serving_system_output_roaming_indicator_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM:
            tlv_type_str = "Serving System";
            translated_value = qmi_indication_nas_serving_system_output_serving_system_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
indication_serving_system_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Serving System\" (0x0024)\n",
                            line_prefix);

    {
        struct indication_serving_system_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_serving_system_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasServingSystemOutput *
__qmi_indication_nas_serving_system_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasServingSystemOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_INDICATION_NAS_SERVING_SYSTEM, NULL);

    self = g_slice_new0 (QmiIndicationNasServingSystemOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_MNC_PCS_DIGIT_INCLUDE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_mnc_pcs_digit_include_status_validate (buffer, buffer_len)) {
                self->arg_mnc_pcs_digit_include_status_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_mnc_pcs_digit_include_status_mcc));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_mnc_pcs_digit_include_status_mnc));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_mnc_pcs_digit_include_status_includes_pcs_digit = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'MNC PCS Digit Include Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UMTS_PRIMARY_SCRAMBLING_CODE,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_umts_primary_scrambling_code_validate (buffer, buffer_len)) {
                self->arg_umts_primary_scrambling_code_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_umts_primary_scrambling_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'UMTS Primary Scrambling Code' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_plmn_not_changed_indication_validate (buffer, buffer_len)) {
                self->arg_plmn_not_changed_indication_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_plmn_not_changed_indication = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PLMN Not Changed Indication' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CALL_BARRING_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_call_barring_status_validate (buffer, buffer_len)) {
                self->arg_call_barring_status_set = TRUE;

                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
                }
                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Call Barring Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LTE_TAC,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_lte_tac_validate (buffer, buffer_len)) {
                self->arg_lte_tac_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_tac));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE TAC' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_HDR_PERSONALITY,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_hdr_personality_validate (buffer, buffer_len)) {
                self->arg_hdr_personality_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_personality = (QmiNasHdrPersonality)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'HDR Personality' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_cdma_system_info_validate (buffer, buffer_len)) {
                self->arg_cdma_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_mcc));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_system_info_imsi_11_12));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DETAILED_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_detailed_service_status_validate (buffer, buffer_len)) {
                self->arg_detailed_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_detailed_service_status_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_detailed_service_status_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_detailed_service_status_hdr_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_detailed_service_status_hdr_hybrid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_detailed_service_status_forbidden = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Detailed Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DTM_SUPPORT,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_dtm_support_validate (buffer, buffer_len)) {
                self->arg_dtm_support_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_dtm_support = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'DTM Support' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PRL_INDICATOR_3GPP2,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_prl_indicator_3gpp2_validate (buffer, buffer_len)) {
                self->arg_prl_indicator_3gpp2_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_prl_indicator_3gpp2 = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PRL Indicator 3GPP2' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CONCURRENT_SERVICE_INFO_3GPP2,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_concurrent_service_info_3gpp2_validate (buffer, buffer_len)) {
                self->arg_concurrent_service_info_3gpp2_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_concurrent_service_info_3gpp2 = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Concurrent Service Info 3GPP2' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CID_3GPP,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_cid_3gpp_validate (buffer, buffer_len)) {
                self->arg_cid_3gpp_set = TRUE;

                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cid_3gpp));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CID 3GPP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_LAC_3GPP,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_lac_3gpp_validate (buffer, buffer_len)) {
                self->arg_lac_3gpp_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lac_3gpp));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LAC 3GPP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_UNIVERSAL_TIME_AND_LOCAL_TIME_ZONE_3GPP,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_universal_time_and_local_time_zone_3gpp_validate (buffer, buffer_len)) {
                self->arg_universal_time_and_local_time_zone_3gpp_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_universal_time_and_local_time_zone_3gpp_year));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_and_local_time_zone_3gpp_month));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_and_local_time_zone_3gpp_day));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_and_local_time_zone_3gpp_hour));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_and_local_time_zone_3gpp_minute));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_and_local_time_zone_3gpp_second));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_and_local_time_zone_3gpp_time_zone));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Universal Time and Local Time Zone 3GPP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DAYLIGHT_SAVING_TIME_ADJUSTMENT_3GPP,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_daylight_saving_time_adjustment_3gpp_validate (buffer, buffer_len)) {
                self->arg_daylight_saving_time_adjustment_3gpp_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_daylight_saving_time_adjustment_3gpp));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Daylight Saving Time Adjustment 3GPP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_time_zone_3gpp_validate (buffer, buffer_len)) {
                self->arg_time_zone_3gpp_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_time_zone_3gpp));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Time Zone 3GPP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_PLMN_NAME_FLAG_3GPP,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_plmn_name_flag_3gpp_validate (buffer, buffer_len)) {
                self->arg_plmn_name_flag_3gpp_set = TRUE;

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_plmn_name_flag_3gpp = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PLMN Name Flag 3GPP' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_P_REV,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_cdma_p_rev_validate (buffer, buffer_len)) {
                self->arg_cdma_p_rev_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_p_rev));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA P Rev' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_TIME_ZONE_3GPP2,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_time_zone_3gpp2_validate (buffer, buffer_len)) {
                self->arg_time_zone_3gpp2_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_time_zone_3gpp2_leap_seconds));
                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_time_zone_3gpp2_local_time_offset));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_time_zone_3gpp2_daylight_saving_time = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Time Zone 3GPP2' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DEFAULT_ROAMING_INDICATOR,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_default_roaming_indicator_validate (buffer, buffer_len)) {
                self->arg_default_roaming_indicator_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_default_roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Default Roaming Indicator' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR_LIST,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_roaming_indicator_list_validate (buffer, buffer_len)) {
                self->arg_roaming_indicator_list_set = TRUE;

                {
                    guint roaming_indicator_list_i;
                    guint8 roaming_indicator_list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(roaming_indicator_list_n_items));

                    self->arg_roaming_indicator_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiIndicationNasServingSystemOutputRoamingIndicatorListElement),
                        (guint)roaming_indicator_list_n_items);

                    for (roaming_indicator_list_i = 0; roaming_indicator_list_i < roaming_indicator_list_n_items; roaming_indicator_list_i++) {
                        QmiIndicationNasServingSystemOutputRoamingIndicatorListElement roaming_indicator_list_aux;

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            roaming_indicator_list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                        }
                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            roaming_indicator_list_aux.roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
                        }
                        g_array_insert_val (self->arg_roaming_indicator_list, roaming_indicator_list_i, roaming_indicator_list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Roaming Indicator List' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_BASE_STATION_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_cdma_base_station_info_validate (buffer, buffer_len)) {
                self->arg_cdma_base_station_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_base_station_info_base_station_id));
                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_base_station_info_base_station_latitude));
                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_base_station_info_base_station_longitude));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA Base Station Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CDMA_SYSTEM_ID,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_cdma_system_id_validate (buffer, buffer_len)) {
                self->arg_cdma_system_id_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_id_sid));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_id_nid));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA System ID' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_CURRENT_PLMN,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_current_plmn_validate (buffer, buffer_len)) {
                self->arg_current_plmn_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_current_plmn_mcc));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_current_plmn_mnc));
                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    8,
                    0,
                    &(self->arg_current_plmn_description));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Current PLMN' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_DATA_SERVICE_CAPABILITY,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_data_service_capability_validate (buffer, buffer_len)) {
                self->arg_data_service_capability_set = TRUE;

                {
                    guint data_service_capability_i;
                    guint8 data_service_capability_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(data_service_capability_n_items));

                    self->arg_data_service_capability = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiNasDataCapability),
                        (guint)data_service_capability_n_items);

                    for (data_service_capability_i = 0; data_service_capability_i < data_service_capability_n_items; data_service_capability_i++) {
                        QmiNasDataCapability data_service_capability_aux;

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            data_service_capability_aux = (QmiNasDataCapability)tmp;
                        }
                        g_array_insert_val (self->arg_data_service_capability, data_service_capability_i, data_service_capability_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Data Service Capability' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_ROAMING_INDICATOR,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_roaming_indicator_validate (buffer, buffer_len)) {
                self->arg_roaming_indicator_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_roaming_indicator = (QmiNasRoamingIndicatorStatus)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Roaming Indicator' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SERVING_SYSTEM_OUTPUT_TLV_SERVING_SYSTEM,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_serving_system_output_serving_system_validate (buffer, buffer_len)) {
                self->arg_serving_system_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_serving_system_registration_state = (QmiNasRegistrationState)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_serving_system_cs_attach_state = (QmiNasAttachState)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_serving_system_ps_attach_state = (QmiNasAttachState)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_serving_system_selected_network = (QmiNasNetworkType)tmp;
                }
                {
                    guint radio_interfaces_i;
                    guint8 radio_interfaces_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(radio_interfaces_n_items));

                    self->arg_serving_system_radio_interfaces = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiNasRadioInterface),
                        (guint)radio_interfaces_n_items);

                    for (radio_interfaces_i = 0; radio_interfaces_i < radio_interfaces_n_items; radio_interfaces_i++) {
                        QmiNasRadioInterface radio_interfaces_aux;

                        {
                            gint8 tmp;

                            /* Read the gint8 variable from the buffer */
                            qmi_utils_read_gint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            radio_interfaces_aux = (QmiNasRadioInterface)tmp;
                        }
                        g_array_insert_val (self->arg_serving_system_radio_interfaces, radio_interfaces_i, radio_interfaces_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Serving System' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Serving System TLV: Not found");
                qmi_indication_nas_serving_system_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Home Network */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_home_network_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_HOME_NETWORK);

    return self;
}

/* --- Output -- */

struct _QmiMessageNasGetHomeNetworkOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Home Network 3GPP2 */
    gboolean arg_home_network_3gpp2_set;
    guint16 arg_home_network_3gpp2_mcc;
    guint16 arg_home_network_3gpp2_mnc;
    guint8 arg_home_network_3gpp2_display_description;
    guint8 arg_home_network_3gpp2_description_encoding;
    gchar *arg_home_network_3gpp2_description;

    /* Home System ID */
    gboolean arg_home_system_id_set;
    guint16 arg_home_system_id_sid;
    guint16 arg_home_system_id_nid;

    /* Home Network */
    gboolean arg_home_network_set;
    guint16 arg_home_network_mcc;
    guint16 arg_home_network_mnc;
    gchar *arg_home_network_description;
};

#define QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP2 0x11
#define QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_SYSTEM_ID 0x10
#define QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK 0x01

/**
 * qmi_message_nas_get_home_network_output_get_result:
 * @self: a QmiMessageNasGetHomeNetworkOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_get_home_network_output_get_result (
    QmiMessageNasGetHomeNetworkOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_nas_get_home_network_output_get_home_network_3gpp2:
 * @self: a #QmiMessageNasGetHomeNetworkOutput.
 * @home_network_3gpp2_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @home_network_3gpp2_mnc: a placeholder for the output #guint16, or %NULL if not required.
 * @home_network_3gpp2_display_description: a placeholder for the output #QmiNasNetworkDescriptionDisplay, or %NULL if not required.
 * @home_network_3gpp2_description_encoding: a placeholder for the output #QmiNasNetworkDescriptionEncoding, or %NULL if not required.
 * @home_network_3gpp2_description: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Home Network 3GPP2' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_home_network_output_get_home_network_3gpp2 (
    QmiMessageNasGetHomeNetworkOutput *self,
    guint16 *home_network_3gpp2_mcc,
    guint16 *home_network_3gpp2_mnc,
    QmiNasNetworkDescriptionDisplay *home_network_3gpp2_display_description,
    QmiNasNetworkDescriptionEncoding *home_network_3gpp2_description_encoding,
    const gchar **home_network_3gpp2_description,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_home_network_3gpp2_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Home Network 3GPP2' was not found in the message");
        return FALSE;
    }

    if (home_network_3gpp2_mcc)
        *home_network_3gpp2_mcc = self->arg_home_network_3gpp2_mcc;
    if (home_network_3gpp2_mnc)
        *home_network_3gpp2_mnc = self->arg_home_network_3gpp2_mnc;
    if (home_network_3gpp2_display_description)
        *home_network_3gpp2_display_description = (QmiNasNetworkDescriptionDisplay)(self->arg_home_network_3gpp2_display_description);
    if (home_network_3gpp2_description_encoding)
        *home_network_3gpp2_description_encoding = (QmiNasNetworkDescriptionEncoding)(self->arg_home_network_3gpp2_description_encoding);
    if (home_network_3gpp2_description)
        *home_network_3gpp2_description = self->arg_home_network_3gpp2_description;

    return TRUE;
}

/**
 * qmi_message_nas_get_home_network_output_get_home_system_id:
 * @self: a #QmiMessageNasGetHomeNetworkOutput.
 * @home_system_id_sid: a placeholder for the output #guint16, or %NULL if not required.
 * @home_system_id_nid: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Home System ID' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_home_network_output_get_home_system_id (
    QmiMessageNasGetHomeNetworkOutput *self,
    guint16 *home_system_id_sid,
    guint16 *home_system_id_nid,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_home_system_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Home System ID' was not found in the message");
        return FALSE;
    }

    if (home_system_id_sid)
        *home_system_id_sid = self->arg_home_system_id_sid;
    if (home_system_id_nid)
        *home_system_id_nid = self->arg_home_system_id_nid;

    return TRUE;
}

/**
 * qmi_message_nas_get_home_network_output_get_home_network:
 * @self: a #QmiMessageNasGetHomeNetworkOutput.
 * @home_network_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @home_network_mnc: a placeholder for the output #guint16, or %NULL if not required.
 * @home_network_description: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Home Network' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_home_network_output_get_home_network (
    QmiMessageNasGetHomeNetworkOutput *self,
    guint16 *home_network_mcc,
    guint16 *home_network_mnc,
    const gchar **home_network_description,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_home_network_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Home Network' was not found in the message");
        return FALSE;
    }

    if (home_network_mcc)
        *home_network_mcc = self->arg_home_network_mcc;
    if (home_network_mnc)
        *home_network_mnc = self->arg_home_network_mnc;
    if (home_network_description)
        *home_network_description = self->arg_home_network_description;

    return TRUE;
}

GType
qmi_message_nas_get_home_network_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetHomeNetworkOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_home_network_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_home_network_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_get_home_network_output_ref:
 * @self: a #QmiMessageNasGetHomeNetworkOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasGetHomeNetworkOutput *
qmi_message_nas_get_home_network_output_ref (QmiMessageNasGetHomeNetworkOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_get_home_network_output_unref:
 * @self: a #QmiMessageNasGetHomeNetworkOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_get_home_network_output_unref (QmiMessageNasGetHomeNetworkOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_home_network_3gpp2_description);
        g_free (self->arg_home_network_description);
        g_slice_free (QmiMessageNasGetHomeNetworkOutput, self);
    }
}

static gboolean
qmi_message_nas_get_home_network_output_home_network_3gpp2_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;
    expected_len += 1;
    expected_len += 1;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Home Network 3GPP2' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Home Network 3GPP2' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_home_network_output_home_network_3gpp2_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP2,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_home_network_output_home_network_3gpp2_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " display_description = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_description_display_get_string ((QmiNasNetworkDescriptionDisplay)tmp));
#elif defined  __QMI_NAS_NETWORK_DESCRIPTION_DISPLAY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_description_display_build_string_from_mask ((QmiNasNetworkDescriptionDisplay)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkDescriptionDisplay
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " description_encoding = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_description_encoding_get_string ((QmiNasNetworkDescriptionEncoding)tmp));
#elif defined  __QMI_NAS_NETWORK_DESCRIPTION_ENCODING_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_description_encoding_build_string_from_mask ((QmiNasNetworkDescriptionEncoding)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkDescriptionEncoding
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " description = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Home Network 3GPP2' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_home_network_output_home_system_id_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Home System ID' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Home System ID' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_home_network_output_home_system_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_SYSTEM_ID,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_home_network_output_home_system_id_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " sid = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " nid = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Home System ID' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_home_network_output_home_network_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Home Network' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Home Network' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_home_network_output_home_network_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_home_network_output_home_network_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " description = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Home Network' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_home_network_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_home_network_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_home_network_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP2:
            tlv_type_str = "Home Network 3GPP2";
            translated_value = qmi_message_nas_get_home_network_output_home_network_3gpp2_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_SYSTEM_ID:
            tlv_type_str = "Home System ID";
            translated_value = qmi_message_nas_get_home_network_output_home_system_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK:
            tlv_type_str = "Home Network";
            translated_value = qmi_message_nas_get_home_network_output_home_network_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_home_network_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Home Network\" (0x0025)\n",
                            line_prefix);

    {
        struct message_get_home_network_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_home_network_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetHomeNetworkOutput *
__qmi_message_nas_get_home_network_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetHomeNetworkOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_GET_HOME_NETWORK, NULL);

    self = g_slice_new0 (QmiMessageNasGetHomeNetworkOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_get_home_network_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK_3GPP2,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_home_network_output_home_network_3gpp2_validate (buffer, buffer_len)) {
                self->arg_home_network_3gpp2_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_home_network_3gpp2_mcc));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_home_network_3gpp2_mnc));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_home_network_3gpp2_display_description = (QmiNasNetworkDescriptionDisplay)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_home_network_3gpp2_description_encoding = (QmiNasNetworkDescriptionEncoding)tmp;
                }
                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    8,
                    0,
                    &(self->arg_home_network_3gpp2_description));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Home Network 3GPP2' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_SYSTEM_ID,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_home_network_output_home_system_id_validate (buffer, buffer_len)) {
                self->arg_home_system_id_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_home_system_id_sid));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_home_system_id_nid));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Home System ID' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_HOME_NETWORK_OUTPUT_TLV_HOME_NETWORK,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_home_network_output_home_network_validate (buffer, buffer_len)) {
                self->arg_home_network_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_home_network_mcc));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_home_network_mnc));
                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    8,
                    0,
                    &(self->arg_home_network_description));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Home Network' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Home Network TLV: Not found");
                qmi_message_nas_get_home_network_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Set Technology Preference */


/* --- Input -- */

struct _QmiMessageNasSetTechnologyPreferenceInput {
    volatile gint ref_count;

    /* Current */
    gboolean arg_current_set;
    guint16 arg_current_technology_preference;
    guint8 arg_current_technology_preference_duration;
};

#define QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_INPUT_TLV_CURRENT 0x01

/**
 * qmi_message_nas_set_technology_preference_input_get_current:
 * @self: a #QmiMessageNasSetTechnologyPreferenceInput.
 * @current_technology_preference: a placeholder for the output #QmiNasRadioTechnologyPreference, or %NULL if not required.
 * @current_technology_preference_duration: a placeholder for the output #QmiNasPreferenceDuration, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Current' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_technology_preference_input_get_current (
    QmiMessageNasSetTechnologyPreferenceInput *self,
    QmiNasRadioTechnologyPreference *current_technology_preference,
    QmiNasPreferenceDuration *current_technology_preference_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_current_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Current' was not found in the message");
        return FALSE;
    }

    if (current_technology_preference)
        *current_technology_preference = (QmiNasRadioTechnologyPreference)(self->arg_current_technology_preference);
    if (current_technology_preference_duration)
        *current_technology_preference_duration = (QmiNasPreferenceDuration)(self->arg_current_technology_preference_duration);

    return TRUE;
}

/**
 * qmi_message_nas_set_technology_preference_input_set_current:
 * @self: a #QmiMessageNasSetTechnologyPreferenceInput.
 * @current_technology_preference: a #QmiNasRadioTechnologyPreference.
 * @current_technology_preference_duration: a #QmiNasPreferenceDuration.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Current' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_technology_preference_input_set_current (
    QmiMessageNasSetTechnologyPreferenceInput *self,
    QmiNasRadioTechnologyPreference current_technology_preference,
    QmiNasPreferenceDuration current_technology_preference_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_current_technology_preference = (guint16)(current_technology_preference);
    self->arg_current_technology_preference_duration = (guint8)(current_technology_preference_duration);
    self->arg_current_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_set_technology_preference_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetTechnologyPreferenceInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_technology_preference_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_technology_preference_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_set_technology_preference_input_ref:
 * @self: a #QmiMessageNasSetTechnologyPreferenceInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasSetTechnologyPreferenceInput *
qmi_message_nas_set_technology_preference_input_ref (QmiMessageNasSetTechnologyPreferenceInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_set_technology_preference_input_unref:
 * @self: a #QmiMessageNasSetTechnologyPreferenceInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_set_technology_preference_input_unref (QmiMessageNasSetTechnologyPreferenceInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSetTechnologyPreferenceInput, self);
    }
}

/**
 * qmi_message_nas_set_technology_preference_input_new:
 *
 * Allocates a new #QmiMessageNasSetTechnologyPreferenceInput.
 *
 * Returns: the newly created #QmiMessageNasSetTechnologyPreferenceInput. The returned value should be freed with qmi_message_nas_set_technology_preference_input_unref().
 */
QmiMessageNasSetTechnologyPreferenceInput *
qmi_message_nas_set_technology_preference_input_new (void)
{
    QmiMessageNasSetTechnologyPreferenceInput *self;

    self = g_slice_new0 (QmiMessageNasSetTechnologyPreferenceInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_set_technology_preference_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageNasSetTechnologyPreferenceInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Set Technology Preference' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Current' TLV */
    if (input->arg_current_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint16 tmp;

            tmp = (guint16)input->arg_current_technology_preference;
            /* Write the guint16 variable to the buffer */
            qmi_utils_write_guint16_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }
        {
            guint8 tmp;

            tmp = (guint8)input->arg_current_technology_preference_duration;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_INPUT_TLV_CURRENT,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Current TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Current' in message 'Set Technology Preference'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageNasSetTechnologyPreferenceOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_nas_set_technology_preference_output_get_result:
 * @self: a QmiMessageNasSetTechnologyPreferenceOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_set_technology_preference_output_get_result (
    QmiMessageNasSetTechnologyPreferenceOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_set_technology_preference_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetTechnologyPreferenceOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_technology_preference_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_technology_preference_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_set_technology_preference_output_ref:
 * @self: a #QmiMessageNasSetTechnologyPreferenceOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasSetTechnologyPreferenceOutput *
qmi_message_nas_set_technology_preference_output_ref (QmiMessageNasSetTechnologyPreferenceOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_set_technology_preference_output_unref:
 * @self: a #QmiMessageNasSetTechnologyPreferenceOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_set_technology_preference_output_unref (QmiMessageNasSetTechnologyPreferenceOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSetTechnologyPreferenceOutput, self);
    }
}

static gboolean
qmi_message_nas_set_technology_preference_input_current_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Current' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Current' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_technology_preference_input_current_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_INPUT_TLV_CURRENT,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_technology_preference_input_current_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " technology_preference = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_technology_preference_get_string ((QmiNasRadioTechnologyPreference)tmp));
#elif defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_technology_preference_build_string_from_mask ((QmiNasRadioTechnologyPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioTechnologyPreference
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " technology_preference_duration = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_PREFERENCE_DURATION_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_preference_duration_get_string ((QmiNasPreferenceDuration)tmp));
#elif defined  __QMI_NAS_PREFERENCE_DURATION_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_preference_duration_build_string_from_mask ((QmiNasPreferenceDuration)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasPreferenceDuration
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Current' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_technology_preference_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_technology_preference_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_technology_preference_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_INPUT_TLV_CURRENT:
            tlv_type_str = "Current";
            translated_value = qmi_message_nas_set_technology_preference_input_current_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_technology_preference_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Technology Preference\" (0x002A)\n",
                            line_prefix);

    {
        struct message_set_technology_preference_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_technology_preference_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasSetTechnologyPreferenceOutput *
__qmi_message_nas_set_technology_preference_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasSetTechnologyPreferenceOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE, NULL);

    self = g_slice_new0 (QmiMessageNasSetTechnologyPreferenceOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_set_technology_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Technology Preference */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_technology_preference_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE);

    return self;
}

/* --- Output -- */

struct _QmiMessageNasGetTechnologyPreferenceOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Persistent */
    gboolean arg_persistent_set;
    guint16 arg_persistent;

    /* Active */
    gboolean arg_active_set;
    guint16 arg_active_technology_preference;
    guint8 arg_active_technology_preference_duration;
};

#define QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_PERSISTENT 0x10
#define QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_ACTIVE 0x01

/**
 * qmi_message_nas_get_technology_preference_output_get_result:
 * @self: a QmiMessageNasGetTechnologyPreferenceOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_get_technology_preference_output_get_result (
    QmiMessageNasGetTechnologyPreferenceOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_nas_get_technology_preference_output_get_persistent:
 * @self: a #QmiMessageNasGetTechnologyPreferenceOutput.
 * @persistent: a placeholder for the output #QmiNasRadioTechnologyPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Persistent' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_technology_preference_output_get_persistent (
    QmiMessageNasGetTechnologyPreferenceOutput *self,
    QmiNasRadioTechnologyPreference *persistent,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_persistent_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Persistent' was not found in the message");
        return FALSE;
    }

    if (persistent)
        *persistent = (QmiNasRadioTechnologyPreference)(self->arg_persistent);

    return TRUE;
}

/**
 * qmi_message_nas_get_technology_preference_output_get_active:
 * @self: a #QmiMessageNasGetTechnologyPreferenceOutput.
 * @active_technology_preference: a placeholder for the output #QmiNasRadioTechnologyPreference, or %NULL if not required.
 * @active_technology_preference_duration: a placeholder for the output #QmiNasPreferenceDuration, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Active' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_technology_preference_output_get_active (
    QmiMessageNasGetTechnologyPreferenceOutput *self,
    QmiNasRadioTechnologyPreference *active_technology_preference,
    QmiNasPreferenceDuration *active_technology_preference_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_active_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Active' was not found in the message");
        return FALSE;
    }

    if (active_technology_preference)
        *active_technology_preference = (QmiNasRadioTechnologyPreference)(self->arg_active_technology_preference);
    if (active_technology_preference_duration)
        *active_technology_preference_duration = (QmiNasPreferenceDuration)(self->arg_active_technology_preference_duration);

    return TRUE;
}

GType
qmi_message_nas_get_technology_preference_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetTechnologyPreferenceOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_technology_preference_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_technology_preference_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_get_technology_preference_output_ref:
 * @self: a #QmiMessageNasGetTechnologyPreferenceOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasGetTechnologyPreferenceOutput *
qmi_message_nas_get_technology_preference_output_ref (QmiMessageNasGetTechnologyPreferenceOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_get_technology_preference_output_unref:
 * @self: a #QmiMessageNasGetTechnologyPreferenceOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_get_technology_preference_output_unref (QmiMessageNasGetTechnologyPreferenceOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetTechnologyPreferenceOutput, self);
    }
}

static gboolean
qmi_message_nas_get_technology_preference_output_persistent_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Persistent' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Persistent' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_technology_preference_output_persistent_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_PERSISTENT,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_technology_preference_output_persistent_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_technology_preference_get_string ((QmiNasRadioTechnologyPreference)tmp));
#elif defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_technology_preference_build_string_from_mask ((QmiNasRadioTechnologyPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioTechnologyPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Persistent' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_technology_preference_output_active_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Active' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Active' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_technology_preference_output_active_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_ACTIVE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_technology_preference_output_active_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " technology_preference = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_technology_preference_get_string ((QmiNasRadioTechnologyPreference)tmp));
#elif defined  __QMI_NAS_RADIO_TECHNOLOGY_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_technology_preference_build_string_from_mask ((QmiNasRadioTechnologyPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioTechnologyPreference
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " technology_preference_duration = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_PREFERENCE_DURATION_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_preference_duration_get_string ((QmiNasPreferenceDuration)tmp));
#elif defined  __QMI_NAS_PREFERENCE_DURATION_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_preference_duration_build_string_from_mask ((QmiNasPreferenceDuration)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasPreferenceDuration
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Active' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_technology_preference_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_technology_preference_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_technology_preference_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_PERSISTENT:
            tlv_type_str = "Persistent";
            translated_value = qmi_message_nas_get_technology_preference_output_persistent_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_ACTIVE:
            tlv_type_str = "Active";
            translated_value = qmi_message_nas_get_technology_preference_output_active_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_technology_preference_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Technology Preference\" (0x002B)\n",
                            line_prefix);

    {
        struct message_get_technology_preference_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_technology_preference_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetTechnologyPreferenceOutput *
__qmi_message_nas_get_technology_preference_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetTechnologyPreferenceOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE, NULL);

    self = g_slice_new0 (QmiMessageNasGetTechnologyPreferenceOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_get_technology_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_PERSISTENT,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_technology_preference_output_persistent_validate (buffer, buffer_len)) {
                self->arg_persistent_set = TRUE;

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_persistent = (QmiNasRadioTechnologyPreference)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Persistent' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE_OUTPUT_TLV_ACTIVE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_technology_preference_output_active_validate (buffer, buffer_len)) {
                self->arg_active_set = TRUE;

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_active_technology_preference = (QmiNasRadioTechnologyPreference)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_active_technology_preference_duration = (QmiNasPreferenceDuration)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Active' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Active TLV: Not found");
                qmi_message_nas_get_technology_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get RF Band Information */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_rf_band_information_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION);

    return self;
}

/* --- Output -- */

struct _QmiMessageNasGetRfBandInformationOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* List */
    gboolean arg_list_set;
    GArray *arg_list;
};

#define QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_LIST 0x11

/**
 * qmi_message_nas_get_rf_band_information_output_get_result:
 * @self: a QmiMessageNasGetRfBandInformationOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_get_rf_band_information_output_get_result (
    QmiMessageNasGetRfBandInformationOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_nas_get_rf_band_information_output_get_list:
 * @self: a #QmiMessageNasGetRfBandInformationOutput.
 * @list: a placeholder for the output #GArray of #QmiMessageNasGetRfBandInformationOutputListElement elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_rf_band_information_output_get_list (
    QmiMessageNasGetRfBandInformationOutput *self,
    GArray **list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'List' was not found in the message");
        return FALSE;
    }

    if (list)
        *list = self->arg_list;

    return TRUE;
}

GType
qmi_message_nas_get_rf_band_information_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetRfBandInformationOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_rf_band_information_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_rf_band_information_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_get_rf_band_information_output_ref:
 * @self: a #QmiMessageNasGetRfBandInformationOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasGetRfBandInformationOutput *
qmi_message_nas_get_rf_band_information_output_ref (QmiMessageNasGetRfBandInformationOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_get_rf_band_information_output_unref:
 * @self: a #QmiMessageNasGetRfBandInformationOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_get_rf_band_information_output_unref (QmiMessageNasGetRfBandInformationOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_list)
            g_array_unref (self->arg_list);
        g_slice_free (QmiMessageNasGetRfBandInformationOutput, self);
    }
}

static gboolean
qmi_message_nas_get_rf_band_information_output_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint list_i;
        guint8 list_n_items;
        const guint8 *list_aux_buffer = &buffer[expected_len];
        guint16 list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &list_aux_buffer,
            &list_aux_buffer_len,
            &(list_n_items));
        for (list_i = 0; list_i < list_n_items; list_i++) {

            expected_len += 1;
            expected_len += 2;
            expected_len += 2;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_rf_band_information_output_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_LIST,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_rf_band_information_output_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint list_i;
            guint8 list_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(list_n_items));

            g_string_append (printable, "{");

            for (list_i = 0; list_i < list_n_items; list_i++) {
                g_string_append_printf (printable, " [%u] = '", list_i);
                g_string_append (printable, "[");
                g_string_append (printable, " radio_interface = '");

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " active_band_class = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

#if defined  __QMI_NAS_ACTIVE_BAND_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_active_band_get_string ((QmiNasActiveBand)tmp));
#elif defined  __QMI_NAS_ACTIVE_BAND_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_active_band_build_string_from_mask ((QmiNasActiveBand)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasActiveBand
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " active_channel = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_rf_band_information_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_rf_band_information_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_rf_band_information_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_LIST:
            tlv_type_str = "List";
            translated_value = qmi_message_nas_get_rf_band_information_output_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_rf_band_information_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get RF Band Information\" (0x0031)\n",
                            line_prefix);

    {
        struct message_get_rf_band_information_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_rf_band_information_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetRfBandInformationOutput *
__qmi_message_nas_get_rf_band_information_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetRfBandInformationOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION, NULL);

    self = g_slice_new0 (QmiMessageNasGetRfBandInformationOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_get_rf_band_information_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION_OUTPUT_TLV_LIST,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_rf_band_information_output_list_validate (buffer, buffer_len)) {
                self->arg_list_set = TRUE;

                {
                    guint list_i;
                    guint8 list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(list_n_items));

                    self->arg_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageNasGetRfBandInformationOutputListElement),
                        (guint)list_n_items);

                    for (list_i = 0; list_i < list_n_items; list_i++) {
                        QmiMessageNasGetRfBandInformationOutputListElement list_aux;

                        {
                            gint8 tmp;

                            /* Read the gint8 variable from the buffer */
                            qmi_utils_read_gint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            list_aux.radio_interface = (QmiNasRadioInterface)tmp;
                        }
                        {
                            guint16 tmp;

                            /* Read the guint16 variable from the buffer */
                            qmi_utils_read_guint16_from_buffer (
                                &buffer,
                                &buffer_len,
                                QMI_ENDIAN_LITTLE,
                                &tmp);
                            list_aux.active_band_class = (QmiNasActiveBand)tmp;
                        }
                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(list_aux.active_channel));
                        g_array_insert_val (self->arg_list, list_i, list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'List' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Set System Selection Preference */


/* --- Input -- */

struct _QmiMessageNasSetSystemSelectionPreferenceInput {
    volatile gint ref_count;

    /* TD SCDMA Band Preference */
    gboolean arg_td_scdma_band_preference_set;
    guint64 arg_td_scdma_band_preference;

    /* MNC PDS Digit Include Status */
    gboolean arg_mnc_pds_digit_include_status_set;
    guint8 arg_mnc_pds_digit_include_status;

    /* GSM WCDMA Acquisition Order Preference */
    gboolean arg_gsm_wcdma_acquisition_order_preference_set;
    guint32 arg_gsm_wcdma_acquisition_order_preference;

    /* Service Domain Preference */
    gboolean arg_service_domain_preference_set;
    guint32 arg_service_domain_preference;

    /* Change Duration */
    gboolean arg_change_duration_set;
    guint8 arg_change_duration;

    /* Network Selection Preference */
    gboolean arg_network_selection_preference_set;
    guint8 arg_network_selection_preference_mode;
    guint16 arg_network_selection_preference_mcc;
    guint16 arg_network_selection_preference_mnc;

    /* LTE Band Preference */
    gboolean arg_lte_band_preference_set;
    guint64 arg_lte_band_preference;

    /* Roaming Preference */
    gboolean arg_roaming_preference_set;
    guint16 arg_roaming_preference;

    /* CDMA PRL Preference */
    gboolean arg_cdma_prl_preference_set;
    guint16 arg_cdma_prl_preference;

    /* Band Preference */
    gboolean arg_band_preference_set;
    guint64 arg_band_preference;

    /* Mode Preference */
    gboolean arg_mode_preference_set;
    guint16 arg_mode_preference;

    /* Emergency mode */
    gboolean arg_emergency_mode_set;
    guint8 arg_emergency_mode;
};

#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_TD_SCDMA_BAND_PREFERENCE 0x1D
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MNC_PDS_DIGIT_INCLUDE_STATUS 0x1A
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE 0x19
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_SERVICE_DOMAIN_PREFERENCE 0x18
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CHANGE_DURATION 0x17
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_PREFERENCE 0x16
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_LTE_BAND_PREFERENCE 0x15
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ROAMING_PREFERENCE 0x14
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CDMA_PRL_PREFERENCE 0x13
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_BAND_PREFERENCE 0x12
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MODE_PREFERENCE 0x11
#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EMERGENCY_MODE 0x10

/**
 * qmi_message_nas_set_system_selection_preference_input_get_td_scdma_band_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @td_scdma_band_preference: a placeholder for the output #QmiNasTdScdmaBandPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'TD SCDMA Band Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_td_scdma_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasTdScdmaBandPreference *td_scdma_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scdma_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCDMA Band Preference' was not found in the message");
        return FALSE;
    }

    if (td_scdma_band_preference)
        *td_scdma_band_preference = (QmiNasTdScdmaBandPreference)(self->arg_td_scdma_band_preference);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_td_scdma_band_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @td_scdma_band_preference: a #QmiNasTdScdmaBandPreference.
 * @error: Return location for error or %NULL.
 *
 * Set the 'TD SCDMA Band Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_td_scdma_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasTdScdmaBandPreference td_scdma_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_td_scdma_band_preference = (guint64)(td_scdma_band_preference);
    self->arg_td_scdma_band_preference_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_mnc_pds_digit_include_status:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @mnc_pds_digit_include_status: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'MNC PDS Digit Include Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_mnc_pds_digit_include_status (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    gboolean *mnc_pds_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mnc_pds_digit_include_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MNC PDS Digit Include Status' was not found in the message");
        return FALSE;
    }

    if (mnc_pds_digit_include_status)
        *mnc_pds_digit_include_status = (gboolean)(self->arg_mnc_pds_digit_include_status);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_mnc_pds_digit_include_status:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @mnc_pds_digit_include_status: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'MNC PDS Digit Include Status' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_mnc_pds_digit_include_status (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    gboolean mnc_pds_digit_include_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_mnc_pds_digit_include_status = (guint8)(mnc_pds_digit_include_status);
    self->arg_mnc_pds_digit_include_status_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_gsm_wcdma_acquisition_order_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @gsm_wcdma_acquisition_order_preference: a placeholder for the output #QmiNasGsmWcdmaAcquisitionOrderPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM WCDMA Acquisition Order Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_gsm_wcdma_acquisition_order_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasGsmWcdmaAcquisitionOrderPreference *gsm_wcdma_acquisition_order_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_wcdma_acquisition_order_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM WCDMA Acquisition Order Preference' was not found in the message");
        return FALSE;
    }

    if (gsm_wcdma_acquisition_order_preference)
        *gsm_wcdma_acquisition_order_preference = (QmiNasGsmWcdmaAcquisitionOrderPreference)(self->arg_gsm_wcdma_acquisition_order_preference);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_gsm_wcdma_acquisition_order_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @gsm_wcdma_acquisition_order_preference: a #QmiNasGsmWcdmaAcquisitionOrderPreference.
 * @error: Return location for error or %NULL.
 *
 * Set the 'GSM WCDMA Acquisition Order Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_gsm_wcdma_acquisition_order_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasGsmWcdmaAcquisitionOrderPreference gsm_wcdma_acquisition_order_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_gsm_wcdma_acquisition_order_preference = (guint32)(gsm_wcdma_acquisition_order_preference);
    self->arg_gsm_wcdma_acquisition_order_preference_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_service_domain_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @service_domain_preference: a placeholder for the output #QmiNasServiceDomainPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Service Domain Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_service_domain_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasServiceDomainPreference *service_domain_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_service_domain_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Service Domain Preference' was not found in the message");
        return FALSE;
    }

    if (service_domain_preference)
        *service_domain_preference = (QmiNasServiceDomainPreference)(self->arg_service_domain_preference);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_service_domain_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @service_domain_preference: a #QmiNasServiceDomainPreference.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Service Domain Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_service_domain_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasServiceDomainPreference service_domain_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_service_domain_preference = (guint32)(service_domain_preference);
    self->arg_service_domain_preference_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_change_duration:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @change_duration: a placeholder for the output #QmiNasChangeDuration, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Change Duration' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_change_duration (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasChangeDuration *change_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_change_duration_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Change Duration' was not found in the message");
        return FALSE;
    }

    if (change_duration)
        *change_duration = (QmiNasChangeDuration)(self->arg_change_duration);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_change_duration:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @change_duration: a #QmiNasChangeDuration.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Change Duration' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_change_duration (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasChangeDuration change_duration,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_change_duration = (guint8)(change_duration);
    self->arg_change_duration_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_network_selection_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @network_selection_preference_mode: a placeholder for the output #QmiNasNetworkSelectionPreference, or %NULL if not required.
 * @network_selection_preference_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @network_selection_preference_mnc: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Network Selection Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_network_selection_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasNetworkSelectionPreference *network_selection_preference_mode,
    guint16 *network_selection_preference_mcc,
    guint16 *network_selection_preference_mnc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_selection_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Selection Preference' was not found in the message");
        return FALSE;
    }

    if (network_selection_preference_mode)
        *network_selection_preference_mode = (QmiNasNetworkSelectionPreference)(self->arg_network_selection_preference_mode);
    if (network_selection_preference_mcc)
        *network_selection_preference_mcc = self->arg_network_selection_preference_mcc;
    if (network_selection_preference_mnc)
        *network_selection_preference_mnc = self->arg_network_selection_preference_mnc;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_network_selection_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @network_selection_preference_mode: a #QmiNasNetworkSelectionPreference.
 * @network_selection_preference_mcc: a #guint16.
 * @network_selection_preference_mnc: a #guint16.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Network Selection Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_network_selection_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasNetworkSelectionPreference network_selection_preference_mode,
    guint16 network_selection_preference_mcc,
    guint16 network_selection_preference_mnc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_network_selection_preference_mode = (guint8)(network_selection_preference_mode);
    self->arg_network_selection_preference_mcc = network_selection_preference_mcc;
    self->arg_network_selection_preference_mnc = network_selection_preference_mnc;
    self->arg_network_selection_preference_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_lte_band_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @lte_band_preference: a placeholder for the output #QmiNasLteBandPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE Band Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_lte_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasLteBandPreference *lte_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Band Preference' was not found in the message");
        return FALSE;
    }

    if (lte_band_preference)
        *lte_band_preference = (QmiNasLteBandPreference)(self->arg_lte_band_preference);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_lte_band_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @lte_band_preference: a #QmiNasLteBandPreference.
 * @error: Return location for error or %NULL.
 *
 * Set the 'LTE Band Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_lte_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasLteBandPreference lte_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_lte_band_preference = (guint64)(lte_band_preference);
    self->arg_lte_band_preference_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_roaming_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @roaming_preference: a placeholder for the output #QmiNasRoamingPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Roaming Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_roaming_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasRoamingPreference *roaming_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Preference' was not found in the message");
        return FALSE;
    }

    if (roaming_preference)
        *roaming_preference = (QmiNasRoamingPreference)(self->arg_roaming_preference);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_roaming_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @roaming_preference: a #QmiNasRoamingPreference.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Roaming Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_roaming_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasRoamingPreference roaming_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_roaming_preference = (guint16)(roaming_preference);
    self->arg_roaming_preference_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_cdma_prl_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @cdma_prl_preference: a placeholder for the output #QmiNasCdmaPrlPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA PRL Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_cdma_prl_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasCdmaPrlPreference *cdma_prl_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_prl_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA PRL Preference' was not found in the message");
        return FALSE;
    }

    if (cdma_prl_preference)
        *cdma_prl_preference = (QmiNasCdmaPrlPreference)(self->arg_cdma_prl_preference);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_cdma_prl_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @cdma_prl_preference: a #QmiNasCdmaPrlPreference.
 * @error: Return location for error or %NULL.
 *
 * Set the 'CDMA PRL Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_cdma_prl_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasCdmaPrlPreference cdma_prl_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_cdma_prl_preference = (guint16)(cdma_prl_preference);
    self->arg_cdma_prl_preference_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_band_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @band_preference: a placeholder for the output #QmiNasBandPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Band Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasBandPreference *band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Band Preference' was not found in the message");
        return FALSE;
    }

    if (band_preference)
        *band_preference = (QmiNasBandPreference)(self->arg_band_preference);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_band_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @band_preference: a #QmiNasBandPreference.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Band Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_band_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasBandPreference band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_band_preference = (guint64)(band_preference);
    self->arg_band_preference_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_mode_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @mode_preference: a placeholder for the output #QmiNasRatModePreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Mode Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_mode_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasRatModePreference *mode_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mode_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Mode Preference' was not found in the message");
        return FALSE;
    }

    if (mode_preference)
        *mode_preference = (QmiNasRatModePreference)(self->arg_mode_preference);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_mode_preference:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @mode_preference: a #QmiNasRatModePreference.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Mode Preference' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_mode_preference (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    QmiNasRatModePreference mode_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_mode_preference = (guint16)(mode_preference);
    self->arg_mode_preference_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_get_emergency_mode:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @emergency_mode: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Emergency mode' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_get_emergency_mode (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    gboolean *emergency_mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_emergency_mode_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Emergency mode' was not found in the message");
        return FALSE;
    }

    if (emergency_mode)
        *emergency_mode = (gboolean)(self->arg_emergency_mode);

    return TRUE;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_set_emergency_mode:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @emergency_mode: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Emergency mode' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_set_system_selection_preference_input_set_emergency_mode (
    QmiMessageNasSetSystemSelectionPreferenceInput *self,
    gboolean emergency_mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_emergency_mode = (guint8)(emergency_mode);
    self->arg_emergency_mode_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_set_system_selection_preference_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetSystemSelectionPreferenceInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_system_selection_preference_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_system_selection_preference_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_ref:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasSetSystemSelectionPreferenceInput *
qmi_message_nas_set_system_selection_preference_input_ref (QmiMessageNasSetSystemSelectionPreferenceInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_set_system_selection_preference_input_unref:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_set_system_selection_preference_input_unref (QmiMessageNasSetSystemSelectionPreferenceInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSetSystemSelectionPreferenceInput, self);
    }
}

/**
 * qmi_message_nas_set_system_selection_preference_input_new:
 *
 * Allocates a new #QmiMessageNasSetSystemSelectionPreferenceInput.
 *
 * Returns: the newly created #QmiMessageNasSetSystemSelectionPreferenceInput. The returned value should be freed with qmi_message_nas_set_system_selection_preference_input_unref().
 */
QmiMessageNasSetSystemSelectionPreferenceInput *
qmi_message_nas_set_system_selection_preference_input_new (void)
{
    QmiMessageNasSetSystemSelectionPreferenceInput *self;

    self = g_slice_new0 (QmiMessageNasSetSystemSelectionPreferenceInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_set_system_selection_preference_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageNasSetSystemSelectionPreferenceInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return self;

    /* Try to add the 'TD SCDMA Band Preference' TLV */
    if (input->arg_td_scdma_band_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint64 tmp;

            tmp = (guint64)input->arg_td_scdma_band_preference;
            /* Write the guint64 variable to the buffer */
            qmi_utils_write_guint64_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_TD_SCDMA_BAND_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the TD SCDMA Band Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'MNC PDS Digit Include Status' TLV */
    if (input->arg_mnc_pds_digit_include_status_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_mnc_pds_digit_include_status;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MNC_PDS_DIGIT_INCLUDE_STATUS,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the MNC PDS Digit Include Status TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'GSM WCDMA Acquisition Order Preference' TLV */
    if (input->arg_gsm_wcdma_acquisition_order_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint32 tmp;

            tmp = (guint32)input->arg_gsm_wcdma_acquisition_order_preference;
            /* Write the guint32 variable to the buffer */
            qmi_utils_write_guint32_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the GSM WCDMA Acquisition Order Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Service Domain Preference' TLV */
    if (input->arg_service_domain_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint32 tmp;

            tmp = (guint32)input->arg_service_domain_preference;
            /* Write the guint32 variable to the buffer */
            qmi_utils_write_guint32_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_SERVICE_DOMAIN_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Service Domain Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Change Duration' TLV */
    if (input->arg_change_duration_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_change_duration;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CHANGE_DURATION,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Change Duration TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Network Selection Preference' TLV */
    if (input->arg_network_selection_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_network_selection_preference_mode;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the guint16 variable to the buffer */
        qmi_utils_write_guint16_to_buffer (
            &buffer_aux,
            &buffer_len,
            QMI_ENDIAN_LITTLE,
            &(input->arg_network_selection_preference_mcc));
        /* Write the guint16 variable to the buffer */
        qmi_utils_write_guint16_to_buffer (
            &buffer_aux,
            &buffer_len,
            QMI_ENDIAN_LITTLE,
            &(input->arg_network_selection_preference_mnc));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Network Selection Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'LTE Band Preference' TLV */
    if (input->arg_lte_band_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint64 tmp;

            tmp = (guint64)input->arg_lte_band_preference;
            /* Write the guint64 variable to the buffer */
            qmi_utils_write_guint64_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_LTE_BAND_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the LTE Band Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Roaming Preference' TLV */
    if (input->arg_roaming_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint16 tmp;

            tmp = (guint16)input->arg_roaming_preference;
            /* Write the guint16 variable to the buffer */
            qmi_utils_write_guint16_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ROAMING_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Roaming Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'CDMA PRL Preference' TLV */
    if (input->arg_cdma_prl_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint16 tmp;

            tmp = (guint16)input->arg_cdma_prl_preference;
            /* Write the guint16 variable to the buffer */
            qmi_utils_write_guint16_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CDMA_PRL_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the CDMA PRL Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Band Preference' TLV */
    if (input->arg_band_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint64 tmp;

            tmp = (guint64)input->arg_band_preference;
            /* Write the guint64 variable to the buffer */
            qmi_utils_write_guint64_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_BAND_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Band Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Mode Preference' TLV */
    if (input->arg_mode_preference_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint16 tmp;

            tmp = (guint16)input->arg_mode_preference;
            /* Write the guint16 variable to the buffer */
            qmi_utils_write_guint16_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MODE_PREFERENCE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Mode Preference TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Emergency mode' TLV */
    if (input->arg_emergency_mode_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_emergency_mode;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EMERGENCY_MODE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Emergency mode TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageNasSetSystemSelectionPreferenceOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_nas_set_system_selection_preference_output_get_result:
 * @self: a QmiMessageNasSetSystemSelectionPreferenceOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_set_system_selection_preference_output_get_result (
    QmiMessageNasSetSystemSelectionPreferenceOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_set_system_selection_preference_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasSetSystemSelectionPreferenceOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_set_system_selection_preference_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_set_system_selection_preference_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_set_system_selection_preference_output_ref:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasSetSystemSelectionPreferenceOutput *
qmi_message_nas_set_system_selection_preference_output_ref (QmiMessageNasSetSystemSelectionPreferenceOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_set_system_selection_preference_output_unref:
 * @self: a #QmiMessageNasSetSystemSelectionPreferenceOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_set_system_selection_preference_output_unref (QmiMessageNasSetSystemSelectionPreferenceOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasSetSystemSelectionPreferenceOutput, self);
    }
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_td_scdma_band_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'TD SCDMA Band Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'TD SCDMA Band Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_td_scdma_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_TD_SCDMA_BAND_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_td_scdma_band_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_td_scdma_band_preference_get_string ((QmiNasTdScdmaBandPreference)tmp));
#elif defined  __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_td_scdma_band_preference_build_string_from_mask ((QmiNasTdScdmaBandPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasTdScdmaBandPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'TD SCDMA Band Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_mnc_pds_digit_include_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'MNC PDS Digit Include Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'MNC PDS Digit Include Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_mnc_pds_digit_include_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MNC_PDS_DIGIT_INCLUDE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_mnc_pds_digit_include_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'MNC PDS Digit Include Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_gsm_wcdma_acquisition_order_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM WCDMA Acquisition Order Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM WCDMA Acquisition Order Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_gsm_wcdma_acquisition_order_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_gsm_wcdma_acquisition_order_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_gsm_wcdma_acquisition_order_preference_get_string ((QmiNasGsmWcdmaAcquisitionOrderPreference)tmp));
#elif defined  __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_gsm_wcdma_acquisition_order_preference_build_string_from_mask ((QmiNasGsmWcdmaAcquisitionOrderPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasGsmWcdmaAcquisitionOrderPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM WCDMA Acquisition Order Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_service_domain_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Service Domain Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Service Domain Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_service_domain_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_SERVICE_DOMAIN_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_service_domain_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_domain_preference_get_string ((QmiNasServiceDomainPreference)tmp));
#elif defined  __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_domain_preference_build_string_from_mask ((QmiNasServiceDomainPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceDomainPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Service Domain Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_change_duration_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Change Duration' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Change Duration' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_change_duration_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CHANGE_DURATION,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_change_duration_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_CHANGE_DURATION_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_change_duration_get_string ((QmiNasChangeDuration)tmp));
#elif defined  __QMI_NAS_CHANGE_DURATION_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_change_duration_build_string_from_mask ((QmiNasChangeDuration)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasChangeDuration
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Change Duration' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_network_selection_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 2;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Network Selection Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Network Selection Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_network_selection_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_network_selection_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mode = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_selection_preference_get_string ((QmiNasNetworkSelectionPreference)tmp));
#elif defined  __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_selection_preference_build_string_from_mask ((QmiNasNetworkSelectionPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkSelectionPreference
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Network Selection Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_lte_band_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE Band Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE Band Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_lte_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_LTE_BAND_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_lte_band_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_LTE_BAND_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_lte_band_preference_get_string ((QmiNasLteBandPreference)tmp));
#elif defined  __QMI_NAS_LTE_BAND_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_lte_band_preference_build_string_from_mask ((QmiNasLteBandPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasLteBandPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE Band Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_roaming_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Roaming Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Roaming Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_roaming_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ROAMING_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_roaming_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_ROAMING_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_preference_get_string ((QmiNasRoamingPreference)tmp));
#elif defined  __QMI_NAS_ROAMING_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_preference_build_string_from_mask ((QmiNasRoamingPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Roaming Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_cdma_prl_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA PRL Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA PRL Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_cdma_prl_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CDMA_PRL_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_cdma_prl_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CDMA_PRL_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_cdma_prl_preference_get_string ((QmiNasCdmaPrlPreference)tmp));
#elif defined  __QMI_NAS_CDMA_PRL_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_cdma_prl_preference_build_string_from_mask ((QmiNasCdmaPrlPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCdmaPrlPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA PRL Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_band_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Band Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Band Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_BAND_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_band_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_BAND_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_band_preference_get_string ((QmiNasBandPreference)tmp));
#elif defined  __QMI_NAS_BAND_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_band_preference_build_string_from_mask ((QmiNasBandPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasBandPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Band Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_mode_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Mode Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Mode Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_mode_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MODE_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_mode_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_RAT_MODE_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_rat_mode_preference_get_string ((QmiNasRatModePreference)tmp));
#elif defined  __QMI_NAS_RAT_MODE_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_rat_mode_preference_build_string_from_mask ((QmiNasRatModePreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRatModePreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Mode Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_set_system_selection_preference_input_emergency_mode_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Emergency mode' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Emergency mode' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_set_system_selection_preference_input_emergency_mode_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EMERGENCY_MODE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_set_system_selection_preference_input_emergency_mode_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Emergency mode' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_system_selection_preference_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_system_selection_preference_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_system_selection_preference_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_TD_SCDMA_BAND_PREFERENCE:
            tlv_type_str = "TD SCDMA Band Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_td_scdma_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MNC_PDS_DIGIT_INCLUDE_STATUS:
            tlv_type_str = "MNC PDS Digit Include Status";
            translated_value = qmi_message_nas_set_system_selection_preference_input_mnc_pds_digit_include_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE:
            tlv_type_str = "GSM WCDMA Acquisition Order Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_gsm_wcdma_acquisition_order_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_SERVICE_DOMAIN_PREFERENCE:
            tlv_type_str = "Service Domain Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_service_domain_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CHANGE_DURATION:
            tlv_type_str = "Change Duration";
            translated_value = qmi_message_nas_set_system_selection_preference_input_change_duration_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_NETWORK_SELECTION_PREFERENCE:
            tlv_type_str = "Network Selection Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_network_selection_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_LTE_BAND_PREFERENCE:
            tlv_type_str = "LTE Band Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_lte_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_ROAMING_PREFERENCE:
            tlv_type_str = "Roaming Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_roaming_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_CDMA_PRL_PREFERENCE:
            tlv_type_str = "CDMA PRL Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_cdma_prl_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_BAND_PREFERENCE:
            tlv_type_str = "Band Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_MODE_PREFERENCE:
            tlv_type_str = "Mode Preference";
            translated_value = qmi_message_nas_set_system_selection_preference_input_mode_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_INPUT_TLV_EMERGENCY_MODE:
            tlv_type_str = "Emergency mode";
            translated_value = qmi_message_nas_set_system_selection_preference_input_emergency_mode_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_system_selection_preference_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set System Selection Preference\" (0x0033)\n",
                            line_prefix);

    {
        struct message_set_system_selection_preference_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_system_selection_preference_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasSetSystemSelectionPreferenceOutput *
__qmi_message_nas_set_system_selection_preference_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasSetSystemSelectionPreferenceOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE, NULL);

    self = g_slice_new0 (QmiMessageNasSetSystemSelectionPreferenceOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_set_system_selection_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get System Selection Preference */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_system_selection_preference_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE);

    return self;
}

/* --- Output -- */

struct _QmiMessageNasGetSystemSelectionPreferenceOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Manual Network Selection */
    gboolean arg_manual_network_selection_set;
    guint16 arg_manual_network_selection_mcc;
    guint16 arg_manual_network_selection_mnc;
    guint8 arg_manual_network_selection_includes_pcs_digit;

    /* TD SCDMA Band Preference */
    gboolean arg_td_scdma_band_preference_set;
    guint64 arg_td_scdma_band_preference;

    /* GSM WCDMA Acquisition Order Preference */
    gboolean arg_gsm_wcdma_acquisition_order_preference_set;
    guint32 arg_gsm_wcdma_acquisition_order_preference;

    /* Service Domain Preference */
    gboolean arg_service_domain_preference_set;
    guint32 arg_service_domain_preference;

    /* Network Selection Preference */
    gboolean arg_network_selection_preference_set;
    guint8 arg_network_selection_preference;

    /* LTE Band Preference */
    gboolean arg_lte_band_preference_set;
    guint64 arg_lte_band_preference;

    /* Roaming Preference */
    gboolean arg_roaming_preference_set;
    guint16 arg_roaming_preference;

    /* CDMA PRL Preference */
    gboolean arg_cdma_prl_preference_set;
    guint16 arg_cdma_prl_preference;

    /* Band Preference */
    gboolean arg_band_preference_set;
    guint64 arg_band_preference;

    /* Mode Preference */
    gboolean arg_mode_preference_set;
    guint16 arg_mode_preference;

    /* Emergency mode */
    gboolean arg_emergency_mode_set;
    guint8 arg_emergency_mode;
};

#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MANUAL_NETWORK_SELECTION 0x1B
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_TD_SCDMA_BAND_PREFERENCE 0x1A
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE 0x19
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_SERVICE_DOMAIN_PREFERENCE 0x18
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_PREFERENCE 0x16
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_LTE_BAND_PREFERENCE 0x15
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ROAMING_PREFERENCE 0x14
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_CDMA_PRL_PREFERENCE 0x13
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_BAND_PREFERENCE 0x12
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MODE_PREFERENCE 0x11
#define QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EMERGENCY_MODE 0x10

/**
 * qmi_message_nas_get_system_selection_preference_output_get_result:
 * @self: a QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_result (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_manual_network_selection:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @manual_network_selection_mcc: a placeholder for the output #guint16, or %NULL if not required.
 * @manual_network_selection_mnc: a placeholder for the output #guint16, or %NULL if not required.
 * @manual_network_selection_includes_pcs_digit: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Manual Network Selection' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_manual_network_selection (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    guint16 *manual_network_selection_mcc,
    guint16 *manual_network_selection_mnc,
    gboolean *manual_network_selection_includes_pcs_digit,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_manual_network_selection_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Manual Network Selection' was not found in the message");
        return FALSE;
    }

    if (manual_network_selection_mcc)
        *manual_network_selection_mcc = self->arg_manual_network_selection_mcc;
    if (manual_network_selection_mnc)
        *manual_network_selection_mnc = self->arg_manual_network_selection_mnc;
    if (manual_network_selection_includes_pcs_digit)
        *manual_network_selection_includes_pcs_digit = (gboolean)(self->arg_manual_network_selection_includes_pcs_digit);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_td_scdma_band_preference:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @td_scdma_band_preference: a placeholder for the output #QmiNasTdScdmaBandPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'TD SCDMA Band Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_td_scdma_band_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasTdScdmaBandPreference *td_scdma_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scdma_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCDMA Band Preference' was not found in the message");
        return FALSE;
    }

    if (td_scdma_band_preference)
        *td_scdma_band_preference = (QmiNasTdScdmaBandPreference)(self->arg_td_scdma_band_preference);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_gsm_wcdma_acquisition_order_preference:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @gsm_wcdma_acquisition_order_preference: a placeholder for the output #QmiNasGsmWcdmaAcquisitionOrderPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM WCDMA Acquisition Order Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_gsm_wcdma_acquisition_order_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasGsmWcdmaAcquisitionOrderPreference *gsm_wcdma_acquisition_order_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_wcdma_acquisition_order_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM WCDMA Acquisition Order Preference' was not found in the message");
        return FALSE;
    }

    if (gsm_wcdma_acquisition_order_preference)
        *gsm_wcdma_acquisition_order_preference = (QmiNasGsmWcdmaAcquisitionOrderPreference)(self->arg_gsm_wcdma_acquisition_order_preference);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_service_domain_preference:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @service_domain_preference: a placeholder for the output #QmiNasServiceDomainPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Service Domain Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_service_domain_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasServiceDomainPreference *service_domain_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_service_domain_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Service Domain Preference' was not found in the message");
        return FALSE;
    }

    if (service_domain_preference)
        *service_domain_preference = (QmiNasServiceDomainPreference)(self->arg_service_domain_preference);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_network_selection_preference:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @network_selection_preference: a placeholder for the output #QmiNasNetworkSelectionPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Network Selection Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_network_selection_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasNetworkSelectionPreference *network_selection_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_network_selection_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Network Selection Preference' was not found in the message");
        return FALSE;
    }

    if (network_selection_preference)
        *network_selection_preference = (QmiNasNetworkSelectionPreference)(self->arg_network_selection_preference);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_lte_band_preference:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @lte_band_preference: a placeholder for the output #QmiNasLteBandPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE Band Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_lte_band_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasLteBandPreference *lte_band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Band Preference' was not found in the message");
        return FALSE;
    }

    if (lte_band_preference)
        *lte_band_preference = (QmiNasLteBandPreference)(self->arg_lte_band_preference);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_roaming_preference:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @roaming_preference: a placeholder for the output #QmiNasRoamingPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Roaming Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_roaming_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasRoamingPreference *roaming_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_roaming_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Roaming Preference' was not found in the message");
        return FALSE;
    }

    if (roaming_preference)
        *roaming_preference = (QmiNasRoamingPreference)(self->arg_roaming_preference);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_cdma_prl_preference:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @cdma_prl_preference: a placeholder for the output #QmiNasCdmaPrlPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA PRL Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_cdma_prl_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasCdmaPrlPreference *cdma_prl_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_prl_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA PRL Preference' was not found in the message");
        return FALSE;
    }

    if (cdma_prl_preference)
        *cdma_prl_preference = (QmiNasCdmaPrlPreference)(self->arg_cdma_prl_preference);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_band_preference:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @band_preference: a placeholder for the output #QmiNasBandPreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Band Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_band_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasBandPreference *band_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_band_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Band Preference' was not found in the message");
        return FALSE;
    }

    if (band_preference)
        *band_preference = (QmiNasBandPreference)(self->arg_band_preference);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_mode_preference:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @mode_preference: a placeholder for the output #QmiNasRatModePreference, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Mode Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_mode_preference (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    QmiNasRatModePreference *mode_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mode_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Mode Preference' was not found in the message");
        return FALSE;
    }

    if (mode_preference)
        *mode_preference = (QmiNasRatModePreference)(self->arg_mode_preference);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_get_emergency_mode:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 * @emergency_mode: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Emergency mode' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_selection_preference_output_get_emergency_mode (
    QmiMessageNasGetSystemSelectionPreferenceOutput *self,
    gboolean *emergency_mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_emergency_mode_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Emergency mode' was not found in the message");
        return FALSE;
    }

    if (emergency_mode)
        *emergency_mode = (gboolean)(self->arg_emergency_mode);

    return TRUE;
}

GType
qmi_message_nas_get_system_selection_preference_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSystemSelectionPreferenceOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_system_selection_preference_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_system_selection_preference_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_ref:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasGetSystemSelectionPreferenceOutput *
qmi_message_nas_get_system_selection_preference_output_ref (QmiMessageNasGetSystemSelectionPreferenceOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_get_system_selection_preference_output_unref:
 * @self: a #QmiMessageNasGetSystemSelectionPreferenceOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_get_system_selection_preference_output_unref (QmiMessageNasGetSystemSelectionPreferenceOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetSystemSelectionPreferenceOutput, self);
    }
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_manual_network_selection_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Manual Network Selection' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Manual Network Selection' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_manual_network_selection_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MANUAL_NETWORK_SELECTION,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_manual_network_selection_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " mcc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " includes_pcs_digit = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Manual Network Selection' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_td_scdma_band_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'TD SCDMA Band Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'TD SCDMA Band Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_td_scdma_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_TD_SCDMA_BAND_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_td_scdma_band_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_td_scdma_band_preference_get_string ((QmiNasTdScdmaBandPreference)tmp));
#elif defined  __QMI_NAS_TD_SCDMA_BAND_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_td_scdma_band_preference_build_string_from_mask ((QmiNasTdScdmaBandPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasTdScdmaBandPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'TD SCDMA Band Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_gsm_wcdma_acquisition_order_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM WCDMA Acquisition Order Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM WCDMA Acquisition Order Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_gsm_wcdma_acquisition_order_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_gsm_wcdma_acquisition_order_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_gsm_wcdma_acquisition_order_preference_get_string ((QmiNasGsmWcdmaAcquisitionOrderPreference)tmp));
#elif defined  __QMI_NAS_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_gsm_wcdma_acquisition_order_preference_build_string_from_mask ((QmiNasGsmWcdmaAcquisitionOrderPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasGsmWcdmaAcquisitionOrderPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM WCDMA Acquisition Order Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_service_domain_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Service Domain Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Service Domain Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_service_domain_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_SERVICE_DOMAIN_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_service_domain_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_domain_preference_get_string ((QmiNasServiceDomainPreference)tmp));
#elif defined  __QMI_NAS_SERVICE_DOMAIN_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_domain_preference_build_string_from_mask ((QmiNasServiceDomainPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceDomainPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Service Domain Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_network_selection_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Network Selection Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Network Selection Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_network_selection_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_network_selection_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_selection_preference_get_string ((QmiNasNetworkSelectionPreference)tmp));
#elif defined  __QMI_NAS_NETWORK_SELECTION_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_selection_preference_build_string_from_mask ((QmiNasNetworkSelectionPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkSelectionPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Network Selection Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_lte_band_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE Band Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE Band Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_lte_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_LTE_BAND_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_lte_band_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_LTE_BAND_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_lte_band_preference_get_string ((QmiNasLteBandPreference)tmp));
#elif defined  __QMI_NAS_LTE_BAND_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_lte_band_preference_build_string_from_mask ((QmiNasLteBandPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasLteBandPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE Band Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_roaming_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Roaming Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Roaming Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_roaming_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ROAMING_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_roaming_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_ROAMING_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_preference_get_string ((QmiNasRoamingPreference)tmp));
#elif defined  __QMI_NAS_ROAMING_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_preference_build_string_from_mask ((QmiNasRoamingPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Roaming Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_cdma_prl_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA PRL Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA PRL Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_cdma_prl_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_CDMA_PRL_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_cdma_prl_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CDMA_PRL_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_cdma_prl_preference_get_string ((QmiNasCdmaPrlPreference)tmp));
#elif defined  __QMI_NAS_CDMA_PRL_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_cdma_prl_preference_build_string_from_mask ((QmiNasCdmaPrlPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCdmaPrlPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA PRL Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_band_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Band Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Band Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_band_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_BAND_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_band_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_BAND_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_band_preference_get_string ((QmiNasBandPreference)tmp));
#elif defined  __QMI_NAS_BAND_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_band_preference_build_string_from_mask ((QmiNasBandPreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasBandPreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Band Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_mode_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Mode Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Mode Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_mode_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MODE_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_mode_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_RAT_MODE_PREFERENCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_rat_mode_preference_get_string ((QmiNasRatModePreference)tmp));
#elif defined  __QMI_NAS_RAT_MODE_PREFERENCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_rat_mode_preference_build_string_from_mask ((QmiNasRatModePreference)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRatModePreference
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Mode Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_selection_preference_output_emergency_mode_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Emergency mode' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Emergency mode' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_selection_preference_output_emergency_mode_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EMERGENCY_MODE,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_selection_preference_output_emergency_mode_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Emergency mode' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_system_selection_preference_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_system_selection_preference_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_system_selection_preference_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MANUAL_NETWORK_SELECTION:
            tlv_type_str = "Manual Network Selection";
            translated_value = qmi_message_nas_get_system_selection_preference_output_manual_network_selection_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_TD_SCDMA_BAND_PREFERENCE:
            tlv_type_str = "TD SCDMA Band Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_td_scdma_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE:
            tlv_type_str = "GSM WCDMA Acquisition Order Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_gsm_wcdma_acquisition_order_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_SERVICE_DOMAIN_PREFERENCE:
            tlv_type_str = "Service Domain Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_service_domain_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_PREFERENCE:
            tlv_type_str = "Network Selection Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_network_selection_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_LTE_BAND_PREFERENCE:
            tlv_type_str = "LTE Band Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_lte_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ROAMING_PREFERENCE:
            tlv_type_str = "Roaming Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_roaming_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_CDMA_PRL_PREFERENCE:
            tlv_type_str = "CDMA PRL Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_cdma_prl_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_BAND_PREFERENCE:
            tlv_type_str = "Band Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_band_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MODE_PREFERENCE:
            tlv_type_str = "Mode Preference";
            translated_value = qmi_message_nas_get_system_selection_preference_output_mode_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EMERGENCY_MODE:
            tlv_type_str = "Emergency mode";
            translated_value = qmi_message_nas_get_system_selection_preference_output_emergency_mode_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_system_selection_preference_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get System Selection Preference\" (0x0034)\n",
                            line_prefix);

    {
        struct message_get_system_selection_preference_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_system_selection_preference_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetSystemSelectionPreferenceOutput *
__qmi_message_nas_get_system_selection_preference_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetSystemSelectionPreferenceOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE, NULL);

    self = g_slice_new0 (QmiMessageNasGetSystemSelectionPreferenceOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_get_system_selection_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MANUAL_NETWORK_SELECTION,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_manual_network_selection_validate (buffer, buffer_len)) {
                self->arg_manual_network_selection_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_manual_network_selection_mcc));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_manual_network_selection_mnc));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_manual_network_selection_includes_pcs_digit = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Manual Network Selection' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_TD_SCDMA_BAND_PREFERENCE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_td_scdma_band_preference_validate (buffer, buffer_len)) {
                self->arg_td_scdma_band_preference_set = TRUE;

                {
                    guint64 tmp;

                    /* Read the guint64 variable from the buffer */
                    qmi_utils_read_guint64_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_td_scdma_band_preference = (QmiNasTdScdmaBandPreference)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'TD SCDMA Band Preference' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_GSM_WCDMA_ACQUISITION_ORDER_PREFERENCE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_gsm_wcdma_acquisition_order_preference_validate (buffer, buffer_len)) {
                self->arg_gsm_wcdma_acquisition_order_preference_set = TRUE;

                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_gsm_wcdma_acquisition_order_preference = (QmiNasGsmWcdmaAcquisitionOrderPreference)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM WCDMA Acquisition Order Preference' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_SERVICE_DOMAIN_PREFERENCE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_service_domain_preference_validate (buffer, buffer_len)) {
                self->arg_service_domain_preference_set = TRUE;

                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_service_domain_preference = (QmiNasServiceDomainPreference)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Service Domain Preference' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_NETWORK_SELECTION_PREFERENCE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_network_selection_preference_validate (buffer, buffer_len)) {
                self->arg_network_selection_preference_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_network_selection_preference = (QmiNasNetworkSelectionPreference)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Network Selection Preference' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_LTE_BAND_PREFERENCE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_lte_band_preference_validate (buffer, buffer_len)) {
                self->arg_lte_band_preference_set = TRUE;

                {
                    guint64 tmp;

                    /* Read the guint64 variable from the buffer */
                    qmi_utils_read_guint64_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_lte_band_preference = (QmiNasLteBandPreference)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE Band Preference' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_ROAMING_PREFERENCE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_roaming_preference_validate (buffer, buffer_len)) {
                self->arg_roaming_preference_set = TRUE;

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_roaming_preference = (QmiNasRoamingPreference)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Roaming Preference' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_CDMA_PRL_PREFERENCE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_cdma_prl_preference_validate (buffer, buffer_len)) {
                self->arg_cdma_prl_preference_set = TRUE;

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_cdma_prl_preference = (QmiNasCdmaPrlPreference)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA PRL Preference' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_BAND_PREFERENCE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_band_preference_validate (buffer, buffer_len)) {
                self->arg_band_preference_set = TRUE;

                {
                    guint64 tmp;

                    /* Read the guint64 variable from the buffer */
                    qmi_utils_read_guint64_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_band_preference = (QmiNasBandPreference)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Band Preference' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_MODE_PREFERENCE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_mode_preference_validate (buffer, buffer_len)) {
                self->arg_mode_preference_set = TRUE;

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_mode_preference = (QmiNasRatModePreference)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Mode Preference' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE_OUTPUT_TLV_EMERGENCY_MODE,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_selection_preference_output_emergency_mode_validate (buffer, buffer_len)) {
                self->arg_emergency_mode_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_emergency_mode = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Emergency mode' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS Network Time */


/* --- Output -- */

struct _QmiIndicationNasNetworkTimeOutput {
    volatile gint ref_count;

    /* Radio Interface */
    gboolean arg_radio_interface_set;
    gint8 arg_radio_interface;

    /* Daylight Savings Adjustment */
    gboolean arg_daylight_savings_adjustment_set;
    guint8 arg_daylight_savings_adjustment;

    /* Timezone Offset */
    gboolean arg_timezone_offset_set;
    gint8 arg_timezone_offset;

    /* Universal Time */
    gboolean arg_universal_time_set;
    guint16 arg_universal_time_year;
    guint8 arg_universal_time_month;
    guint8 arg_universal_time_day;
    guint8 arg_universal_time_hour;
    guint8 arg_universal_time_minute;
    guint8 arg_universal_time_second;
    guint8 arg_universal_time_day_of_week;
};

#define QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_RADIO_INTERFACE 0x12
#define QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_DAYLIGHT_SAVINGS_ADJUSTMENT 0x11
#define QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_TIMEZONE_OFFSET 0x10
#define QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_UNIVERSAL_TIME 0x01

/**
 * qmi_indication_nas_network_time_output_get_radio_interface:
 * @self: a #QmiIndicationNasNetworkTimeOutput.
 * @radio_interface: a placeholder for the output #QmiNasRadioInterface, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Radio Interface' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_network_time_output_get_radio_interface (
    QmiIndicationNasNetworkTimeOutput *self,
    QmiNasRadioInterface *radio_interface,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_radio_interface_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Radio Interface' was not found in the message");
        return FALSE;
    }

    if (radio_interface)
        *radio_interface = (QmiNasRadioInterface)(self->arg_radio_interface);

    return TRUE;
}

/**
 * qmi_indication_nas_network_time_output_get_daylight_savings_adjustment:
 * @self: a #QmiIndicationNasNetworkTimeOutput.
 * @daylight_savings_adjustment: a placeholder for the output #QmiNasDaylightSavingsAdjustment, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Daylight Savings Adjustment' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_network_time_output_get_daylight_savings_adjustment (
    QmiIndicationNasNetworkTimeOutput *self,
    QmiNasDaylightSavingsAdjustment *daylight_savings_adjustment,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_daylight_savings_adjustment_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Daylight Savings Adjustment' was not found in the message");
        return FALSE;
    }

    if (daylight_savings_adjustment)
        *daylight_savings_adjustment = (QmiNasDaylightSavingsAdjustment)(self->arg_daylight_savings_adjustment);

    return TRUE;
}

/**
 * qmi_indication_nas_network_time_output_get_timezone_offset:
 * @self: a #QmiIndicationNasNetworkTimeOutput.
 * @timezone_offset: a placeholder for the output #gint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Timezone Offset' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_network_time_output_get_timezone_offset (
    QmiIndicationNasNetworkTimeOutput *self,
    gint8 *timezone_offset,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_timezone_offset_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Timezone Offset' was not found in the message");
        return FALSE;
    }

    if (timezone_offset)
        *timezone_offset = self->arg_timezone_offset;

    return TRUE;
}

/**
 * qmi_indication_nas_network_time_output_get_universal_time:
 * @self: a #QmiIndicationNasNetworkTimeOutput.
 * @universal_time_year: a placeholder for the output #guint16, or %NULL if not required.
 * @universal_time_month: a placeholder for the output #guint8, or %NULL if not required.
 * @universal_time_day: a placeholder for the output #guint8, or %NULL if not required.
 * @universal_time_hour: a placeholder for the output #guint8, or %NULL if not required.
 * @universal_time_minute: a placeholder for the output #guint8, or %NULL if not required.
 * @universal_time_second: a placeholder for the output #guint8, or %NULL if not required.
 * @universal_time_day_of_week: a placeholder for the output #QmiNasDayOfWeek, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Universal Time' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_network_time_output_get_universal_time (
    QmiIndicationNasNetworkTimeOutput *self,
    guint16 *universal_time_year,
    guint8 *universal_time_month,
    guint8 *universal_time_day,
    guint8 *universal_time_hour,
    guint8 *universal_time_minute,
    guint8 *universal_time_second,
    QmiNasDayOfWeek *universal_time_day_of_week,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_universal_time_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Universal Time' was not found in the message");
        return FALSE;
    }

    if (universal_time_year)
        *universal_time_year = self->arg_universal_time_year;
    if (universal_time_month)
        *universal_time_month = self->arg_universal_time_month;
    if (universal_time_day)
        *universal_time_day = self->arg_universal_time_day;
    if (universal_time_hour)
        *universal_time_hour = self->arg_universal_time_hour;
    if (universal_time_minute)
        *universal_time_minute = self->arg_universal_time_minute;
    if (universal_time_second)
        *universal_time_second = self->arg_universal_time_second;
    if (universal_time_day_of_week)
        *universal_time_day_of_week = (QmiNasDayOfWeek)(self->arg_universal_time_day_of_week);

    return TRUE;
}

GType
qmi_indication_nas_network_time_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasNetworkTimeOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_network_time_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_network_time_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_indication_nas_network_time_output_ref:
 * @self: a #QmiIndicationNasNetworkTimeOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiIndicationNasNetworkTimeOutput *
qmi_indication_nas_network_time_output_ref (QmiIndicationNasNetworkTimeOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_indication_nas_network_time_output_unref:
 * @self: a #QmiIndicationNasNetworkTimeOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_indication_nas_network_time_output_unref (QmiIndicationNasNetworkTimeOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiIndicationNasNetworkTimeOutput, self);
    }
}

static gboolean
qmi_indication_nas_network_time_output_radio_interface_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Radio Interface' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Radio Interface' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_network_time_output_radio_interface_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_RADIO_INTERFACE,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_network_time_output_radio_interface_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_RADIO_INTERFACE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_radio_interface_get_string ((QmiNasRadioInterface)tmp));
#elif defined  __QMI_NAS_RADIO_INTERFACE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_radio_interface_build_string_from_mask ((QmiNasRadioInterface)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRadioInterface
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Radio Interface' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_network_time_output_daylight_savings_adjustment_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Daylight Savings Adjustment' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Daylight Savings Adjustment' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_network_time_output_daylight_savings_adjustment_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_DAYLIGHT_SAVINGS_ADJUSTMENT,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_network_time_output_daylight_savings_adjustment_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_daylight_savings_adjustment_get_string ((QmiNasDaylightSavingsAdjustment)tmp));
#elif defined  __QMI_NAS_DAYLIGHT_SAVINGS_ADJUSTMENT_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_daylight_savings_adjustment_build_string_from_mask ((QmiNasDaylightSavingsAdjustment)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasDaylightSavingsAdjustment
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Daylight Savings Adjustment' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_network_time_output_timezone_offset_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Timezone Offset' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Timezone Offset' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_network_time_output_timezone_offset_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_TIMEZONE_OFFSET,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_network_time_output_timezone_offset_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Timezone Offset' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_network_time_output_universal_time_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Universal Time' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Universal Time' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_network_time_output_universal_time_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_UNIVERSAL_TIME,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_network_time_output_universal_time_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " year = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " month = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " day = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hour = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " minute = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " second = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " day_of_week = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_DAY_OF_WEEK_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_day_of_week_get_string ((QmiNasDayOfWeek)tmp));
#elif defined  __QMI_NAS_DAY_OF_WEEK_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_day_of_week_build_string_from_mask ((QmiNasDayOfWeek)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasDayOfWeek
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Universal Time' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct indication_network_time_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_network_time_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_network_time_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    {
        switch (type) {
        case QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_RADIO_INTERFACE:
            tlv_type_str = "Radio Interface";
            translated_value = qmi_indication_nas_network_time_output_radio_interface_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_DAYLIGHT_SAVINGS_ADJUSTMENT:
            tlv_type_str = "Daylight Savings Adjustment";
            translated_value = qmi_indication_nas_network_time_output_daylight_savings_adjustment_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_TIMEZONE_OFFSET:
            tlv_type_str = "Timezone Offset";
            translated_value = qmi_indication_nas_network_time_output_timezone_offset_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_UNIVERSAL_TIME:
            tlv_type_str = "Universal Time";
            translated_value = qmi_indication_nas_network_time_output_universal_time_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
indication_network_time_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Network Time\" (0x004C)\n",
                            line_prefix);

    {
        struct indication_network_time_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_network_time_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasNetworkTimeOutput *
__qmi_indication_nas_network_time_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasNetworkTimeOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_INDICATION_NAS_NETWORK_TIME, NULL);

    self = g_slice_new0 (QmiIndicationNasNetworkTimeOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_RADIO_INTERFACE,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_network_time_output_radio_interface_validate (buffer, buffer_len)) {
                self->arg_radio_interface_set = TRUE;

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_radio_interface = (QmiNasRadioInterface)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Radio Interface' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_DAYLIGHT_SAVINGS_ADJUSTMENT,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_network_time_output_daylight_savings_adjustment_validate (buffer, buffer_len)) {
                self->arg_daylight_savings_adjustment_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_daylight_savings_adjustment = (QmiNasDaylightSavingsAdjustment)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Daylight Savings Adjustment' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_TIMEZONE_OFFSET,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_network_time_output_timezone_offset_validate (buffer, buffer_len)) {
                self->arg_timezone_offset_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_timezone_offset));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Timezone Offset' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_NETWORK_TIME_OUTPUT_TLV_UNIVERSAL_TIME,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_network_time_output_universal_time_validate (buffer, buffer_len)) {
                self->arg_universal_time_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_universal_time_year));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_month));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_day));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_hour));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_minute));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_universal_time_second));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_universal_time_day_of_week = (QmiNasDayOfWeek)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Universal Time' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Universal Time TLV: Not found");
                qmi_indication_nas_network_time_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get System Info */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_system_info_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SYSTEM_INFO);

    return self;
}

/* --- Output -- */

struct _QmiMessageNasGetSystemInfoOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* SIM Reject Info */
    gboolean arg_sim_reject_info_set;
    guint32 arg_sim_reject_info;

    /* LTE eMBMS Coverage Info Support */
    gboolean arg_lte_embms_coverage_info_support_set;
    guint8 arg_lte_embms_coverage_info_support;

    /* TD SCDMA System Info */
    gboolean arg_td_scdma_system_info_set;
    guint8 arg_td_scdma_system_info_domain_valid;
    guint8 arg_td_scdma_system_info_domain;
    guint8 arg_td_scdma_system_info_service_capability_valid;
    guint8 arg_td_scdma_system_info_service_capability;
    guint8 arg_td_scdma_system_info_roaming_status_valid;
    guint8 arg_td_scdma_system_info_roaming_status;
    guint8 arg_td_scdma_system_info_forbidden_valid;
    guint8 arg_td_scdma_system_info_forbidden;
    guint8 arg_td_scdma_system_info_lac_valid;
    guint16 arg_td_scdma_system_info_lac;
    guint8 arg_td_scdma_system_info_cid_valid;
    guint32 arg_td_scdma_system_info_cid;
    guint8 arg_td_scdma_system_info_registration_reject_info_valid;
    guint8 arg_td_scdma_system_info_registration_reject_domain;
    guint8 arg_td_scdma_system_info_registration_reject_cause;
    guint8 arg_td_scdma_system_info_network_id_valid;
    gchar arg_td_scdma_system_info_mcc[4];
    gchar arg_td_scdma_system_info_mnc[4];
    guint8 arg_td_scdma_system_info_hs_call_status_valid;
    guint8 arg_td_scdma_system_info_hs_call_status;
    guint8 arg_td_scdma_system_info_hs_service_valid;
    guint8 arg_td_scdma_system_info_hs_service;
    guint8 arg_td_scdma_system_info_cell_parameter_id_valid;
    guint16 arg_td_scdma_system_info_cell_parameter_id;
    guint8 arg_td_scdma_system_info_cell_broadcast_support_valid;
    guint32 arg_td_scdma_system_info_cell_broadcast_support;
    guint8 arg_td_scdma_system_info_cs_call_barring_status_valid;
    gint32 arg_td_scdma_system_info_cs_call_barring_status;
    guint8 arg_td_scdma_system_info_ps_call_barring_status_valid;
    gint32 arg_td_scdma_system_info_ps_call_barring_status;
    guint8 arg_td_scdma_system_info_cipher_domain_valid;
    guint8 arg_td_scdma_system_info_cipher_domain;

    /* TD SCDMA Service Status */
    gboolean arg_td_scdma_service_status_set;
    guint8 arg_td_scdma_service_status_service_status;
    guint8 arg_td_scdma_service_status_true_service_status;
    guint8 arg_td_scdma_service_status_preferred_data_path;

    /* WCDMA Cipher Domain */
    gboolean arg_wcdma_cipher_domain_set;
    guint8 arg_wcdma_cipher_domain;

    /* GSM Cipher Domain */
    gboolean arg_gsm_cipher_domain_set;
    guint8 arg_gsm_cipher_domain;

    /* LTE Voice Support */
    gboolean arg_lte_voice_support_set;
    guint8 arg_lte_voice_support;

    /* WCDMA Call Barring Status */
    gboolean arg_wcdma_call_barring_status_set;
    gint32 arg_wcdma_call_barring_status_cs_status;
    gint32 arg_wcdma_call_barring_status_ps_status;

    /* GSM Call Barring Status */
    gboolean arg_gsm_call_barring_status_set;
    gint32 arg_gsm_call_barring_status_cs_status;
    gint32 arg_gsm_call_barring_status_ps_status;

    /* Additional LTE System Info */
    gboolean arg_additional_lte_system_info_set;
    guint16 arg_additional_lte_system_info_geo_system_index;

    /* Additional WCDMA System Info */
    gboolean arg_additional_wcdma_system_info_set;
    guint16 arg_additional_wcdma_system_info_geo_system_index;
    guint32 arg_additional_wcdma_system_info_cell_broadcast_support;

    /* Additional GSM System Info */
    gboolean arg_additional_gsm_system_info_set;
    guint16 arg_additional_gsm_system_info_geo_system_index;
    guint32 arg_additional_gsm_system_info_cell_broadcast_support;

    /* Additional HDR System Info */
    gboolean arg_additional_hdr_system_info_set;
    guint16 arg_additional_hdr_system_info_geo_system_index;

    /* Additional CDMA System Info */
    gboolean arg_additional_cdma_system_info_set;
    guint16 arg_additional_cdma_system_info_geo_system_index;
    guint16 arg_additional_cdma_system_info_registration_period;

    /* LTE System Info */
    gboolean arg_lte_system_info_set;
    guint8 arg_lte_system_info_domain_valid;
    guint8 arg_lte_system_info_domain;
    guint8 arg_lte_system_info_service_capability_valid;
    guint8 arg_lte_system_info_service_capability;
    guint8 arg_lte_system_info_roaming_status_valid;
    guint8 arg_lte_system_info_roaming_status;
    guint8 arg_lte_system_info_forbidden_valid;
    guint8 arg_lte_system_info_forbidden;
    guint8 arg_lte_system_info_lac_valid;
    guint16 arg_lte_system_info_lac;
    guint8 arg_lte_system_info_cid_valid;
    guint32 arg_lte_system_info_cid;
    guint8 arg_lte_system_info_registration_reject_info_valid;
    guint8 arg_lte_system_info_registration_reject_domain;
    guint8 arg_lte_system_info_registration_reject_cause;
    guint8 arg_lte_system_info_network_id_valid;
    gchar arg_lte_system_info_mcc[4];
    gchar arg_lte_system_info_mnc[4];
    guint8 arg_lte_system_info_tac_valid;
    guint16 arg_lte_system_info_tac;

    /* WCDMA System Info */
    gboolean arg_wcdma_system_info_set;
    guint8 arg_wcdma_system_info_domain_valid;
    guint8 arg_wcdma_system_info_domain;
    guint8 arg_wcdma_system_info_service_capability_valid;
    guint8 arg_wcdma_system_info_service_capability;
    guint8 arg_wcdma_system_info_roaming_status_valid;
    guint8 arg_wcdma_system_info_roaming_status;
    guint8 arg_wcdma_system_info_forbidden_valid;
    guint8 arg_wcdma_system_info_forbidden;
    guint8 arg_wcdma_system_info_lac_valid;
    guint16 arg_wcdma_system_info_lac;
    guint8 arg_wcdma_system_info_cid_valid;
    guint32 arg_wcdma_system_info_cid;
    guint8 arg_wcdma_system_info_registration_reject_info_valid;
    guint8 arg_wcdma_system_info_registration_reject_domain;
    guint8 arg_wcdma_system_info_registration_reject_cause;
    guint8 arg_wcdma_system_info_network_id_valid;
    gchar arg_wcdma_system_info_mcc[4];
    gchar arg_wcdma_system_info_mnc[4];
    guint8 arg_wcdma_system_info_hs_call_status_valid;
    guint8 arg_wcdma_system_info_hs_call_status;
    guint8 arg_wcdma_system_info_hs_service_valid;
    guint8 arg_wcdma_system_info_hs_service;
    guint8 arg_wcdma_system_info_primary_scrambling_code_valid;
    guint16 arg_wcdma_system_info_primary_scrambling_code;

    /* GSM System Info */
    gboolean arg_gsm_system_info_set;
    guint8 arg_gsm_system_info_domain_valid;
    guint8 arg_gsm_system_info_domain;
    guint8 arg_gsm_system_info_service_capability_valid;
    guint8 arg_gsm_system_info_service_capability;
    guint8 arg_gsm_system_info_roaming_status_valid;
    guint8 arg_gsm_system_info_roaming_status;
    guint8 arg_gsm_system_info_forbidden_valid;
    guint8 arg_gsm_system_info_forbidden;
    guint8 arg_gsm_system_info_lac_valid;
    guint16 arg_gsm_system_info_lac;
    guint8 arg_gsm_system_info_cid_valid;
    guint32 arg_gsm_system_info_cid;
    guint8 arg_gsm_system_info_registration_reject_info_valid;
    guint8 arg_gsm_system_info_registration_reject_domain;
    guint8 arg_gsm_system_info_registration_reject_cause;
    guint8 arg_gsm_system_info_network_id_valid;
    gchar arg_gsm_system_info_mcc[4];
    gchar arg_gsm_system_info_mnc[4];
    guint8 arg_gsm_system_info_egprs_support_valid;
    guint8 arg_gsm_system_info_egprs_support;
    guint8 arg_gsm_system_info_dtm_support_valid;
    guint8 arg_gsm_system_info_dtm_support;

    /* HDR System Info */
    gboolean arg_hdr_system_info_set;
    guint8 arg_hdr_system_info_domain_valid;
    guint8 arg_hdr_system_info_domain;
    guint8 arg_hdr_system_info_service_capability_valid;
    guint8 arg_hdr_system_info_service_capability;
    guint8 arg_hdr_system_info_roaming_status_valid;
    guint8 arg_hdr_system_info_roaming_status;
    guint8 arg_hdr_system_info_forbidden_valid;
    guint8 arg_hdr_system_info_forbidden;
    guint8 arg_hdr_system_info_prl_match_valid;
    guint8 arg_hdr_system_info_prl_match;
    guint8 arg_hdr_system_info_personality_valid;
    guint8 arg_hdr_system_info_personality;
    guint8 arg_hdr_system_info_protocol_revision_valid;
    guint8 arg_hdr_system_info_protocol_revision;
    guint8 arg_hdr_system_info_is_856_system_id_valid;
    gchar arg_hdr_system_info_is_856_system_id[17];

    /* CDMA System Info */
    gboolean arg_cdma_system_info_set;
    guint8 arg_cdma_system_info_domain_valid;
    guint8 arg_cdma_system_info_domain;
    guint8 arg_cdma_system_info_service_capability_valid;
    guint8 arg_cdma_system_info_service_capability;
    guint8 arg_cdma_system_info_roaming_status_valid;
    guint8 arg_cdma_system_info_roaming_status;
    guint8 arg_cdma_system_info_forbidden_valid;
    guint8 arg_cdma_system_info_forbidden;
    guint8 arg_cdma_system_info_prl_match_valid;
    guint8 arg_cdma_system_info_prl_match;
    guint8 arg_cdma_system_info_p_rev_valid;
    guint8 arg_cdma_system_info_p_rev;
    guint8 arg_cdma_system_info_base_station_p_rev_valid;
    guint8 arg_cdma_system_info_base_station_p_rev;
    guint8 arg_cdma_system_info_concurrent_service_support_valid;
    guint8 arg_cdma_system_info_concurrent_service_support;
    guint8 arg_cdma_system_info_cdma_system_id_valid;
    guint16 arg_cdma_system_info_sid;
    guint16 arg_cdma_system_info_nid;
    guint8 arg_cdma_system_info_base_station_info_valid;
    guint16 arg_cdma_system_info_base_station_id;
    gint32 arg_cdma_system_info_base_station_latitude;
    gint32 arg_cdma_system_info_base_station_longitude;
    guint8 arg_cdma_system_info_packet_zone_valid;
    guint16 arg_cdma_system_info_packet_zone;
    guint8 arg_cdma_system_info_network_id_valid;
    gchar arg_cdma_system_info_mcc[4];
    gchar arg_cdma_system_info_mnc[4];

    /* LTE Service Status */
    gboolean arg_lte_service_status_set;
    guint8 arg_lte_service_status_service_status;
    guint8 arg_lte_service_status_true_service_status;
    guint8 arg_lte_service_status_preferred_data_path;

    /* WCDMA Service Status */
    gboolean arg_wcdma_service_status_set;
    guint8 arg_wcdma_service_status_service_status;
    guint8 arg_wcdma_service_status_true_service_status;
    guint8 arg_wcdma_service_status_preferred_data_path;

    /* GSM Service Status */
    gboolean arg_gsm_service_status_set;
    guint8 arg_gsm_service_status_service_status;
    guint8 arg_gsm_service_status_true_service_status;
    guint8 arg_gsm_service_status_preferred_data_path;

    /* HDR Service Status */
    gboolean arg_hdr_service_status_set;
    guint8 arg_hdr_service_status_service_status;
    guint8 arg_hdr_service_status_preferred_data_path;

    /* CDMA Service Status */
    gboolean arg_cdma_service_status_set;
    guint8 arg_cdma_service_status_service_status;
    guint8 arg_cdma_service_status_preferred_data_path;
};

#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO 0x27
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT 0x26
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SYSTEM_INFO 0x25
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS 0x24
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN 0x23
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN 0x22
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT 0x21
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS 0x20
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS 0x1F
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO 0x1E
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO 0x1D
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO 0x1C
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO 0x1B
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO 0x1A
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO 0x19
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO 0x18
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO 0x17
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO 0x16
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO 0x15
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS 0x14
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS 0x13
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS 0x12
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS 0x11
#define QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS 0x10

/**
 * qmi_message_nas_get_system_info_output_get_result:
 * @self: a QmiMessageNasGetSystemInfoOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_get_system_info_output_get_result (
    QmiMessageNasGetSystemInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_nas_get_system_info_output_get_sim_reject_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @sim_reject_info: a placeholder for the output #QmiNasSimRejectState, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'SIM Reject Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_sim_reject_info (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasSimRejectState *sim_reject_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sim_reject_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SIM Reject Info' was not found in the message");
        return FALSE;
    }

    if (sim_reject_info)
        *sim_reject_info = (QmiNasSimRejectState)(self->arg_sim_reject_info);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_lte_embms_coverage_info_support:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @lte_embms_coverage_info_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE eMBMS Coverage Info Support' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_lte_embms_coverage_info_support (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *lte_embms_coverage_info_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_embms_coverage_info_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE eMBMS Coverage Info Support' was not found in the message");
        return FALSE;
    }

    if (lte_embms_coverage_info_support)
        *lte_embms_coverage_info_support = (gboolean)(self->arg_lte_embms_coverage_info_support);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_td_scdma_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @td_scdma_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @td_scdma_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @td_scdma_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @td_scdma_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_lac_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_lac: a placeholder for the output #guint16, or %NULL if not required.
 * @td_scdma_system_info_cid_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_cid: a placeholder for the output #guint32, or %NULL if not required.
 * @td_scdma_system_info_registration_reject_info_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_registration_reject_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @td_scdma_system_info_registration_reject_cause: a placeholder for the output #guint8, or %NULL if not required.
 * @td_scdma_system_info_network_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_mcc: a placeholder for the output constant string, or %NULL if not required.
 * @td_scdma_system_info_mnc: a placeholder for the output constant string, or %NULL if not required.
 * @td_scdma_system_info_hs_call_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_hs_call_status: a placeholder for the output #QmiNasWcdmaHsService, or %NULL if not required.
 * @td_scdma_system_info_hs_service_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_hs_service: a placeholder for the output #QmiNasWcdmaHsService, or %NULL if not required.
 * @td_scdma_system_info_cell_parameter_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_cell_parameter_id: a placeholder for the output #guint16, or %NULL if not required.
 * @td_scdma_system_info_cell_broadcast_support_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_cell_broadcast_support: a placeholder for the output #QmiNasCellBroadcastCapability, or %NULL if not required.
 * @td_scdma_system_info_cs_call_barring_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_cs_call_barring_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @td_scdma_system_info_ps_call_barring_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_ps_call_barring_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @td_scdma_system_info_cipher_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scdma_system_info_cipher_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'TD SCDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_td_scdma_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *td_scdma_system_info_domain_valid,
    QmiNasNetworkServiceDomain *td_scdma_system_info_domain,
    gboolean *td_scdma_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *td_scdma_system_info_service_capability,
    gboolean *td_scdma_system_info_roaming_status_valid,
    QmiNasRoamingStatus *td_scdma_system_info_roaming_status,
    gboolean *td_scdma_system_info_forbidden_valid,
    gboolean *td_scdma_system_info_forbidden,
    gboolean *td_scdma_system_info_lac_valid,
    guint16 *td_scdma_system_info_lac,
    gboolean *td_scdma_system_info_cid_valid,
    guint32 *td_scdma_system_info_cid,
    gboolean *td_scdma_system_info_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *td_scdma_system_info_registration_reject_domain,
    guint8 *td_scdma_system_info_registration_reject_cause,
    gboolean *td_scdma_system_info_network_id_valid,
    const gchar **td_scdma_system_info_mcc,
    const gchar **td_scdma_system_info_mnc,
    gboolean *td_scdma_system_info_hs_call_status_valid,
    QmiNasWcdmaHsService *td_scdma_system_info_hs_call_status,
    gboolean *td_scdma_system_info_hs_service_valid,
    QmiNasWcdmaHsService *td_scdma_system_info_hs_service,
    gboolean *td_scdma_system_info_cell_parameter_id_valid,
    guint16 *td_scdma_system_info_cell_parameter_id,
    gboolean *td_scdma_system_info_cell_broadcast_support_valid,
    QmiNasCellBroadcastCapability *td_scdma_system_info_cell_broadcast_support,
    gboolean *td_scdma_system_info_cs_call_barring_status_valid,
    QmiNasCallBarringStatus *td_scdma_system_info_cs_call_barring_status,
    gboolean *td_scdma_system_info_ps_call_barring_status_valid,
    QmiNasCallBarringStatus *td_scdma_system_info_ps_call_barring_status,
    gboolean *td_scdma_system_info_cipher_domain_valid,
    QmiNasNetworkServiceDomain *td_scdma_system_info_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCDMA System Info' was not found in the message");
        return FALSE;
    }

    if (td_scdma_system_info_domain_valid)
        *td_scdma_system_info_domain_valid = (gboolean)(self->arg_td_scdma_system_info_domain_valid);
    if (td_scdma_system_info_domain)
        *td_scdma_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scdma_system_info_domain);
    if (td_scdma_system_info_service_capability_valid)
        *td_scdma_system_info_service_capability_valid = (gboolean)(self->arg_td_scdma_system_info_service_capability_valid);
    if (td_scdma_system_info_service_capability)
        *td_scdma_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_td_scdma_system_info_service_capability);
    if (td_scdma_system_info_roaming_status_valid)
        *td_scdma_system_info_roaming_status_valid = (gboolean)(self->arg_td_scdma_system_info_roaming_status_valid);
    if (td_scdma_system_info_roaming_status)
        *td_scdma_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_td_scdma_system_info_roaming_status);
    if (td_scdma_system_info_forbidden_valid)
        *td_scdma_system_info_forbidden_valid = (gboolean)(self->arg_td_scdma_system_info_forbidden_valid);
    if (td_scdma_system_info_forbidden)
        *td_scdma_system_info_forbidden = (gboolean)(self->arg_td_scdma_system_info_forbidden);
    if (td_scdma_system_info_lac_valid)
        *td_scdma_system_info_lac_valid = (gboolean)(self->arg_td_scdma_system_info_lac_valid);
    if (td_scdma_system_info_lac)
        *td_scdma_system_info_lac = self->arg_td_scdma_system_info_lac;
    if (td_scdma_system_info_cid_valid)
        *td_scdma_system_info_cid_valid = (gboolean)(self->arg_td_scdma_system_info_cid_valid);
    if (td_scdma_system_info_cid)
        *td_scdma_system_info_cid = self->arg_td_scdma_system_info_cid;
    if (td_scdma_system_info_registration_reject_info_valid)
        *td_scdma_system_info_registration_reject_info_valid = (gboolean)(self->arg_td_scdma_system_info_registration_reject_info_valid);
    if (td_scdma_system_info_registration_reject_domain)
        *td_scdma_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scdma_system_info_registration_reject_domain);
    if (td_scdma_system_info_registration_reject_cause)
        *td_scdma_system_info_registration_reject_cause = self->arg_td_scdma_system_info_registration_reject_cause;
    if (td_scdma_system_info_network_id_valid)
        *td_scdma_system_info_network_id_valid = (gboolean)(self->arg_td_scdma_system_info_network_id_valid);
    if (td_scdma_system_info_mcc)
        *td_scdma_system_info_mcc = self->arg_td_scdma_system_info_mcc;
    if (td_scdma_system_info_mnc)
        *td_scdma_system_info_mnc = self->arg_td_scdma_system_info_mnc;
    if (td_scdma_system_info_hs_call_status_valid)
        *td_scdma_system_info_hs_call_status_valid = (gboolean)(self->arg_td_scdma_system_info_hs_call_status_valid);
    if (td_scdma_system_info_hs_call_status)
        *td_scdma_system_info_hs_call_status = (QmiNasWcdmaHsService)(self->arg_td_scdma_system_info_hs_call_status);
    if (td_scdma_system_info_hs_service_valid)
        *td_scdma_system_info_hs_service_valid = (gboolean)(self->arg_td_scdma_system_info_hs_service_valid);
    if (td_scdma_system_info_hs_service)
        *td_scdma_system_info_hs_service = (QmiNasWcdmaHsService)(self->arg_td_scdma_system_info_hs_service);
    if (td_scdma_system_info_cell_parameter_id_valid)
        *td_scdma_system_info_cell_parameter_id_valid = (gboolean)(self->arg_td_scdma_system_info_cell_parameter_id_valid);
    if (td_scdma_system_info_cell_parameter_id)
        *td_scdma_system_info_cell_parameter_id = self->arg_td_scdma_system_info_cell_parameter_id;
    if (td_scdma_system_info_cell_broadcast_support_valid)
        *td_scdma_system_info_cell_broadcast_support_valid = (gboolean)(self->arg_td_scdma_system_info_cell_broadcast_support_valid);
    if (td_scdma_system_info_cell_broadcast_support)
        *td_scdma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_td_scdma_system_info_cell_broadcast_support);
    if (td_scdma_system_info_cs_call_barring_status_valid)
        *td_scdma_system_info_cs_call_barring_status_valid = (gboolean)(self->arg_td_scdma_system_info_cs_call_barring_status_valid);
    if (td_scdma_system_info_cs_call_barring_status)
        *td_scdma_system_info_cs_call_barring_status = (QmiNasCallBarringStatus)(self->arg_td_scdma_system_info_cs_call_barring_status);
    if (td_scdma_system_info_ps_call_barring_status_valid)
        *td_scdma_system_info_ps_call_barring_status_valid = (gboolean)(self->arg_td_scdma_system_info_ps_call_barring_status_valid);
    if (td_scdma_system_info_ps_call_barring_status)
        *td_scdma_system_info_ps_call_barring_status = (QmiNasCallBarringStatus)(self->arg_td_scdma_system_info_ps_call_barring_status);
    if (td_scdma_system_info_cipher_domain_valid)
        *td_scdma_system_info_cipher_domain_valid = (gboolean)(self->arg_td_scdma_system_info_cipher_domain_valid);
    if (td_scdma_system_info_cipher_domain)
        *td_scdma_system_info_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scdma_system_info_cipher_domain);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_td_scdma_service_status:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @td_scdma_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @td_scdma_service_status_true_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @td_scdma_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'TD SCDMA Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_td_scdma_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *td_scdma_service_status_service_status,
    QmiNasServiceStatus *td_scdma_service_status_true_service_status,
    gboolean *td_scdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (td_scdma_service_status_service_status)
        *td_scdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_td_scdma_service_status_service_status);
    if (td_scdma_service_status_true_service_status)
        *td_scdma_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_td_scdma_service_status_true_service_status);
    if (td_scdma_service_status_preferred_data_path)
        *td_scdma_service_status_preferred_data_path = (gboolean)(self->arg_td_scdma_service_status_preferred_data_path);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_wcdma_cipher_domain:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @wcdma_cipher_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'WCDMA Cipher Domain' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_wcdma_cipher_domain (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasNetworkServiceDomain *wcdma_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_cipher_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Cipher Domain' was not found in the message");
        return FALSE;
    }

    if (wcdma_cipher_domain)
        *wcdma_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_cipher_domain);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_gsm_cipher_domain:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @gsm_cipher_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM Cipher Domain' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_gsm_cipher_domain (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasNetworkServiceDomain *gsm_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_cipher_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Cipher Domain' was not found in the message");
        return FALSE;
    }

    if (gsm_cipher_domain)
        *gsm_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_cipher_domain);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_lte_voice_support:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @lte_voice_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE Voice Support' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_lte_voice_support (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *lte_voice_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_voice_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Voice Support' was not found in the message");
        return FALSE;
    }

    if (lte_voice_support)
        *lte_voice_support = (gboolean)(self->arg_lte_voice_support);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_wcdma_call_barring_status:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @wcdma_call_barring_status_cs_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @wcdma_call_barring_status_ps_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'WCDMA Call Barring Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_wcdma_call_barring_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasCallBarringStatus *wcdma_call_barring_status_cs_status,
    QmiNasCallBarringStatus *wcdma_call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (wcdma_call_barring_status_cs_status)
        *wcdma_call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_wcdma_call_barring_status_cs_status);
    if (wcdma_call_barring_status_ps_status)
        *wcdma_call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_wcdma_call_barring_status_ps_status);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_gsm_call_barring_status:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @gsm_call_barring_status_cs_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @gsm_call_barring_status_ps_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM Call Barring Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_gsm_call_barring_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasCallBarringStatus *gsm_call_barring_status_cs_status,
    QmiNasCallBarringStatus *gsm_call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (gsm_call_barring_status_cs_status)
        *gsm_call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_gsm_call_barring_status_cs_status);
    if (gsm_call_barring_status_ps_status)
        *gsm_call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_gsm_call_barring_status_ps_status);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_additional_lte_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @additional_lte_system_info_geo_system_index: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Additional LTE System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_additional_lte_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *additional_lte_system_info_geo_system_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_lte_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional LTE System Info' was not found in the message");
        return FALSE;
    }

    if (additional_lte_system_info_geo_system_index)
        *additional_lte_system_info_geo_system_index = self->arg_additional_lte_system_info_geo_system_index;

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_additional_wcdma_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @additional_wcdma_system_info_geo_system_index: a placeholder for the output #guint16, or %NULL if not required.
 * @additional_wcdma_system_info_cell_broadcast_support: a placeholder for the output #QmiNasCellBroadcastCapability, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Additional WCDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_additional_wcdma_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *additional_wcdma_system_info_geo_system_index,
    QmiNasCellBroadcastCapability *additional_wcdma_system_info_cell_broadcast_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_wcdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional WCDMA System Info' was not found in the message");
        return FALSE;
    }

    if (additional_wcdma_system_info_geo_system_index)
        *additional_wcdma_system_info_geo_system_index = self->arg_additional_wcdma_system_info_geo_system_index;
    if (additional_wcdma_system_info_cell_broadcast_support)
        *additional_wcdma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_additional_wcdma_system_info_cell_broadcast_support);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_additional_gsm_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @additional_gsm_system_info_geo_system_index: a placeholder for the output #guint16, or %NULL if not required.
 * @additional_gsm_system_info_cell_broadcast_support: a placeholder for the output #QmiNasCellBroadcastCapability, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Additional GSM System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_additional_gsm_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *additional_gsm_system_info_geo_system_index,
    QmiNasCellBroadcastCapability *additional_gsm_system_info_cell_broadcast_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_gsm_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional GSM System Info' was not found in the message");
        return FALSE;
    }

    if (additional_gsm_system_info_geo_system_index)
        *additional_gsm_system_info_geo_system_index = self->arg_additional_gsm_system_info_geo_system_index;
    if (additional_gsm_system_info_cell_broadcast_support)
        *additional_gsm_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_additional_gsm_system_info_cell_broadcast_support);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_additional_hdr_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @additional_hdr_system_info_geo_system_index: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Additional HDR System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_additional_hdr_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *additional_hdr_system_info_geo_system_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_hdr_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional HDR System Info' was not found in the message");
        return FALSE;
    }

    if (additional_hdr_system_info_geo_system_index)
        *additional_hdr_system_info_geo_system_index = self->arg_additional_hdr_system_info_geo_system_index;

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_additional_cdma_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @additional_cdma_system_info_geo_system_index: a placeholder for the output #guint16, or %NULL if not required.
 * @additional_cdma_system_info_registration_period: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Additional CDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_additional_cdma_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    guint16 *additional_cdma_system_info_geo_system_index,
    guint16 *additional_cdma_system_info_registration_period,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (additional_cdma_system_info_geo_system_index)
        *additional_cdma_system_info_geo_system_index = self->arg_additional_cdma_system_info_geo_system_index;
    if (additional_cdma_system_info_registration_period)
        *additional_cdma_system_info_registration_period = self->arg_additional_cdma_system_info_registration_period;

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_lte_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @lte_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @lte_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @lte_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @lte_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_lac_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_lac: a placeholder for the output #guint16, or %NULL if not required.
 * @lte_system_info_cid_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_cid: a placeholder for the output #guint32, or %NULL if not required.
 * @lte_system_info_registration_reject_info_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_registration_reject_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @lte_system_info_registration_reject_cause: a placeholder for the output #guint8, or %NULL if not required.
 * @lte_system_info_network_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_mcc: a placeholder for the output constant string, or %NULL if not required.
 * @lte_system_info_mnc: a placeholder for the output constant string, or %NULL if not required.
 * @lte_system_info_tac_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_tac: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_lte_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *lte_system_info_domain_valid,
    QmiNasNetworkServiceDomain *lte_system_info_domain,
    gboolean *lte_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *lte_system_info_service_capability,
    gboolean *lte_system_info_roaming_status_valid,
    QmiNasRoamingStatus *lte_system_info_roaming_status,
    gboolean *lte_system_info_forbidden_valid,
    gboolean *lte_system_info_forbidden,
    gboolean *lte_system_info_lac_valid,
    guint16 *lte_system_info_lac,
    gboolean *lte_system_info_cid_valid,
    guint32 *lte_system_info_cid,
    gboolean *lte_system_info_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *lte_system_info_registration_reject_domain,
    guint8 *lte_system_info_registration_reject_cause,
    gboolean *lte_system_info_network_id_valid,
    const gchar **lte_system_info_mcc,
    const gchar **lte_system_info_mnc,
    gboolean *lte_system_info_tac_valid,
    guint16 *lte_system_info_tac,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE System Info' was not found in the message");
        return FALSE;
    }

    if (lte_system_info_domain_valid)
        *lte_system_info_domain_valid = (gboolean)(self->arg_lte_system_info_domain_valid);
    if (lte_system_info_domain)
        *lte_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_domain);
    if (lte_system_info_service_capability_valid)
        *lte_system_info_service_capability_valid = (gboolean)(self->arg_lte_system_info_service_capability_valid);
    if (lte_system_info_service_capability)
        *lte_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_service_capability);
    if (lte_system_info_roaming_status_valid)
        *lte_system_info_roaming_status_valid = (gboolean)(self->arg_lte_system_info_roaming_status_valid);
    if (lte_system_info_roaming_status)
        *lte_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_lte_system_info_roaming_status);
    if (lte_system_info_forbidden_valid)
        *lte_system_info_forbidden_valid = (gboolean)(self->arg_lte_system_info_forbidden_valid);
    if (lte_system_info_forbidden)
        *lte_system_info_forbidden = (gboolean)(self->arg_lte_system_info_forbidden);
    if (lte_system_info_lac_valid)
        *lte_system_info_lac_valid = (gboolean)(self->arg_lte_system_info_lac_valid);
    if (lte_system_info_lac)
        *lte_system_info_lac = self->arg_lte_system_info_lac;
    if (lte_system_info_cid_valid)
        *lte_system_info_cid_valid = (gboolean)(self->arg_lte_system_info_cid_valid);
    if (lte_system_info_cid)
        *lte_system_info_cid = self->arg_lte_system_info_cid;
    if (lte_system_info_registration_reject_info_valid)
        *lte_system_info_registration_reject_info_valid = (gboolean)(self->arg_lte_system_info_registration_reject_info_valid);
    if (lte_system_info_registration_reject_domain)
        *lte_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_registration_reject_domain);
    if (lte_system_info_registration_reject_cause)
        *lte_system_info_registration_reject_cause = self->arg_lte_system_info_registration_reject_cause;
    if (lte_system_info_network_id_valid)
        *lte_system_info_network_id_valid = (gboolean)(self->arg_lte_system_info_network_id_valid);
    if (lte_system_info_mcc)
        *lte_system_info_mcc = self->arg_lte_system_info_mcc;
    if (lte_system_info_mnc)
        *lte_system_info_mnc = self->arg_lte_system_info_mnc;
    if (lte_system_info_tac_valid)
        *lte_system_info_tac_valid = (gboolean)(self->arg_lte_system_info_tac_valid);
    if (lte_system_info_tac)
        *lte_system_info_tac = self->arg_lte_system_info_tac;

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_wcdma_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @wcdma_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @wcdma_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @wcdma_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @wcdma_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_lac_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_lac: a placeholder for the output #guint16, or %NULL if not required.
 * @wcdma_system_info_cid_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_cid: a placeholder for the output #guint32, or %NULL if not required.
 * @wcdma_system_info_registration_reject_info_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_registration_reject_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @wcdma_system_info_registration_reject_cause: a placeholder for the output #guint8, or %NULL if not required.
 * @wcdma_system_info_network_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_mcc: a placeholder for the output constant string, or %NULL if not required.
 * @wcdma_system_info_mnc: a placeholder for the output constant string, or %NULL if not required.
 * @wcdma_system_info_hs_call_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_hs_call_status: a placeholder for the output #QmiNasWcdmaHsService, or %NULL if not required.
 * @wcdma_system_info_hs_service_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_hs_service: a placeholder for the output #QmiNasWcdmaHsService, or %NULL if not required.
 * @wcdma_system_info_primary_scrambling_code_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_primary_scrambling_code: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'WCDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_wcdma_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *wcdma_system_info_domain_valid,
    QmiNasNetworkServiceDomain *wcdma_system_info_domain,
    gboolean *wcdma_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *wcdma_system_info_service_capability,
    gboolean *wcdma_system_info_roaming_status_valid,
    QmiNasRoamingStatus *wcdma_system_info_roaming_status,
    gboolean *wcdma_system_info_forbidden_valid,
    gboolean *wcdma_system_info_forbidden,
    gboolean *wcdma_system_info_lac_valid,
    guint16 *wcdma_system_info_lac,
    gboolean *wcdma_system_info_cid_valid,
    guint32 *wcdma_system_info_cid,
    gboolean *wcdma_system_info_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *wcdma_system_info_registration_reject_domain,
    guint8 *wcdma_system_info_registration_reject_cause,
    gboolean *wcdma_system_info_network_id_valid,
    const gchar **wcdma_system_info_mcc,
    const gchar **wcdma_system_info_mnc,
    gboolean *wcdma_system_info_hs_call_status_valid,
    QmiNasWcdmaHsService *wcdma_system_info_hs_call_status,
    gboolean *wcdma_system_info_hs_service_valid,
    QmiNasWcdmaHsService *wcdma_system_info_hs_service,
    gboolean *wcdma_system_info_primary_scrambling_code_valid,
    guint16 *wcdma_system_info_primary_scrambling_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA System Info' was not found in the message");
        return FALSE;
    }

    if (wcdma_system_info_domain_valid)
        *wcdma_system_info_domain_valid = (gboolean)(self->arg_wcdma_system_info_domain_valid);
    if (wcdma_system_info_domain)
        *wcdma_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_domain);
    if (wcdma_system_info_service_capability_valid)
        *wcdma_system_info_service_capability_valid = (gboolean)(self->arg_wcdma_system_info_service_capability_valid);
    if (wcdma_system_info_service_capability)
        *wcdma_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_service_capability);
    if (wcdma_system_info_roaming_status_valid)
        *wcdma_system_info_roaming_status_valid = (gboolean)(self->arg_wcdma_system_info_roaming_status_valid);
    if (wcdma_system_info_roaming_status)
        *wcdma_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_wcdma_system_info_roaming_status);
    if (wcdma_system_info_forbidden_valid)
        *wcdma_system_info_forbidden_valid = (gboolean)(self->arg_wcdma_system_info_forbidden_valid);
    if (wcdma_system_info_forbidden)
        *wcdma_system_info_forbidden = (gboolean)(self->arg_wcdma_system_info_forbidden);
    if (wcdma_system_info_lac_valid)
        *wcdma_system_info_lac_valid = (gboolean)(self->arg_wcdma_system_info_lac_valid);
    if (wcdma_system_info_lac)
        *wcdma_system_info_lac = self->arg_wcdma_system_info_lac;
    if (wcdma_system_info_cid_valid)
        *wcdma_system_info_cid_valid = (gboolean)(self->arg_wcdma_system_info_cid_valid);
    if (wcdma_system_info_cid)
        *wcdma_system_info_cid = self->arg_wcdma_system_info_cid;
    if (wcdma_system_info_registration_reject_info_valid)
        *wcdma_system_info_registration_reject_info_valid = (gboolean)(self->arg_wcdma_system_info_registration_reject_info_valid);
    if (wcdma_system_info_registration_reject_domain)
        *wcdma_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_registration_reject_domain);
    if (wcdma_system_info_registration_reject_cause)
        *wcdma_system_info_registration_reject_cause = self->arg_wcdma_system_info_registration_reject_cause;
    if (wcdma_system_info_network_id_valid)
        *wcdma_system_info_network_id_valid = (gboolean)(self->arg_wcdma_system_info_network_id_valid);
    if (wcdma_system_info_mcc)
        *wcdma_system_info_mcc = self->arg_wcdma_system_info_mcc;
    if (wcdma_system_info_mnc)
        *wcdma_system_info_mnc = self->arg_wcdma_system_info_mnc;
    if (wcdma_system_info_hs_call_status_valid)
        *wcdma_system_info_hs_call_status_valid = (gboolean)(self->arg_wcdma_system_info_hs_call_status_valid);
    if (wcdma_system_info_hs_call_status)
        *wcdma_system_info_hs_call_status = (QmiNasWcdmaHsService)(self->arg_wcdma_system_info_hs_call_status);
    if (wcdma_system_info_hs_service_valid)
        *wcdma_system_info_hs_service_valid = (gboolean)(self->arg_wcdma_system_info_hs_service_valid);
    if (wcdma_system_info_hs_service)
        *wcdma_system_info_hs_service = (QmiNasWcdmaHsService)(self->arg_wcdma_system_info_hs_service);
    if (wcdma_system_info_primary_scrambling_code_valid)
        *wcdma_system_info_primary_scrambling_code_valid = (gboolean)(self->arg_wcdma_system_info_primary_scrambling_code_valid);
    if (wcdma_system_info_primary_scrambling_code)
        *wcdma_system_info_primary_scrambling_code = self->arg_wcdma_system_info_primary_scrambling_code;

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_gsm_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @gsm_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @gsm_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @gsm_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @gsm_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_lac_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_lac: a placeholder for the output #guint16, or %NULL if not required.
 * @gsm_system_info_cid_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_cid: a placeholder for the output #guint32, or %NULL if not required.
 * @gsm_system_info_registration_reject_info_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_registration_reject_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @gsm_system_info_registration_reject_cause: a placeholder for the output #guint8, or %NULL if not required.
 * @gsm_system_info_network_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_mcc: a placeholder for the output constant string, or %NULL if not required.
 * @gsm_system_info_mnc: a placeholder for the output constant string, or %NULL if not required.
 * @gsm_system_info_egprs_support_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_egprs_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_dtm_support_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_dtm_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_gsm_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *gsm_system_info_domain_valid,
    QmiNasNetworkServiceDomain *gsm_system_info_domain,
    gboolean *gsm_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *gsm_system_info_service_capability,
    gboolean *gsm_system_info_roaming_status_valid,
    QmiNasRoamingStatus *gsm_system_info_roaming_status,
    gboolean *gsm_system_info_forbidden_valid,
    gboolean *gsm_system_info_forbidden,
    gboolean *gsm_system_info_lac_valid,
    guint16 *gsm_system_info_lac,
    gboolean *gsm_system_info_cid_valid,
    guint32 *gsm_system_info_cid,
    gboolean *gsm_system_info_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *gsm_system_info_registration_reject_domain,
    guint8 *gsm_system_info_registration_reject_cause,
    gboolean *gsm_system_info_network_id_valid,
    const gchar **gsm_system_info_mcc,
    const gchar **gsm_system_info_mnc,
    gboolean *gsm_system_info_egprs_support_valid,
    gboolean *gsm_system_info_egprs_support,
    gboolean *gsm_system_info_dtm_support_valid,
    gboolean *gsm_system_info_dtm_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM System Info' was not found in the message");
        return FALSE;
    }

    if (gsm_system_info_domain_valid)
        *gsm_system_info_domain_valid = (gboolean)(self->arg_gsm_system_info_domain_valid);
    if (gsm_system_info_domain)
        *gsm_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_domain);
    if (gsm_system_info_service_capability_valid)
        *gsm_system_info_service_capability_valid = (gboolean)(self->arg_gsm_system_info_service_capability_valid);
    if (gsm_system_info_service_capability)
        *gsm_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_service_capability);
    if (gsm_system_info_roaming_status_valid)
        *gsm_system_info_roaming_status_valid = (gboolean)(self->arg_gsm_system_info_roaming_status_valid);
    if (gsm_system_info_roaming_status)
        *gsm_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_gsm_system_info_roaming_status);
    if (gsm_system_info_forbidden_valid)
        *gsm_system_info_forbidden_valid = (gboolean)(self->arg_gsm_system_info_forbidden_valid);
    if (gsm_system_info_forbidden)
        *gsm_system_info_forbidden = (gboolean)(self->arg_gsm_system_info_forbidden);
    if (gsm_system_info_lac_valid)
        *gsm_system_info_lac_valid = (gboolean)(self->arg_gsm_system_info_lac_valid);
    if (gsm_system_info_lac)
        *gsm_system_info_lac = self->arg_gsm_system_info_lac;
    if (gsm_system_info_cid_valid)
        *gsm_system_info_cid_valid = (gboolean)(self->arg_gsm_system_info_cid_valid);
    if (gsm_system_info_cid)
        *gsm_system_info_cid = self->arg_gsm_system_info_cid;
    if (gsm_system_info_registration_reject_info_valid)
        *gsm_system_info_registration_reject_info_valid = (gboolean)(self->arg_gsm_system_info_registration_reject_info_valid);
    if (gsm_system_info_registration_reject_domain)
        *gsm_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_registration_reject_domain);
    if (gsm_system_info_registration_reject_cause)
        *gsm_system_info_registration_reject_cause = self->arg_gsm_system_info_registration_reject_cause;
    if (gsm_system_info_network_id_valid)
        *gsm_system_info_network_id_valid = (gboolean)(self->arg_gsm_system_info_network_id_valid);
    if (gsm_system_info_mcc)
        *gsm_system_info_mcc = self->arg_gsm_system_info_mcc;
    if (gsm_system_info_mnc)
        *gsm_system_info_mnc = self->arg_gsm_system_info_mnc;
    if (gsm_system_info_egprs_support_valid)
        *gsm_system_info_egprs_support_valid = (gboolean)(self->arg_gsm_system_info_egprs_support_valid);
    if (gsm_system_info_egprs_support)
        *gsm_system_info_egprs_support = (gboolean)(self->arg_gsm_system_info_egprs_support);
    if (gsm_system_info_dtm_support_valid)
        *gsm_system_info_dtm_support_valid = (gboolean)(self->arg_gsm_system_info_dtm_support_valid);
    if (gsm_system_info_dtm_support)
        *gsm_system_info_dtm_support = (gboolean)(self->arg_gsm_system_info_dtm_support);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_hdr_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @hdr_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @hdr_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @hdr_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @hdr_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_prl_match_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_prl_match: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_personality_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_personality: a placeholder for the output #QmiNasHdrPersonality, or %NULL if not required.
 * @hdr_system_info_protocol_revision_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_protocol_revision: a placeholder for the output #QmiNasHdrProtocolRevision, or %NULL if not required.
 * @hdr_system_info_is_856_system_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_is_856_system_id: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'HDR System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_hdr_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *hdr_system_info_domain_valid,
    QmiNasNetworkServiceDomain *hdr_system_info_domain,
    gboolean *hdr_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *hdr_system_info_service_capability,
    gboolean *hdr_system_info_roaming_status_valid,
    QmiNasRoamingStatus *hdr_system_info_roaming_status,
    gboolean *hdr_system_info_forbidden_valid,
    gboolean *hdr_system_info_forbidden,
    gboolean *hdr_system_info_prl_match_valid,
    gboolean *hdr_system_info_prl_match,
    gboolean *hdr_system_info_personality_valid,
    QmiNasHdrPersonality *hdr_system_info_personality,
    gboolean *hdr_system_info_protocol_revision_valid,
    QmiNasHdrProtocolRevision *hdr_system_info_protocol_revision,
    gboolean *hdr_system_info_is_856_system_id_valid,
    const gchar **hdr_system_info_is_856_system_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR System Info' was not found in the message");
        return FALSE;
    }

    if (hdr_system_info_domain_valid)
        *hdr_system_info_domain_valid = (gboolean)(self->arg_hdr_system_info_domain_valid);
    if (hdr_system_info_domain)
        *hdr_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_hdr_system_info_domain);
    if (hdr_system_info_service_capability_valid)
        *hdr_system_info_service_capability_valid = (gboolean)(self->arg_hdr_system_info_service_capability_valid);
    if (hdr_system_info_service_capability)
        *hdr_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_hdr_system_info_service_capability);
    if (hdr_system_info_roaming_status_valid)
        *hdr_system_info_roaming_status_valid = (gboolean)(self->arg_hdr_system_info_roaming_status_valid);
    if (hdr_system_info_roaming_status)
        *hdr_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_hdr_system_info_roaming_status);
    if (hdr_system_info_forbidden_valid)
        *hdr_system_info_forbidden_valid = (gboolean)(self->arg_hdr_system_info_forbidden_valid);
    if (hdr_system_info_forbidden)
        *hdr_system_info_forbidden = (gboolean)(self->arg_hdr_system_info_forbidden);
    if (hdr_system_info_prl_match_valid)
        *hdr_system_info_prl_match_valid = (gboolean)(self->arg_hdr_system_info_prl_match_valid);
    if (hdr_system_info_prl_match)
        *hdr_system_info_prl_match = (gboolean)(self->arg_hdr_system_info_prl_match);
    if (hdr_system_info_personality_valid)
        *hdr_system_info_personality_valid = (gboolean)(self->arg_hdr_system_info_personality_valid);
    if (hdr_system_info_personality)
        *hdr_system_info_personality = (QmiNasHdrPersonality)(self->arg_hdr_system_info_personality);
    if (hdr_system_info_protocol_revision_valid)
        *hdr_system_info_protocol_revision_valid = (gboolean)(self->arg_hdr_system_info_protocol_revision_valid);
    if (hdr_system_info_protocol_revision)
        *hdr_system_info_protocol_revision = (QmiNasHdrProtocolRevision)(self->arg_hdr_system_info_protocol_revision);
    if (hdr_system_info_is_856_system_id_valid)
        *hdr_system_info_is_856_system_id_valid = (gboolean)(self->arg_hdr_system_info_is_856_system_id_valid);
    if (hdr_system_info_is_856_system_id)
        *hdr_system_info_is_856_system_id = self->arg_hdr_system_info_is_856_system_id;

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_cdma_system_info:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @cdma_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @cdma_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @cdma_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @cdma_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_prl_match_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_prl_match: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_p_rev_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_p_rev: a placeholder for the output #guint8, or %NULL if not required.
 * @cdma_system_info_base_station_p_rev_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_base_station_p_rev: a placeholder for the output #guint8, or %NULL if not required.
 * @cdma_system_info_concurrent_service_support_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_concurrent_service_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_cdma_system_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_sid: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_info_nid: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_info_base_station_info_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_base_station_id: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_info_base_station_latitude: a placeholder for the output #gint32, or %NULL if not required.
 * @cdma_system_info_base_station_longitude: a placeholder for the output #gint32, or %NULL if not required.
 * @cdma_system_info_packet_zone_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_packet_zone: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_info_network_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_mcc: a placeholder for the output constant string, or %NULL if not required.
 * @cdma_system_info_mnc: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_cdma_system_info (
    QmiMessageNasGetSystemInfoOutput *self,
    gboolean *cdma_system_info_domain_valid,
    QmiNasNetworkServiceDomain *cdma_system_info_domain,
    gboolean *cdma_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *cdma_system_info_service_capability,
    gboolean *cdma_system_info_roaming_status_valid,
    QmiNasRoamingStatus *cdma_system_info_roaming_status,
    gboolean *cdma_system_info_forbidden_valid,
    gboolean *cdma_system_info_forbidden,
    gboolean *cdma_system_info_prl_match_valid,
    gboolean *cdma_system_info_prl_match,
    gboolean *cdma_system_info_p_rev_valid,
    guint8 *cdma_system_info_p_rev,
    gboolean *cdma_system_info_base_station_p_rev_valid,
    guint8 *cdma_system_info_base_station_p_rev,
    gboolean *cdma_system_info_concurrent_service_support_valid,
    gboolean *cdma_system_info_concurrent_service_support,
    gboolean *cdma_system_info_cdma_system_id_valid,
    guint16 *cdma_system_info_sid,
    guint16 *cdma_system_info_nid,
    gboolean *cdma_system_info_base_station_info_valid,
    guint16 *cdma_system_info_base_station_id,
    gint32 *cdma_system_info_base_station_latitude,
    gint32 *cdma_system_info_base_station_longitude,
    gboolean *cdma_system_info_packet_zone_valid,
    guint16 *cdma_system_info_packet_zone,
    gboolean *cdma_system_info_network_id_valid,
    const gchar **cdma_system_info_mcc,
    const gchar **cdma_system_info_mnc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (cdma_system_info_domain_valid)
        *cdma_system_info_domain_valid = (gboolean)(self->arg_cdma_system_info_domain_valid);
    if (cdma_system_info_domain)
        *cdma_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_cdma_system_info_domain);
    if (cdma_system_info_service_capability_valid)
        *cdma_system_info_service_capability_valid = (gboolean)(self->arg_cdma_system_info_service_capability_valid);
    if (cdma_system_info_service_capability)
        *cdma_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_cdma_system_info_service_capability);
    if (cdma_system_info_roaming_status_valid)
        *cdma_system_info_roaming_status_valid = (gboolean)(self->arg_cdma_system_info_roaming_status_valid);
    if (cdma_system_info_roaming_status)
        *cdma_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_cdma_system_info_roaming_status);
    if (cdma_system_info_forbidden_valid)
        *cdma_system_info_forbidden_valid = (gboolean)(self->arg_cdma_system_info_forbidden_valid);
    if (cdma_system_info_forbidden)
        *cdma_system_info_forbidden = (gboolean)(self->arg_cdma_system_info_forbidden);
    if (cdma_system_info_prl_match_valid)
        *cdma_system_info_prl_match_valid = (gboolean)(self->arg_cdma_system_info_prl_match_valid);
    if (cdma_system_info_prl_match)
        *cdma_system_info_prl_match = (gboolean)(self->arg_cdma_system_info_prl_match);
    if (cdma_system_info_p_rev_valid)
        *cdma_system_info_p_rev_valid = (gboolean)(self->arg_cdma_system_info_p_rev_valid);
    if (cdma_system_info_p_rev)
        *cdma_system_info_p_rev = self->arg_cdma_system_info_p_rev;
    if (cdma_system_info_base_station_p_rev_valid)
        *cdma_system_info_base_station_p_rev_valid = (gboolean)(self->arg_cdma_system_info_base_station_p_rev_valid);
    if (cdma_system_info_base_station_p_rev)
        *cdma_system_info_base_station_p_rev = self->arg_cdma_system_info_base_station_p_rev;
    if (cdma_system_info_concurrent_service_support_valid)
        *cdma_system_info_concurrent_service_support_valid = (gboolean)(self->arg_cdma_system_info_concurrent_service_support_valid);
    if (cdma_system_info_concurrent_service_support)
        *cdma_system_info_concurrent_service_support = (gboolean)(self->arg_cdma_system_info_concurrent_service_support);
    if (cdma_system_info_cdma_system_id_valid)
        *cdma_system_info_cdma_system_id_valid = (gboolean)(self->arg_cdma_system_info_cdma_system_id_valid);
    if (cdma_system_info_sid)
        *cdma_system_info_sid = self->arg_cdma_system_info_sid;
    if (cdma_system_info_nid)
        *cdma_system_info_nid = self->arg_cdma_system_info_nid;
    if (cdma_system_info_base_station_info_valid)
        *cdma_system_info_base_station_info_valid = (gboolean)(self->arg_cdma_system_info_base_station_info_valid);
    if (cdma_system_info_base_station_id)
        *cdma_system_info_base_station_id = self->arg_cdma_system_info_base_station_id;
    if (cdma_system_info_base_station_latitude)
        *cdma_system_info_base_station_latitude = self->arg_cdma_system_info_base_station_latitude;
    if (cdma_system_info_base_station_longitude)
        *cdma_system_info_base_station_longitude = self->arg_cdma_system_info_base_station_longitude;
    if (cdma_system_info_packet_zone_valid)
        *cdma_system_info_packet_zone_valid = (gboolean)(self->arg_cdma_system_info_packet_zone_valid);
    if (cdma_system_info_packet_zone)
        *cdma_system_info_packet_zone = self->arg_cdma_system_info_packet_zone;
    if (cdma_system_info_network_id_valid)
        *cdma_system_info_network_id_valid = (gboolean)(self->arg_cdma_system_info_network_id_valid);
    if (cdma_system_info_mcc)
        *cdma_system_info_mcc = self->arg_cdma_system_info_mcc;
    if (cdma_system_info_mnc)
        *cdma_system_info_mnc = self->arg_cdma_system_info_mnc;

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_lte_service_status:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @lte_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @lte_service_status_true_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @lte_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_lte_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *lte_service_status_service_status,
    QmiNasServiceStatus *lte_service_status_true_service_status,
    gboolean *lte_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Service Status' was not found in the message");
        return FALSE;
    }

    if (lte_service_status_service_status)
        *lte_service_status_service_status = (QmiNasServiceStatus)(self->arg_lte_service_status_service_status);
    if (lte_service_status_true_service_status)
        *lte_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_lte_service_status_true_service_status);
    if (lte_service_status_preferred_data_path)
        *lte_service_status_preferred_data_path = (gboolean)(self->arg_lte_service_status_preferred_data_path);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_wcdma_service_status:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @wcdma_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @wcdma_service_status_true_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @wcdma_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'WCDMA Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_wcdma_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *wcdma_service_status_service_status,
    QmiNasServiceStatus *wcdma_service_status_true_service_status,
    gboolean *wcdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (wcdma_service_status_service_status)
        *wcdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_wcdma_service_status_service_status);
    if (wcdma_service_status_true_service_status)
        *wcdma_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_wcdma_service_status_true_service_status);
    if (wcdma_service_status_preferred_data_path)
        *wcdma_service_status_preferred_data_path = (gboolean)(self->arg_wcdma_service_status_preferred_data_path);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_gsm_service_status:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @gsm_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @gsm_service_status_true_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @gsm_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_gsm_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *gsm_service_status_service_status,
    QmiNasServiceStatus *gsm_service_status_true_service_status,
    gboolean *gsm_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Service Status' was not found in the message");
        return FALSE;
    }

    if (gsm_service_status_service_status)
        *gsm_service_status_service_status = (QmiNasServiceStatus)(self->arg_gsm_service_status_service_status);
    if (gsm_service_status_true_service_status)
        *gsm_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_gsm_service_status_true_service_status);
    if (gsm_service_status_preferred_data_path)
        *gsm_service_status_preferred_data_path = (gboolean)(self->arg_gsm_service_status_preferred_data_path);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_hdr_service_status:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @hdr_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @hdr_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'HDR Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_hdr_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *hdr_service_status_service_status,
    gboolean *hdr_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Service Status' was not found in the message");
        return FALSE;
    }

    if (hdr_service_status_service_status)
        *hdr_service_status_service_status = (QmiNasServiceStatus)(self->arg_hdr_service_status_service_status);
    if (hdr_service_status_preferred_data_path)
        *hdr_service_status_preferred_data_path = (gboolean)(self->arg_hdr_service_status_preferred_data_path);

    return TRUE;
}

/**
 * qmi_message_nas_get_system_info_output_get_cdma_service_status:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 * @cdma_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @cdma_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_system_info_output_get_cdma_service_status (
    QmiMessageNasGetSystemInfoOutput *self,
    QmiNasServiceStatus *cdma_service_status_service_status,
    gboolean *cdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (cdma_service_status_service_status)
        *cdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_cdma_service_status_service_status);
    if (cdma_service_status_preferred_data_path)
        *cdma_service_status_preferred_data_path = (gboolean)(self->arg_cdma_service_status_preferred_data_path);

    return TRUE;
}

GType
qmi_message_nas_get_system_info_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSystemInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_system_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_system_info_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_get_system_info_output_ref:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasGetSystemInfoOutput *
qmi_message_nas_get_system_info_output_ref (QmiMessageNasGetSystemInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_get_system_info_output_unref:
 * @self: a #QmiMessageNasGetSystemInfoOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_get_system_info_output_unref (QmiMessageNasGetSystemInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetSystemInfoOutput, self);
    }
}

static gboolean
qmi_message_nas_get_system_info_output_sim_reject_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'SIM Reject Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'SIM Reject Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_sim_reject_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_sim_reject_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_SIM_REJECT_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_sim_reject_state_get_string ((QmiNasSimRejectState)tmp));
#elif defined  __QMI_NAS_SIM_REJECT_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_sim_reject_state_build_string_from_mask ((QmiNasSimRejectState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasSimRejectState
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'SIM Reject Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_lte_embms_coverage_info_support_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE eMBMS Coverage Info Support' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE eMBMS Coverage Info Support' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_lte_embms_coverage_info_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_lte_embms_coverage_info_support_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE eMBMS Coverage Info Support' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_td_scdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 3;
    expected_len += 3;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'TD SCDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'TD SCDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_td_scdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_td_scdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_info_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_cause = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " network_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_call_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_call_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_service_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_service = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_parameter_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_parameter_id = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_broadcast_support_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_broadcast_support = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cs_call_barring_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cs_call_barring_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_call_barring_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_call_barring_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cipher_domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cipher_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'TD SCDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_td_scdma_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'TD SCDMA Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'TD SCDMA Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_td_scdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_td_scdma_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " true_service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'TD SCDMA Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_wcdma_cipher_domain_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'WCDMA Cipher Domain' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'WCDMA Cipher Domain' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_wcdma_cipher_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_wcdma_cipher_domain_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'WCDMA Cipher Domain' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_gsm_cipher_domain_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM Cipher Domain' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM Cipher Domain' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_gsm_cipher_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_gsm_cipher_domain_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM Cipher Domain' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_lte_voice_support_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE Voice Support' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE Voice Support' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_lte_voice_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_lte_voice_support_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE Voice Support' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_wcdma_call_barring_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'WCDMA Call Barring Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'WCDMA Call Barring Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_wcdma_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_wcdma_call_barring_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " cs_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'WCDMA Call Barring Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_gsm_call_barring_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM Call Barring Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM Call Barring Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_gsm_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_gsm_call_barring_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " cs_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM Call Barring Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_additional_lte_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Additional LTE System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Additional LTE System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_additional_lte_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_additional_lte_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " geo_system_index = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Additional LTE System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_additional_wcdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Additional WCDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Additional WCDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_additional_wcdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_additional_wcdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " geo_system_index = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_broadcast_support = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Additional WCDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_additional_gsm_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Additional GSM System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Additional GSM System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_additional_gsm_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_additional_gsm_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " geo_system_index = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_broadcast_support = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Additional GSM System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_additional_hdr_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Additional HDR System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Additional HDR System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_additional_hdr_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_additional_hdr_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " geo_system_index = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Additional HDR System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_additional_cdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Additional CDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Additional CDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_additional_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_additional_cdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " geo_system_index = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_period = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Additional CDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_lte_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 3;
    expected_len += 3;
    expected_len += 1;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_lte_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_lte_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_info_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_cause = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " network_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " tac_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " tac = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_wcdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 3;
    expected_len += 3;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'WCDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'WCDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_wcdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_wcdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_info_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_cause = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " network_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_call_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_call_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_service_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_service = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " primary_scrambling_code_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " primary_scrambling_code = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'WCDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_gsm_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 3;
    expected_len += 3;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_gsm_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_gsm_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_info_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_cause = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " network_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " egprs_support_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " egprs_support = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " dtm_support_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " dtm_support = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_hdr_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 16;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'HDR System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'HDR System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_hdr_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_hdr_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " prl_match_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " prl_match = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " personality_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " personality = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_HDR_PERSONALITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_hdr_personality_get_string ((QmiNasHdrPersonality)tmp));
#elif defined  __QMI_NAS_HDR_PERSONALITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_hdr_personality_build_string_from_mask ((QmiNasHdrPersonality)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasHdrPersonality
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " protocol_revision_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " protocol_revision = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_HDR_PROTOCOL_REVISION_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_hdr_protocol_revision_get_string ((QmiNasHdrProtocolRevision)tmp));
#elif defined  __QMI_NAS_HDR_PROTOCOL_REVISION_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_hdr_protocol_revision_build_string_from_mask ((QmiNasHdrProtocolRevision)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasHdrProtocolRevision
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " is_856_system_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " is_856_system_id = '");

        {
            gchar tmp[17];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                16,
                &tmp[0]);
            tmp[16] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'HDR System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_cdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 2;
    expected_len += 1;
    expected_len += 2;
    expected_len += 4;
    expected_len += 4;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 3;
    expected_len += 3;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_cdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " prl_match_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " prl_match = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " p_rev_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " p_rev = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_p_rev_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_p_rev = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " concurrent_service_support_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " concurrent_service_support = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cdma_system_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " sid = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " nid = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_info_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_id = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_latitude = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_longitude = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " packet_zone_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " packet_zone = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " network_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_lte_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_lte_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_lte_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " true_service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_wcdma_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'WCDMA Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'WCDMA Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_wcdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_wcdma_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " true_service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'WCDMA Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_gsm_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_gsm_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_gsm_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " true_service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_hdr_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'HDR Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'HDR Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_hdr_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_hdr_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'HDR Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_system_info_output_cdma_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_system_info_output_cdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_system_info_output_cdma_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_system_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_system_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_system_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO:
            tlv_type_str = "SIM Reject Info";
            translated_value = qmi_message_nas_get_system_info_output_sim_reject_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT:
            tlv_type_str = "LTE eMBMS Coverage Info Support";
            translated_value = qmi_message_nas_get_system_info_output_lte_embms_coverage_info_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SYSTEM_INFO:
            tlv_type_str = "TD SCDMA System Info";
            translated_value = qmi_message_nas_get_system_info_output_td_scdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS:
            tlv_type_str = "TD SCDMA Service Status";
            translated_value = qmi_message_nas_get_system_info_output_td_scdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN:
            tlv_type_str = "WCDMA Cipher Domain";
            translated_value = qmi_message_nas_get_system_info_output_wcdma_cipher_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN:
            tlv_type_str = "GSM Cipher Domain";
            translated_value = qmi_message_nas_get_system_info_output_gsm_cipher_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT:
            tlv_type_str = "LTE Voice Support";
            translated_value = qmi_message_nas_get_system_info_output_lte_voice_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS:
            tlv_type_str = "WCDMA Call Barring Status";
            translated_value = qmi_message_nas_get_system_info_output_wcdma_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS:
            tlv_type_str = "GSM Call Barring Status";
            translated_value = qmi_message_nas_get_system_info_output_gsm_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO:
            tlv_type_str = "Additional LTE System Info";
            translated_value = qmi_message_nas_get_system_info_output_additional_lte_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO:
            tlv_type_str = "Additional WCDMA System Info";
            translated_value = qmi_message_nas_get_system_info_output_additional_wcdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO:
            tlv_type_str = "Additional GSM System Info";
            translated_value = qmi_message_nas_get_system_info_output_additional_gsm_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO:
            tlv_type_str = "Additional HDR System Info";
            translated_value = qmi_message_nas_get_system_info_output_additional_hdr_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO:
            tlv_type_str = "Additional CDMA System Info";
            translated_value = qmi_message_nas_get_system_info_output_additional_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO:
            tlv_type_str = "LTE System Info";
            translated_value = qmi_message_nas_get_system_info_output_lte_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO:
            tlv_type_str = "WCDMA System Info";
            translated_value = qmi_message_nas_get_system_info_output_wcdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO:
            tlv_type_str = "GSM System Info";
            translated_value = qmi_message_nas_get_system_info_output_gsm_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO:
            tlv_type_str = "HDR System Info";
            translated_value = qmi_message_nas_get_system_info_output_hdr_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO:
            tlv_type_str = "CDMA System Info";
            translated_value = qmi_message_nas_get_system_info_output_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS:
            tlv_type_str = "LTE Service Status";
            translated_value = qmi_message_nas_get_system_info_output_lte_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS:
            tlv_type_str = "WCDMA Service Status";
            translated_value = qmi_message_nas_get_system_info_output_wcdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS:
            tlv_type_str = "GSM Service Status";
            translated_value = qmi_message_nas_get_system_info_output_gsm_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS:
            tlv_type_str = "HDR Service Status";
            translated_value = qmi_message_nas_get_system_info_output_hdr_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS:
            tlv_type_str = "CDMA Service Status";
            translated_value = qmi_message_nas_get_system_info_output_cdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_system_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get System Info\" (0x004D)\n",
                            line_prefix);

    {
        struct message_get_system_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_system_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetSystemInfoOutput *
__qmi_message_nas_get_system_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetSystemInfoOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_GET_SYSTEM_INFO, NULL);

    self = g_slice_new0 (QmiMessageNasGetSystemInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_get_system_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_sim_reject_info_validate (buffer, buffer_len)) {
                self->arg_sim_reject_info_set = TRUE;

                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_sim_reject_info = (QmiNasSimRejectState)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'SIM Reject Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_lte_embms_coverage_info_support_validate (buffer, buffer_len)) {
                self->arg_lte_embms_coverage_info_support_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_embms_coverage_info_support = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE eMBMS Coverage Info Support' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_td_scdma_system_info_validate (buffer, buffer_len)) {
                self->arg_td_scdma_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_lac_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_td_scdma_system_info_lac));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_cid_valid = (gboolean)tmp;
                }
                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_td_scdma_system_info_cid));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_registration_reject_info_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_td_scdma_system_info_registration_reject_cause));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_network_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_td_scdma_system_info_mcc[0]);
                self->arg_td_scdma_system_info_mcc[3] = '\0';
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_td_scdma_system_info_mnc[0]);
                self->arg_td_scdma_system_info_mnc[3] = '\0';
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_hs_call_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_hs_call_status = (QmiNasWcdmaHsService)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_hs_service_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_hs_service = (QmiNasWcdmaHsService)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_cell_parameter_id_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_td_scdma_system_info_cell_parameter_id));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_cell_broadcast_support_valid = (gboolean)tmp;
                }
                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_td_scdma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_cs_call_barring_status_valid = (gboolean)tmp;
                }
                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_td_scdma_system_info_cs_call_barring_status = (QmiNasCallBarringStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_ps_call_barring_status_valid = (gboolean)tmp;
                }
                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_td_scdma_system_info_ps_call_barring_status = (QmiNasCallBarringStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_cipher_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_system_info_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'TD SCDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_td_scdma_service_status_validate (buffer, buffer_len)) {
                self->arg_td_scdma_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_service_status_true_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'TD SCDMA Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_wcdma_cipher_domain_validate (buffer, buffer_len)) {
                self->arg_wcdma_cipher_domain_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'WCDMA Cipher Domain' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_gsm_cipher_domain_validate (buffer, buffer_len)) {
                self->arg_gsm_cipher_domain_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM Cipher Domain' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_lte_voice_support_validate (buffer, buffer_len)) {
                self->arg_lte_voice_support_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_voice_support = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE Voice Support' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_wcdma_call_barring_status_validate (buffer, buffer_len)) {
                self->arg_wcdma_call_barring_status_set = TRUE;

                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_wcdma_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
                }
                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_wcdma_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'WCDMA Call Barring Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_gsm_call_barring_status_validate (buffer, buffer_len)) {
                self->arg_gsm_call_barring_status_set = TRUE;

                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_gsm_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
                }
                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_gsm_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM Call Barring Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_additional_lte_system_info_validate (buffer, buffer_len)) {
                self->arg_additional_lte_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_lte_system_info_geo_system_index));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Additional LTE System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_additional_wcdma_system_info_validate (buffer, buffer_len)) {
                self->arg_additional_wcdma_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_wcdma_system_info_geo_system_index));
                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_additional_wcdma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Additional WCDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_additional_gsm_system_info_validate (buffer, buffer_len)) {
                self->arg_additional_gsm_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_gsm_system_info_geo_system_index));
                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_additional_gsm_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Additional GSM System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_additional_hdr_system_info_validate (buffer, buffer_len)) {
                self->arg_additional_hdr_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_hdr_system_info_geo_system_index));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Additional HDR System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_additional_cdma_system_info_validate (buffer, buffer_len)) {
                self->arg_additional_cdma_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_cdma_system_info_geo_system_index));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_cdma_system_info_registration_period));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Additional CDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_lte_system_info_validate (buffer, buffer_len)) {
                self->arg_lte_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_lac_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_system_info_lac));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_cid_valid = (gboolean)tmp;
                }
                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_system_info_cid));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_registration_reject_info_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_lte_system_info_registration_reject_cause));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_network_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_lte_system_info_mcc[0]);
                self->arg_lte_system_info_mcc[3] = '\0';
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_lte_system_info_mnc[0]);
                self->arg_lte_system_info_mnc[3] = '\0';
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_tac_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_system_info_tac));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_wcdma_system_info_validate (buffer, buffer_len)) {
                self->arg_wcdma_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_lac_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_wcdma_system_info_lac));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_cid_valid = (gboolean)tmp;
                }
                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_wcdma_system_info_cid));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_registration_reject_info_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_wcdma_system_info_registration_reject_cause));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_network_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_wcdma_system_info_mcc[0]);
                self->arg_wcdma_system_info_mcc[3] = '\0';
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_wcdma_system_info_mnc[0]);
                self->arg_wcdma_system_info_mnc[3] = '\0';
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_hs_call_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_hs_call_status = (QmiNasWcdmaHsService)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_hs_service_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_hs_service = (QmiNasWcdmaHsService)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_primary_scrambling_code_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_wcdma_system_info_primary_scrambling_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'WCDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_gsm_system_info_validate (buffer, buffer_len)) {
                self->arg_gsm_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_lac_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_gsm_system_info_lac));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_cid_valid = (gboolean)tmp;
                }
                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_gsm_system_info_cid));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_registration_reject_info_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_gsm_system_info_registration_reject_cause));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_network_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_gsm_system_info_mcc[0]);
                self->arg_gsm_system_info_mcc[3] = '\0';
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_gsm_system_info_mnc[0]);
                self->arg_gsm_system_info_mnc[3] = '\0';
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_egprs_support_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_egprs_support = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_dtm_support_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_dtm_support = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_hdr_system_info_validate (buffer, buffer_len)) {
                self->arg_hdr_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_prl_match_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_prl_match = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_personality_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_personality = (QmiNasHdrPersonality)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_protocol_revision_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_protocol_revision = (QmiNasHdrProtocolRevision)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_is_856_system_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    16,
                    &self->arg_hdr_system_info_is_856_system_id[0]);
                self->arg_hdr_system_info_is_856_system_id[16] = '\0';

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'HDR System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_cdma_system_info_validate (buffer, buffer_len)) {
                self->arg_cdma_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_prl_match_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_prl_match = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_p_rev_valid = (gboolean)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_system_info_p_rev));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_base_station_p_rev_valid = (gboolean)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_system_info_base_station_p_rev));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_concurrent_service_support_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_concurrent_service_support = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_cdma_system_id_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_sid));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_nid));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_base_station_info_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_base_station_id));
                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_base_station_latitude));
                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_base_station_longitude));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_packet_zone_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_packet_zone));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_network_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_cdma_system_info_mcc[0]);
                self->arg_cdma_system_info_mcc[3] = '\0';
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_cdma_system_info_mnc[0]);
                self->arg_cdma_system_info_mnc[3] = '\0';

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_lte_service_status_validate (buffer, buffer_len)) {
                self->arg_lte_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_service_status_true_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_wcdma_service_status_validate (buffer, buffer_len)) {
                self->arg_wcdma_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_service_status_true_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'WCDMA Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_gsm_service_status_validate (buffer, buffer_len)) {
                self->arg_gsm_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_service_status_true_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_hdr_service_status_validate (buffer, buffer_len)) {
                self->arg_hdr_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'HDR Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_system_info_output_cdma_service_status_validate (buffer, buffer_len)) {
                self->arg_cdma_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS System Info */


/* --- Output -- */

struct _QmiIndicationNasSystemInfoOutput {
    volatile gint ref_count;

    /* SIM Reject Info */
    gboolean arg_sim_reject_info_set;
    guint32 arg_sim_reject_info;

    /* LTE eMBMS Coverage Info Support */
    gboolean arg_lte_embms_coverage_info_support_set;
    guint8 arg_lte_embms_coverage_info_support;

    /* TD SCMA System Info */
    gboolean arg_td_scma_system_info_set;
    guint8 arg_td_scma_system_info_domain_valid;
    guint8 arg_td_scma_system_info_domain;
    guint8 arg_td_scma_system_info_service_capability_valid;
    guint8 arg_td_scma_system_info_service_capability;
    guint8 arg_td_scma_system_info_roaming_status_valid;
    guint8 arg_td_scma_system_info_roaming_status;
    guint8 arg_td_scma_system_info_forbidden_valid;
    guint8 arg_td_scma_system_info_forbidden;
    guint8 arg_td_scma_system_info_lac_valid;
    guint16 arg_td_scma_system_info_lac;
    guint8 arg_td_scma_system_info_cid_valid;
    guint32 arg_td_scma_system_info_cid;
    guint8 arg_td_scma_system_info_registration_reject_info_valid;
    guint8 arg_td_scma_system_info_registration_reject_domain;
    guint8 arg_td_scma_system_info_registration_reject_cause;
    guint8 arg_td_scma_system_info_network_id_valid;
    gchar arg_td_scma_system_info_mcc[4];
    gchar arg_td_scma_system_info_mnc[4];
    guint8 arg_td_scma_system_info_hs_call_status_valid;
    guint8 arg_td_scma_system_info_hs_call_status;
    guint8 arg_td_scma_system_info_hs_service_valid;
    guint8 arg_td_scma_system_info_hs_service;
    guint8 arg_td_scma_system_info_cell_parameter_id_valid;
    guint16 arg_td_scma_system_info_cell_parameter_id;
    guint8 arg_td_scma_system_info_cell_broadcast_support_valid;
    guint32 arg_td_scma_system_info_cell_broadcast_support;
    guint8 arg_td_scma_system_info_cs_call_barring_status_valid;
    gint32 arg_td_scma_system_info_cs_call_barring_status;
    guint8 arg_td_scma_system_info_ps_call_barring_status_valid;
    gint32 arg_td_scma_system_info_ps_call_barring_status;
    guint8 arg_td_scma_system_info_cipher_domain_valid;
    guint8 arg_td_scma_system_info_cipher_domain;

    /* TD SCDMA Service Status */
    gboolean arg_td_scdma_service_status_set;
    guint8 arg_td_scdma_service_status_service_status;
    guint8 arg_td_scdma_service_status_true_service_status;
    guint8 arg_td_scdma_service_status_preferred_data_path;

    /* PLMN Not Changed Indication */
    gboolean arg_plmn_not_changed_indication_set;
    guint8 arg_plmn_not_changed_indication;

    /* WCDMA Cipher Domain */
    gboolean arg_wcdma_cipher_domain_set;
    guint8 arg_wcdma_cipher_domain;

    /* GSM Cipher Domain */
    gboolean arg_gsm_cipher_domain_set;
    guint8 arg_gsm_cipher_domain;

    /* LTE Voice Support */
    gboolean arg_lte_voice_support_set;
    guint8 arg_lte_voice_support;

    /* WCDMA Call Barring Status */
    gboolean arg_wcdma_call_barring_status_set;
    gint32 arg_wcdma_call_barring_status_cs_status;
    gint32 arg_wcdma_call_barring_status_ps_status;

    /* GSM Call Barring Status */
    gboolean arg_gsm_call_barring_status_set;
    gint32 arg_gsm_call_barring_status_cs_status;
    gint32 arg_gsm_call_barring_status_ps_status;

    /* Additional LTE System Info */
    gboolean arg_additional_lte_system_info_set;
    guint16 arg_additional_lte_system_info_geo_system_index;

    /* Additional WCDMA System Info */
    gboolean arg_additional_wcdma_system_info_set;
    guint16 arg_additional_wcdma_system_info_geo_system_index;
    guint32 arg_additional_wcdma_system_info_cell_broadcast_support;

    /* Additional GSM System Info */
    gboolean arg_additional_gsm_system_info_set;
    guint16 arg_additional_gsm_system_info_geo_system_index;
    guint32 arg_additional_gsm_system_info_cell_broadcast_support;

    /* Additional HDR System Info */
    gboolean arg_additional_hdr_system_info_set;
    guint16 arg_additional_hdr_system_info_geo_system_index;

    /* Additional CDMA System Info */
    gboolean arg_additional_cdma_system_info_set;
    guint16 arg_additional_cdma_system_info_geo_system_index;
    guint16 arg_additional_cdma_system_info_registration_period;

    /* LTE System Info */
    gboolean arg_lte_system_info_set;
    guint8 arg_lte_system_info_domain_valid;
    guint8 arg_lte_system_info_domain;
    guint8 arg_lte_system_info_service_capability_valid;
    guint8 arg_lte_system_info_service_capability;
    guint8 arg_lte_system_info_roaming_status_valid;
    guint8 arg_lte_system_info_roaming_status;
    guint8 arg_lte_system_info_forbidden_valid;
    guint8 arg_lte_system_info_forbidden;
    guint8 arg_lte_system_info_lac_valid;
    guint16 arg_lte_system_info_lac;
    guint8 arg_lte_system_info_cid_valid;
    guint32 arg_lte_system_info_cid;
    guint8 arg_lte_system_info_registration_reject_info_valid;
    guint8 arg_lte_system_info_registration_reject_domain;
    guint8 arg_lte_system_info_registration_reject_cause;
    guint8 arg_lte_system_info_network_id_valid;
    gchar arg_lte_system_info_mcc[4];
    gchar arg_lte_system_info_mnc[4];
    guint8 arg_lte_system_info_tac_valid;
    guint16 arg_lte_system_info_tac;

    /* WCDMA System Info */
    gboolean arg_wcdma_system_info_set;
    guint8 arg_wcdma_system_info_domain_valid;
    guint8 arg_wcdma_system_info_domain;
    guint8 arg_wcdma_system_info_service_capability_valid;
    guint8 arg_wcdma_system_info_service_capability;
    guint8 arg_wcdma_system_info_roaming_status_valid;
    guint8 arg_wcdma_system_info_roaming_status;
    guint8 arg_wcdma_system_info_forbidden_valid;
    guint8 arg_wcdma_system_info_forbidden;
    guint8 arg_wcdma_system_info_lac_valid;
    guint16 arg_wcdma_system_info_lac;
    guint8 arg_wcdma_system_info_cid_valid;
    guint32 arg_wcdma_system_info_cid;
    guint8 arg_wcdma_system_info_registration_reject_info_valid;
    guint8 arg_wcdma_system_info_registration_reject_domain;
    guint8 arg_wcdma_system_info_registration_reject_cause;
    guint8 arg_wcdma_system_info_network_id_valid;
    gchar arg_wcdma_system_info_mcc[4];
    gchar arg_wcdma_system_info_mnc[4];
    guint8 arg_wcdma_system_info_hs_call_status_valid;
    guint8 arg_wcdma_system_info_hs_call_status;
    guint8 arg_wcdma_system_info_hs_service_valid;
    guint8 arg_wcdma_system_info_hs_service;
    guint8 arg_wcdma_system_info_primary_scrambling_code_valid;
    guint16 arg_wcdma_system_info_primary_scrambling_code;

    /* GSM System Info */
    gboolean arg_gsm_system_info_set;
    guint8 arg_gsm_system_info_domain_valid;
    guint8 arg_gsm_system_info_domain;
    guint8 arg_gsm_system_info_service_capability_valid;
    guint8 arg_gsm_system_info_service_capability;
    guint8 arg_gsm_system_info_roaming_status_valid;
    guint8 arg_gsm_system_info_roaming_status;
    guint8 arg_gsm_system_info_forbidden_valid;
    guint8 arg_gsm_system_info_forbidden;
    guint8 arg_gsm_system_info_lac_valid;
    guint16 arg_gsm_system_info_lac;
    guint8 arg_gsm_system_info_cid_valid;
    guint32 arg_gsm_system_info_cid;
    guint8 arg_gsm_system_info_registration_reject_info_valid;
    guint8 arg_gsm_system_info_registration_reject_domain;
    guint8 arg_gsm_system_info_registration_reject_cause;
    guint8 arg_gsm_system_info_network_id_valid;
    gchar arg_gsm_system_info_mcc[4];
    gchar arg_gsm_system_info_mnc[4];
    guint8 arg_gsm_system_info_egprs_support_valid;
    guint8 arg_gsm_system_info_egprs_support;
    guint8 arg_gsm_system_info_dtm_support_valid;
    guint8 arg_gsm_system_info_dtm_support;

    /* HDR System Info */
    gboolean arg_hdr_system_info_set;
    guint8 arg_hdr_system_info_domain_valid;
    guint8 arg_hdr_system_info_domain;
    guint8 arg_hdr_system_info_service_capability_valid;
    guint8 arg_hdr_system_info_service_capability;
    guint8 arg_hdr_system_info_roaming_status_valid;
    guint8 arg_hdr_system_info_roaming_status;
    guint8 arg_hdr_system_info_forbidden_valid;
    guint8 arg_hdr_system_info_forbidden;
    guint8 arg_hdr_system_info_prl_match_valid;
    guint8 arg_hdr_system_info_prl_match;
    guint8 arg_hdr_system_info_personality_valid;
    guint8 arg_hdr_system_info_personality;
    guint8 arg_hdr_system_info_protocol_revision_valid;
    guint8 arg_hdr_system_info_protocol_revision;
    guint8 arg_hdr_system_info_is_856_system_id_valid;
    gchar arg_hdr_system_info_is_856_system_id[17];

    /* CDMA System Info */
    gboolean arg_cdma_system_info_set;
    guint8 arg_cdma_system_info_domain_valid;
    guint8 arg_cdma_system_info_domain;
    guint8 arg_cdma_system_info_service_capability_valid;
    guint8 arg_cdma_system_info_service_capability;
    guint8 arg_cdma_system_info_roaming_status_valid;
    guint8 arg_cdma_system_info_roaming_status;
    guint8 arg_cdma_system_info_forbidden_valid;
    guint8 arg_cdma_system_info_forbidden;
    guint8 arg_cdma_system_info_prl_match_valid;
    guint8 arg_cdma_system_info_prl_match;
    guint8 arg_cdma_system_info_p_rev_valid;
    guint8 arg_cdma_system_info_p_rev;
    guint8 arg_cdma_system_info_base_station_p_rev_valid;
    guint8 arg_cdma_system_info_base_station_p_rev;
    guint8 arg_cdma_system_info_concurrent_service_support_valid;
    guint8 arg_cdma_system_info_concurrent_service_support;
    guint8 arg_cdma_system_info_cdma_system_id_valid;
    guint16 arg_cdma_system_info_sid;
    guint16 arg_cdma_system_info_nid;
    guint8 arg_cdma_system_info_base_station_info_valid;
    guint16 arg_cdma_system_info_base_station_id;
    gint32 arg_cdma_system_info_base_station_latitude;
    gint32 arg_cdma_system_info_base_station_longitude;
    guint8 arg_cdma_system_info_packet_zone_valid;
    guint16 arg_cdma_system_info_packet_zone;
    guint8 arg_cdma_system_info_network_id_valid;
    gchar arg_cdma_system_info_mcc[4];
    gchar arg_cdma_system_info_mnc[4];

    /* LTE Service Status */
    gboolean arg_lte_service_status_set;
    guint8 arg_lte_service_status_service_status;
    guint8 arg_lte_service_status_true_service_status;
    guint8 arg_lte_service_status_preferred_data_path;

    /* WCDMA Service Status */
    gboolean arg_wcdma_service_status_set;
    guint8 arg_wcdma_service_status_service_status;
    guint8 arg_wcdma_service_status_true_service_status;
    guint8 arg_wcdma_service_status_preferred_data_path;

    /* GSM Service Status */
    gboolean arg_gsm_service_status_set;
    guint8 arg_gsm_service_status_service_status;
    guint8 arg_gsm_service_status_true_service_status;
    guint8 arg_gsm_service_status_preferred_data_path;

    /* HDR Service Status */
    gboolean arg_hdr_service_status_set;
    guint8 arg_hdr_service_status_service_status;
    guint8 arg_hdr_service_status_preferred_data_path;

    /* CDMA Service Status */
    gboolean arg_cdma_service_status_set;
    guint8 arg_cdma_service_status_service_status;
    guint8 arg_cdma_service_status_preferred_data_path;
};

#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO 0x28
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT 0x27
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCMA_SYSTEM_INFO 0x26
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS 0x25
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION 0x24
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN 0x23
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN 0x22
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT 0x21
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS 0x20
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS 0x1F
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO 0x1E
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO 0x1D
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO 0x1C
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO 0x1B
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO 0x1A
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO 0x19
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO 0x18
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO 0x17
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO 0x16
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO 0x15
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS 0x14
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS 0x13
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS 0x12
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS 0x11
#define QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS 0x10

/**
 * qmi_indication_nas_system_info_output_get_sim_reject_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @sim_reject_info: a placeholder for the output #QmiNasSimRejectState, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'SIM Reject Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_sim_reject_info (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasSimRejectState *sim_reject_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sim_reject_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SIM Reject Info' was not found in the message");
        return FALSE;
    }

    if (sim_reject_info)
        *sim_reject_info = (QmiNasSimRejectState)(self->arg_sim_reject_info);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_lte_embms_coverage_info_support:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @lte_embms_coverage_info_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE eMBMS Coverage Info Support' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_lte_embms_coverage_info_support (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *lte_embms_coverage_info_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_embms_coverage_info_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE eMBMS Coverage Info Support' was not found in the message");
        return FALSE;
    }

    if (lte_embms_coverage_info_support)
        *lte_embms_coverage_info_support = (gboolean)(self->arg_lte_embms_coverage_info_support);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_td_scma_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @td_scma_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @td_scma_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @td_scma_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @td_scma_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_lac_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_lac: a placeholder for the output #guint16, or %NULL if not required.
 * @td_scma_system_info_cid_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_cid: a placeholder for the output #guint32, or %NULL if not required.
 * @td_scma_system_info_registration_reject_info_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_registration_reject_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @td_scma_system_info_registration_reject_cause: a placeholder for the output #guint8, or %NULL if not required.
 * @td_scma_system_info_network_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_mcc: a placeholder for the output constant string, or %NULL if not required.
 * @td_scma_system_info_mnc: a placeholder for the output constant string, or %NULL if not required.
 * @td_scma_system_info_hs_call_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_hs_call_status: a placeholder for the output #QmiNasWcdmaHsService, or %NULL if not required.
 * @td_scma_system_info_hs_service_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_hs_service: a placeholder for the output #QmiNasWcdmaHsService, or %NULL if not required.
 * @td_scma_system_info_cell_parameter_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_cell_parameter_id: a placeholder for the output #guint16, or %NULL if not required.
 * @td_scma_system_info_cell_broadcast_support_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_cell_broadcast_support: a placeholder for the output #QmiNasCellBroadcastCapability, or %NULL if not required.
 * @td_scma_system_info_cs_call_barring_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_cs_call_barring_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @td_scma_system_info_ps_call_barring_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_ps_call_barring_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @td_scma_system_info_cipher_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @td_scma_system_info_cipher_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'TD SCMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_td_scma_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *td_scma_system_info_domain_valid,
    QmiNasNetworkServiceDomain *td_scma_system_info_domain,
    gboolean *td_scma_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *td_scma_system_info_service_capability,
    gboolean *td_scma_system_info_roaming_status_valid,
    QmiNasRoamingStatus *td_scma_system_info_roaming_status,
    gboolean *td_scma_system_info_forbidden_valid,
    gboolean *td_scma_system_info_forbidden,
    gboolean *td_scma_system_info_lac_valid,
    guint16 *td_scma_system_info_lac,
    gboolean *td_scma_system_info_cid_valid,
    guint32 *td_scma_system_info_cid,
    gboolean *td_scma_system_info_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *td_scma_system_info_registration_reject_domain,
    guint8 *td_scma_system_info_registration_reject_cause,
    gboolean *td_scma_system_info_network_id_valid,
    const gchar **td_scma_system_info_mcc,
    const gchar **td_scma_system_info_mnc,
    gboolean *td_scma_system_info_hs_call_status_valid,
    QmiNasWcdmaHsService *td_scma_system_info_hs_call_status,
    gboolean *td_scma_system_info_hs_service_valid,
    QmiNasWcdmaHsService *td_scma_system_info_hs_service,
    gboolean *td_scma_system_info_cell_parameter_id_valid,
    guint16 *td_scma_system_info_cell_parameter_id,
    gboolean *td_scma_system_info_cell_broadcast_support_valid,
    QmiNasCellBroadcastCapability *td_scma_system_info_cell_broadcast_support,
    gboolean *td_scma_system_info_cs_call_barring_status_valid,
    QmiNasCallBarringStatus *td_scma_system_info_cs_call_barring_status,
    gboolean *td_scma_system_info_ps_call_barring_status_valid,
    QmiNasCallBarringStatus *td_scma_system_info_ps_call_barring_status,
    gboolean *td_scma_system_info_cipher_domain_valid,
    QmiNasNetworkServiceDomain *td_scma_system_info_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCMA System Info' was not found in the message");
        return FALSE;
    }

    if (td_scma_system_info_domain_valid)
        *td_scma_system_info_domain_valid = (gboolean)(self->arg_td_scma_system_info_domain_valid);
    if (td_scma_system_info_domain)
        *td_scma_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scma_system_info_domain);
    if (td_scma_system_info_service_capability_valid)
        *td_scma_system_info_service_capability_valid = (gboolean)(self->arg_td_scma_system_info_service_capability_valid);
    if (td_scma_system_info_service_capability)
        *td_scma_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_td_scma_system_info_service_capability);
    if (td_scma_system_info_roaming_status_valid)
        *td_scma_system_info_roaming_status_valid = (gboolean)(self->arg_td_scma_system_info_roaming_status_valid);
    if (td_scma_system_info_roaming_status)
        *td_scma_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_td_scma_system_info_roaming_status);
    if (td_scma_system_info_forbidden_valid)
        *td_scma_system_info_forbidden_valid = (gboolean)(self->arg_td_scma_system_info_forbidden_valid);
    if (td_scma_system_info_forbidden)
        *td_scma_system_info_forbidden = (gboolean)(self->arg_td_scma_system_info_forbidden);
    if (td_scma_system_info_lac_valid)
        *td_scma_system_info_lac_valid = (gboolean)(self->arg_td_scma_system_info_lac_valid);
    if (td_scma_system_info_lac)
        *td_scma_system_info_lac = self->arg_td_scma_system_info_lac;
    if (td_scma_system_info_cid_valid)
        *td_scma_system_info_cid_valid = (gboolean)(self->arg_td_scma_system_info_cid_valid);
    if (td_scma_system_info_cid)
        *td_scma_system_info_cid = self->arg_td_scma_system_info_cid;
    if (td_scma_system_info_registration_reject_info_valid)
        *td_scma_system_info_registration_reject_info_valid = (gboolean)(self->arg_td_scma_system_info_registration_reject_info_valid);
    if (td_scma_system_info_registration_reject_domain)
        *td_scma_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scma_system_info_registration_reject_domain);
    if (td_scma_system_info_registration_reject_cause)
        *td_scma_system_info_registration_reject_cause = self->arg_td_scma_system_info_registration_reject_cause;
    if (td_scma_system_info_network_id_valid)
        *td_scma_system_info_network_id_valid = (gboolean)(self->arg_td_scma_system_info_network_id_valid);
    if (td_scma_system_info_mcc)
        *td_scma_system_info_mcc = self->arg_td_scma_system_info_mcc;
    if (td_scma_system_info_mnc)
        *td_scma_system_info_mnc = self->arg_td_scma_system_info_mnc;
    if (td_scma_system_info_hs_call_status_valid)
        *td_scma_system_info_hs_call_status_valid = (gboolean)(self->arg_td_scma_system_info_hs_call_status_valid);
    if (td_scma_system_info_hs_call_status)
        *td_scma_system_info_hs_call_status = (QmiNasWcdmaHsService)(self->arg_td_scma_system_info_hs_call_status);
    if (td_scma_system_info_hs_service_valid)
        *td_scma_system_info_hs_service_valid = (gboolean)(self->arg_td_scma_system_info_hs_service_valid);
    if (td_scma_system_info_hs_service)
        *td_scma_system_info_hs_service = (QmiNasWcdmaHsService)(self->arg_td_scma_system_info_hs_service);
    if (td_scma_system_info_cell_parameter_id_valid)
        *td_scma_system_info_cell_parameter_id_valid = (gboolean)(self->arg_td_scma_system_info_cell_parameter_id_valid);
    if (td_scma_system_info_cell_parameter_id)
        *td_scma_system_info_cell_parameter_id = self->arg_td_scma_system_info_cell_parameter_id;
    if (td_scma_system_info_cell_broadcast_support_valid)
        *td_scma_system_info_cell_broadcast_support_valid = (gboolean)(self->arg_td_scma_system_info_cell_broadcast_support_valid);
    if (td_scma_system_info_cell_broadcast_support)
        *td_scma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_td_scma_system_info_cell_broadcast_support);
    if (td_scma_system_info_cs_call_barring_status_valid)
        *td_scma_system_info_cs_call_barring_status_valid = (gboolean)(self->arg_td_scma_system_info_cs_call_barring_status_valid);
    if (td_scma_system_info_cs_call_barring_status)
        *td_scma_system_info_cs_call_barring_status = (QmiNasCallBarringStatus)(self->arg_td_scma_system_info_cs_call_barring_status);
    if (td_scma_system_info_ps_call_barring_status_valid)
        *td_scma_system_info_ps_call_barring_status_valid = (gboolean)(self->arg_td_scma_system_info_ps_call_barring_status_valid);
    if (td_scma_system_info_ps_call_barring_status)
        *td_scma_system_info_ps_call_barring_status = (QmiNasCallBarringStatus)(self->arg_td_scma_system_info_ps_call_barring_status);
    if (td_scma_system_info_cipher_domain_valid)
        *td_scma_system_info_cipher_domain_valid = (gboolean)(self->arg_td_scma_system_info_cipher_domain_valid);
    if (td_scma_system_info_cipher_domain)
        *td_scma_system_info_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_td_scma_system_info_cipher_domain);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_td_scdma_service_status:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @td_scdma_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @td_scdma_service_status_true_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @td_scdma_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'TD SCDMA Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_td_scdma_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *td_scdma_service_status_service_status,
    QmiNasServiceStatus *td_scdma_service_status_true_service_status,
    gboolean *td_scdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_td_scdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TD SCDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (td_scdma_service_status_service_status)
        *td_scdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_td_scdma_service_status_service_status);
    if (td_scdma_service_status_true_service_status)
        *td_scdma_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_td_scdma_service_status_true_service_status);
    if (td_scdma_service_status_preferred_data_path)
        *td_scdma_service_status_preferred_data_path = (gboolean)(self->arg_td_scdma_service_status_preferred_data_path);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_plmn_not_changed_indication:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @plmn_not_changed_indication: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PLMN Not Changed Indication' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_plmn_not_changed_indication (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *plmn_not_changed_indication,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_plmn_not_changed_indication_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PLMN Not Changed Indication' was not found in the message");
        return FALSE;
    }

    if (plmn_not_changed_indication)
        *plmn_not_changed_indication = (gboolean)(self->arg_plmn_not_changed_indication);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_wcdma_cipher_domain:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @wcdma_cipher_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'WCDMA Cipher Domain' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_wcdma_cipher_domain (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasNetworkServiceDomain *wcdma_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_cipher_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Cipher Domain' was not found in the message");
        return FALSE;
    }

    if (wcdma_cipher_domain)
        *wcdma_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_cipher_domain);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_gsm_cipher_domain:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @gsm_cipher_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM Cipher Domain' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_gsm_cipher_domain (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasNetworkServiceDomain *gsm_cipher_domain,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_cipher_domain_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Cipher Domain' was not found in the message");
        return FALSE;
    }

    if (gsm_cipher_domain)
        *gsm_cipher_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_cipher_domain);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_lte_voice_support:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @lte_voice_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE Voice Support' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_lte_voice_support (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *lte_voice_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_voice_support_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Voice Support' was not found in the message");
        return FALSE;
    }

    if (lte_voice_support)
        *lte_voice_support = (gboolean)(self->arg_lte_voice_support);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_wcdma_call_barring_status:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @wcdma_call_barring_status_cs_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @wcdma_call_barring_status_ps_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'WCDMA Call Barring Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_wcdma_call_barring_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasCallBarringStatus *wcdma_call_barring_status_cs_status,
    QmiNasCallBarringStatus *wcdma_call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (wcdma_call_barring_status_cs_status)
        *wcdma_call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_wcdma_call_barring_status_cs_status);
    if (wcdma_call_barring_status_ps_status)
        *wcdma_call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_wcdma_call_barring_status_ps_status);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_gsm_call_barring_status:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @gsm_call_barring_status_cs_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @gsm_call_barring_status_ps_status: a placeholder for the output #QmiNasCallBarringStatus, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM Call Barring Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_gsm_call_barring_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasCallBarringStatus *gsm_call_barring_status_cs_status,
    QmiNasCallBarringStatus *gsm_call_barring_status_ps_status,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_call_barring_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Call Barring Status' was not found in the message");
        return FALSE;
    }

    if (gsm_call_barring_status_cs_status)
        *gsm_call_barring_status_cs_status = (QmiNasCallBarringStatus)(self->arg_gsm_call_barring_status_cs_status);
    if (gsm_call_barring_status_ps_status)
        *gsm_call_barring_status_ps_status = (QmiNasCallBarringStatus)(self->arg_gsm_call_barring_status_ps_status);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_additional_lte_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @additional_lte_system_info_geo_system_index: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Additional LTE System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_additional_lte_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    guint16 *additional_lte_system_info_geo_system_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_lte_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional LTE System Info' was not found in the message");
        return FALSE;
    }

    if (additional_lte_system_info_geo_system_index)
        *additional_lte_system_info_geo_system_index = self->arg_additional_lte_system_info_geo_system_index;

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_additional_wcdma_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @additional_wcdma_system_info_geo_system_index: a placeholder for the output #guint16, or %NULL if not required.
 * @additional_wcdma_system_info_cell_broadcast_support: a placeholder for the output #QmiNasCellBroadcastCapability, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Additional WCDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_additional_wcdma_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    guint16 *additional_wcdma_system_info_geo_system_index,
    QmiNasCellBroadcastCapability *additional_wcdma_system_info_cell_broadcast_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_wcdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional WCDMA System Info' was not found in the message");
        return FALSE;
    }

    if (additional_wcdma_system_info_geo_system_index)
        *additional_wcdma_system_info_geo_system_index = self->arg_additional_wcdma_system_info_geo_system_index;
    if (additional_wcdma_system_info_cell_broadcast_support)
        *additional_wcdma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_additional_wcdma_system_info_cell_broadcast_support);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_additional_gsm_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @additional_gsm_system_info_geo_system_index: a placeholder for the output #guint16, or %NULL if not required.
 * @additional_gsm_system_info_cell_broadcast_support: a placeholder for the output #QmiNasCellBroadcastCapability, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Additional GSM System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_additional_gsm_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    guint16 *additional_gsm_system_info_geo_system_index,
    QmiNasCellBroadcastCapability *additional_gsm_system_info_cell_broadcast_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_gsm_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional GSM System Info' was not found in the message");
        return FALSE;
    }

    if (additional_gsm_system_info_geo_system_index)
        *additional_gsm_system_info_geo_system_index = self->arg_additional_gsm_system_info_geo_system_index;
    if (additional_gsm_system_info_cell_broadcast_support)
        *additional_gsm_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)(self->arg_additional_gsm_system_info_cell_broadcast_support);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_additional_hdr_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @additional_hdr_system_info_geo_system_index: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Additional HDR System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_additional_hdr_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    guint16 *additional_hdr_system_info_geo_system_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_hdr_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional HDR System Info' was not found in the message");
        return FALSE;
    }

    if (additional_hdr_system_info_geo_system_index)
        *additional_hdr_system_info_geo_system_index = self->arg_additional_hdr_system_info_geo_system_index;

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_additional_cdma_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @additional_cdma_system_info_geo_system_index: a placeholder for the output #guint16, or %NULL if not required.
 * @additional_cdma_system_info_registration_period: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Additional CDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_additional_cdma_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    guint16 *additional_cdma_system_info_geo_system_index,
    guint16 *additional_cdma_system_info_registration_period,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_additional_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Additional CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (additional_cdma_system_info_geo_system_index)
        *additional_cdma_system_info_geo_system_index = self->arg_additional_cdma_system_info_geo_system_index;
    if (additional_cdma_system_info_registration_period)
        *additional_cdma_system_info_registration_period = self->arg_additional_cdma_system_info_registration_period;

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_lte_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @lte_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @lte_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @lte_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @lte_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_lac_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_lac: a placeholder for the output #guint16, or %NULL if not required.
 * @lte_system_info_cid_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_cid: a placeholder for the output #guint32, or %NULL if not required.
 * @lte_system_info_registration_reject_info_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_registration_reject_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @lte_system_info_registration_reject_cause: a placeholder for the output #guint8, or %NULL if not required.
 * @lte_system_info_network_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_mcc: a placeholder for the output constant string, or %NULL if not required.
 * @lte_system_info_mnc: a placeholder for the output constant string, or %NULL if not required.
 * @lte_system_info_tac_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @lte_system_info_tac: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_lte_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *lte_system_info_domain_valid,
    QmiNasNetworkServiceDomain *lte_system_info_domain,
    gboolean *lte_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *lte_system_info_service_capability,
    gboolean *lte_system_info_roaming_status_valid,
    QmiNasRoamingStatus *lte_system_info_roaming_status,
    gboolean *lte_system_info_forbidden_valid,
    gboolean *lte_system_info_forbidden,
    gboolean *lte_system_info_lac_valid,
    guint16 *lte_system_info_lac,
    gboolean *lte_system_info_cid_valid,
    guint32 *lte_system_info_cid,
    gboolean *lte_system_info_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *lte_system_info_registration_reject_domain,
    guint8 *lte_system_info_registration_reject_cause,
    gboolean *lte_system_info_network_id_valid,
    const gchar **lte_system_info_mcc,
    const gchar **lte_system_info_mnc,
    gboolean *lte_system_info_tac_valid,
    guint16 *lte_system_info_tac,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE System Info' was not found in the message");
        return FALSE;
    }

    if (lte_system_info_domain_valid)
        *lte_system_info_domain_valid = (gboolean)(self->arg_lte_system_info_domain_valid);
    if (lte_system_info_domain)
        *lte_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_domain);
    if (lte_system_info_service_capability_valid)
        *lte_system_info_service_capability_valid = (gboolean)(self->arg_lte_system_info_service_capability_valid);
    if (lte_system_info_service_capability)
        *lte_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_service_capability);
    if (lte_system_info_roaming_status_valid)
        *lte_system_info_roaming_status_valid = (gboolean)(self->arg_lte_system_info_roaming_status_valid);
    if (lte_system_info_roaming_status)
        *lte_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_lte_system_info_roaming_status);
    if (lte_system_info_forbidden_valid)
        *lte_system_info_forbidden_valid = (gboolean)(self->arg_lte_system_info_forbidden_valid);
    if (lte_system_info_forbidden)
        *lte_system_info_forbidden = (gboolean)(self->arg_lte_system_info_forbidden);
    if (lte_system_info_lac_valid)
        *lte_system_info_lac_valid = (gboolean)(self->arg_lte_system_info_lac_valid);
    if (lte_system_info_lac)
        *lte_system_info_lac = self->arg_lte_system_info_lac;
    if (lte_system_info_cid_valid)
        *lte_system_info_cid_valid = (gboolean)(self->arg_lte_system_info_cid_valid);
    if (lte_system_info_cid)
        *lte_system_info_cid = self->arg_lte_system_info_cid;
    if (lte_system_info_registration_reject_info_valid)
        *lte_system_info_registration_reject_info_valid = (gboolean)(self->arg_lte_system_info_registration_reject_info_valid);
    if (lte_system_info_registration_reject_domain)
        *lte_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_lte_system_info_registration_reject_domain);
    if (lte_system_info_registration_reject_cause)
        *lte_system_info_registration_reject_cause = self->arg_lte_system_info_registration_reject_cause;
    if (lte_system_info_network_id_valid)
        *lte_system_info_network_id_valid = (gboolean)(self->arg_lte_system_info_network_id_valid);
    if (lte_system_info_mcc)
        *lte_system_info_mcc = self->arg_lte_system_info_mcc;
    if (lte_system_info_mnc)
        *lte_system_info_mnc = self->arg_lte_system_info_mnc;
    if (lte_system_info_tac_valid)
        *lte_system_info_tac_valid = (gboolean)(self->arg_lte_system_info_tac_valid);
    if (lte_system_info_tac)
        *lte_system_info_tac = self->arg_lte_system_info_tac;

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_wcdma_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @wcdma_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @wcdma_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @wcdma_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @wcdma_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_lac_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_lac: a placeholder for the output #guint16, or %NULL if not required.
 * @wcdma_system_info_cid_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_cid: a placeholder for the output #guint32, or %NULL if not required.
 * @wcdma_system_info_registration_reject_info_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_registration_reject_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @wcdma_system_info_registration_reject_cause: a placeholder for the output #guint8, or %NULL if not required.
 * @wcdma_system_info_network_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_mcc: a placeholder for the output constant string, or %NULL if not required.
 * @wcdma_system_info_mnc: a placeholder for the output constant string, or %NULL if not required.
 * @wcdma_system_info_hs_call_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_hs_call_status: a placeholder for the output #QmiNasWcdmaHsService, or %NULL if not required.
 * @wcdma_system_info_hs_service_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_hs_service: a placeholder for the output #QmiNasWcdmaHsService, or %NULL if not required.
 * @wcdma_system_info_primary_scrambling_code_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @wcdma_system_info_primary_scrambling_code: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'WCDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_wcdma_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *wcdma_system_info_domain_valid,
    QmiNasNetworkServiceDomain *wcdma_system_info_domain,
    gboolean *wcdma_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *wcdma_system_info_service_capability,
    gboolean *wcdma_system_info_roaming_status_valid,
    QmiNasRoamingStatus *wcdma_system_info_roaming_status,
    gboolean *wcdma_system_info_forbidden_valid,
    gboolean *wcdma_system_info_forbidden,
    gboolean *wcdma_system_info_lac_valid,
    guint16 *wcdma_system_info_lac,
    gboolean *wcdma_system_info_cid_valid,
    guint32 *wcdma_system_info_cid,
    gboolean *wcdma_system_info_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *wcdma_system_info_registration_reject_domain,
    guint8 *wcdma_system_info_registration_reject_cause,
    gboolean *wcdma_system_info_network_id_valid,
    const gchar **wcdma_system_info_mcc,
    const gchar **wcdma_system_info_mnc,
    gboolean *wcdma_system_info_hs_call_status_valid,
    QmiNasWcdmaHsService *wcdma_system_info_hs_call_status,
    gboolean *wcdma_system_info_hs_service_valid,
    QmiNasWcdmaHsService *wcdma_system_info_hs_service,
    gboolean *wcdma_system_info_primary_scrambling_code_valid,
    guint16 *wcdma_system_info_primary_scrambling_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA System Info' was not found in the message");
        return FALSE;
    }

    if (wcdma_system_info_domain_valid)
        *wcdma_system_info_domain_valid = (gboolean)(self->arg_wcdma_system_info_domain_valid);
    if (wcdma_system_info_domain)
        *wcdma_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_domain);
    if (wcdma_system_info_service_capability_valid)
        *wcdma_system_info_service_capability_valid = (gboolean)(self->arg_wcdma_system_info_service_capability_valid);
    if (wcdma_system_info_service_capability)
        *wcdma_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_service_capability);
    if (wcdma_system_info_roaming_status_valid)
        *wcdma_system_info_roaming_status_valid = (gboolean)(self->arg_wcdma_system_info_roaming_status_valid);
    if (wcdma_system_info_roaming_status)
        *wcdma_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_wcdma_system_info_roaming_status);
    if (wcdma_system_info_forbidden_valid)
        *wcdma_system_info_forbidden_valid = (gboolean)(self->arg_wcdma_system_info_forbidden_valid);
    if (wcdma_system_info_forbidden)
        *wcdma_system_info_forbidden = (gboolean)(self->arg_wcdma_system_info_forbidden);
    if (wcdma_system_info_lac_valid)
        *wcdma_system_info_lac_valid = (gboolean)(self->arg_wcdma_system_info_lac_valid);
    if (wcdma_system_info_lac)
        *wcdma_system_info_lac = self->arg_wcdma_system_info_lac;
    if (wcdma_system_info_cid_valid)
        *wcdma_system_info_cid_valid = (gboolean)(self->arg_wcdma_system_info_cid_valid);
    if (wcdma_system_info_cid)
        *wcdma_system_info_cid = self->arg_wcdma_system_info_cid;
    if (wcdma_system_info_registration_reject_info_valid)
        *wcdma_system_info_registration_reject_info_valid = (gboolean)(self->arg_wcdma_system_info_registration_reject_info_valid);
    if (wcdma_system_info_registration_reject_domain)
        *wcdma_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_wcdma_system_info_registration_reject_domain);
    if (wcdma_system_info_registration_reject_cause)
        *wcdma_system_info_registration_reject_cause = self->arg_wcdma_system_info_registration_reject_cause;
    if (wcdma_system_info_network_id_valid)
        *wcdma_system_info_network_id_valid = (gboolean)(self->arg_wcdma_system_info_network_id_valid);
    if (wcdma_system_info_mcc)
        *wcdma_system_info_mcc = self->arg_wcdma_system_info_mcc;
    if (wcdma_system_info_mnc)
        *wcdma_system_info_mnc = self->arg_wcdma_system_info_mnc;
    if (wcdma_system_info_hs_call_status_valid)
        *wcdma_system_info_hs_call_status_valid = (gboolean)(self->arg_wcdma_system_info_hs_call_status_valid);
    if (wcdma_system_info_hs_call_status)
        *wcdma_system_info_hs_call_status = (QmiNasWcdmaHsService)(self->arg_wcdma_system_info_hs_call_status);
    if (wcdma_system_info_hs_service_valid)
        *wcdma_system_info_hs_service_valid = (gboolean)(self->arg_wcdma_system_info_hs_service_valid);
    if (wcdma_system_info_hs_service)
        *wcdma_system_info_hs_service = (QmiNasWcdmaHsService)(self->arg_wcdma_system_info_hs_service);
    if (wcdma_system_info_primary_scrambling_code_valid)
        *wcdma_system_info_primary_scrambling_code_valid = (gboolean)(self->arg_wcdma_system_info_primary_scrambling_code_valid);
    if (wcdma_system_info_primary_scrambling_code)
        *wcdma_system_info_primary_scrambling_code = self->arg_wcdma_system_info_primary_scrambling_code;

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_gsm_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @gsm_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @gsm_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @gsm_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @gsm_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_lac_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_lac: a placeholder for the output #guint16, or %NULL if not required.
 * @gsm_system_info_cid_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_cid: a placeholder for the output #guint32, or %NULL if not required.
 * @gsm_system_info_registration_reject_info_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_registration_reject_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @gsm_system_info_registration_reject_cause: a placeholder for the output #guint8, or %NULL if not required.
 * @gsm_system_info_network_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_mcc: a placeholder for the output constant string, or %NULL if not required.
 * @gsm_system_info_mnc: a placeholder for the output constant string, or %NULL if not required.
 * @gsm_system_info_egprs_support_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_egprs_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_dtm_support_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @gsm_system_info_dtm_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_gsm_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *gsm_system_info_domain_valid,
    QmiNasNetworkServiceDomain *gsm_system_info_domain,
    gboolean *gsm_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *gsm_system_info_service_capability,
    gboolean *gsm_system_info_roaming_status_valid,
    QmiNasRoamingStatus *gsm_system_info_roaming_status,
    gboolean *gsm_system_info_forbidden_valid,
    gboolean *gsm_system_info_forbidden,
    gboolean *gsm_system_info_lac_valid,
    guint16 *gsm_system_info_lac,
    gboolean *gsm_system_info_cid_valid,
    guint32 *gsm_system_info_cid,
    gboolean *gsm_system_info_registration_reject_info_valid,
    QmiNasNetworkServiceDomain *gsm_system_info_registration_reject_domain,
    guint8 *gsm_system_info_registration_reject_cause,
    gboolean *gsm_system_info_network_id_valid,
    const gchar **gsm_system_info_mcc,
    const gchar **gsm_system_info_mnc,
    gboolean *gsm_system_info_egprs_support_valid,
    gboolean *gsm_system_info_egprs_support,
    gboolean *gsm_system_info_dtm_support_valid,
    gboolean *gsm_system_info_dtm_support,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM System Info' was not found in the message");
        return FALSE;
    }

    if (gsm_system_info_domain_valid)
        *gsm_system_info_domain_valid = (gboolean)(self->arg_gsm_system_info_domain_valid);
    if (gsm_system_info_domain)
        *gsm_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_domain);
    if (gsm_system_info_service_capability_valid)
        *gsm_system_info_service_capability_valid = (gboolean)(self->arg_gsm_system_info_service_capability_valid);
    if (gsm_system_info_service_capability)
        *gsm_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_service_capability);
    if (gsm_system_info_roaming_status_valid)
        *gsm_system_info_roaming_status_valid = (gboolean)(self->arg_gsm_system_info_roaming_status_valid);
    if (gsm_system_info_roaming_status)
        *gsm_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_gsm_system_info_roaming_status);
    if (gsm_system_info_forbidden_valid)
        *gsm_system_info_forbidden_valid = (gboolean)(self->arg_gsm_system_info_forbidden_valid);
    if (gsm_system_info_forbidden)
        *gsm_system_info_forbidden = (gboolean)(self->arg_gsm_system_info_forbidden);
    if (gsm_system_info_lac_valid)
        *gsm_system_info_lac_valid = (gboolean)(self->arg_gsm_system_info_lac_valid);
    if (gsm_system_info_lac)
        *gsm_system_info_lac = self->arg_gsm_system_info_lac;
    if (gsm_system_info_cid_valid)
        *gsm_system_info_cid_valid = (gboolean)(self->arg_gsm_system_info_cid_valid);
    if (gsm_system_info_cid)
        *gsm_system_info_cid = self->arg_gsm_system_info_cid;
    if (gsm_system_info_registration_reject_info_valid)
        *gsm_system_info_registration_reject_info_valid = (gboolean)(self->arg_gsm_system_info_registration_reject_info_valid);
    if (gsm_system_info_registration_reject_domain)
        *gsm_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)(self->arg_gsm_system_info_registration_reject_domain);
    if (gsm_system_info_registration_reject_cause)
        *gsm_system_info_registration_reject_cause = self->arg_gsm_system_info_registration_reject_cause;
    if (gsm_system_info_network_id_valid)
        *gsm_system_info_network_id_valid = (gboolean)(self->arg_gsm_system_info_network_id_valid);
    if (gsm_system_info_mcc)
        *gsm_system_info_mcc = self->arg_gsm_system_info_mcc;
    if (gsm_system_info_mnc)
        *gsm_system_info_mnc = self->arg_gsm_system_info_mnc;
    if (gsm_system_info_egprs_support_valid)
        *gsm_system_info_egprs_support_valid = (gboolean)(self->arg_gsm_system_info_egprs_support_valid);
    if (gsm_system_info_egprs_support)
        *gsm_system_info_egprs_support = (gboolean)(self->arg_gsm_system_info_egprs_support);
    if (gsm_system_info_dtm_support_valid)
        *gsm_system_info_dtm_support_valid = (gboolean)(self->arg_gsm_system_info_dtm_support_valid);
    if (gsm_system_info_dtm_support)
        *gsm_system_info_dtm_support = (gboolean)(self->arg_gsm_system_info_dtm_support);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_hdr_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @hdr_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @hdr_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @hdr_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @hdr_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_prl_match_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_prl_match: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_personality_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_personality: a placeholder for the output #QmiNasHdrPersonality, or %NULL if not required.
 * @hdr_system_info_protocol_revision_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_protocol_revision: a placeholder for the output #QmiNasHdrProtocolRevision, or %NULL if not required.
 * @hdr_system_info_is_856_system_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @hdr_system_info_is_856_system_id: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'HDR System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_hdr_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *hdr_system_info_domain_valid,
    QmiNasNetworkServiceDomain *hdr_system_info_domain,
    gboolean *hdr_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *hdr_system_info_service_capability,
    gboolean *hdr_system_info_roaming_status_valid,
    QmiNasRoamingStatus *hdr_system_info_roaming_status,
    gboolean *hdr_system_info_forbidden_valid,
    gboolean *hdr_system_info_forbidden,
    gboolean *hdr_system_info_prl_match_valid,
    gboolean *hdr_system_info_prl_match,
    gboolean *hdr_system_info_personality_valid,
    QmiNasHdrPersonality *hdr_system_info_personality,
    gboolean *hdr_system_info_protocol_revision_valid,
    QmiNasHdrProtocolRevision *hdr_system_info_protocol_revision,
    gboolean *hdr_system_info_is_856_system_id_valid,
    const gchar **hdr_system_info_is_856_system_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR System Info' was not found in the message");
        return FALSE;
    }

    if (hdr_system_info_domain_valid)
        *hdr_system_info_domain_valid = (gboolean)(self->arg_hdr_system_info_domain_valid);
    if (hdr_system_info_domain)
        *hdr_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_hdr_system_info_domain);
    if (hdr_system_info_service_capability_valid)
        *hdr_system_info_service_capability_valid = (gboolean)(self->arg_hdr_system_info_service_capability_valid);
    if (hdr_system_info_service_capability)
        *hdr_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_hdr_system_info_service_capability);
    if (hdr_system_info_roaming_status_valid)
        *hdr_system_info_roaming_status_valid = (gboolean)(self->arg_hdr_system_info_roaming_status_valid);
    if (hdr_system_info_roaming_status)
        *hdr_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_hdr_system_info_roaming_status);
    if (hdr_system_info_forbidden_valid)
        *hdr_system_info_forbidden_valid = (gboolean)(self->arg_hdr_system_info_forbidden_valid);
    if (hdr_system_info_forbidden)
        *hdr_system_info_forbidden = (gboolean)(self->arg_hdr_system_info_forbidden);
    if (hdr_system_info_prl_match_valid)
        *hdr_system_info_prl_match_valid = (gboolean)(self->arg_hdr_system_info_prl_match_valid);
    if (hdr_system_info_prl_match)
        *hdr_system_info_prl_match = (gboolean)(self->arg_hdr_system_info_prl_match);
    if (hdr_system_info_personality_valid)
        *hdr_system_info_personality_valid = (gboolean)(self->arg_hdr_system_info_personality_valid);
    if (hdr_system_info_personality)
        *hdr_system_info_personality = (QmiNasHdrPersonality)(self->arg_hdr_system_info_personality);
    if (hdr_system_info_protocol_revision_valid)
        *hdr_system_info_protocol_revision_valid = (gboolean)(self->arg_hdr_system_info_protocol_revision_valid);
    if (hdr_system_info_protocol_revision)
        *hdr_system_info_protocol_revision = (QmiNasHdrProtocolRevision)(self->arg_hdr_system_info_protocol_revision);
    if (hdr_system_info_is_856_system_id_valid)
        *hdr_system_info_is_856_system_id_valid = (gboolean)(self->arg_hdr_system_info_is_856_system_id_valid);
    if (hdr_system_info_is_856_system_id)
        *hdr_system_info_is_856_system_id = self->arg_hdr_system_info_is_856_system_id;

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_cdma_system_info:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @cdma_system_info_domain_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_domain: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @cdma_system_info_service_capability_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_service_capability: a placeholder for the output #QmiNasNetworkServiceDomain, or %NULL if not required.
 * @cdma_system_info_roaming_status_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_roaming_status: a placeholder for the output #QmiNasRoamingStatus, or %NULL if not required.
 * @cdma_system_info_forbidden_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_forbidden: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_prl_match_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_prl_match: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_p_rev_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_p_rev: a placeholder for the output #guint8, or %NULL if not required.
 * @cdma_system_info_base_station_p_rev_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_base_station_p_rev: a placeholder for the output #guint8, or %NULL if not required.
 * @cdma_system_info_concurrent_service_support_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_concurrent_service_support: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_cdma_system_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_sid: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_info_nid: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_info_base_station_info_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_base_station_id: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_info_base_station_latitude: a placeholder for the output #gint32, or %NULL if not required.
 * @cdma_system_info_base_station_longitude: a placeholder for the output #gint32, or %NULL if not required.
 * @cdma_system_info_packet_zone_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_packet_zone: a placeholder for the output #guint16, or %NULL if not required.
 * @cdma_system_info_network_id_valid: a placeholder for the output #gboolean, or %NULL if not required.
 * @cdma_system_info_mcc: a placeholder for the output constant string, or %NULL if not required.
 * @cdma_system_info_mnc: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA System Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_cdma_system_info (
    QmiIndicationNasSystemInfoOutput *self,
    gboolean *cdma_system_info_domain_valid,
    QmiNasNetworkServiceDomain *cdma_system_info_domain,
    gboolean *cdma_system_info_service_capability_valid,
    QmiNasNetworkServiceDomain *cdma_system_info_service_capability,
    gboolean *cdma_system_info_roaming_status_valid,
    QmiNasRoamingStatus *cdma_system_info_roaming_status,
    gboolean *cdma_system_info_forbidden_valid,
    gboolean *cdma_system_info_forbidden,
    gboolean *cdma_system_info_prl_match_valid,
    gboolean *cdma_system_info_prl_match,
    gboolean *cdma_system_info_p_rev_valid,
    guint8 *cdma_system_info_p_rev,
    gboolean *cdma_system_info_base_station_p_rev_valid,
    guint8 *cdma_system_info_base_station_p_rev,
    gboolean *cdma_system_info_concurrent_service_support_valid,
    gboolean *cdma_system_info_concurrent_service_support,
    gboolean *cdma_system_info_cdma_system_id_valid,
    guint16 *cdma_system_info_sid,
    guint16 *cdma_system_info_nid,
    gboolean *cdma_system_info_base_station_info_valid,
    guint16 *cdma_system_info_base_station_id,
    gint32 *cdma_system_info_base_station_latitude,
    gint32 *cdma_system_info_base_station_longitude,
    gboolean *cdma_system_info_packet_zone_valid,
    guint16 *cdma_system_info_packet_zone,
    gboolean *cdma_system_info_network_id_valid,
    const gchar **cdma_system_info_mcc,
    const gchar **cdma_system_info_mnc,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_system_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA System Info' was not found in the message");
        return FALSE;
    }

    if (cdma_system_info_domain_valid)
        *cdma_system_info_domain_valid = (gboolean)(self->arg_cdma_system_info_domain_valid);
    if (cdma_system_info_domain)
        *cdma_system_info_domain = (QmiNasNetworkServiceDomain)(self->arg_cdma_system_info_domain);
    if (cdma_system_info_service_capability_valid)
        *cdma_system_info_service_capability_valid = (gboolean)(self->arg_cdma_system_info_service_capability_valid);
    if (cdma_system_info_service_capability)
        *cdma_system_info_service_capability = (QmiNasNetworkServiceDomain)(self->arg_cdma_system_info_service_capability);
    if (cdma_system_info_roaming_status_valid)
        *cdma_system_info_roaming_status_valid = (gboolean)(self->arg_cdma_system_info_roaming_status_valid);
    if (cdma_system_info_roaming_status)
        *cdma_system_info_roaming_status = (QmiNasRoamingStatus)(self->arg_cdma_system_info_roaming_status);
    if (cdma_system_info_forbidden_valid)
        *cdma_system_info_forbidden_valid = (gboolean)(self->arg_cdma_system_info_forbidden_valid);
    if (cdma_system_info_forbidden)
        *cdma_system_info_forbidden = (gboolean)(self->arg_cdma_system_info_forbidden);
    if (cdma_system_info_prl_match_valid)
        *cdma_system_info_prl_match_valid = (gboolean)(self->arg_cdma_system_info_prl_match_valid);
    if (cdma_system_info_prl_match)
        *cdma_system_info_prl_match = (gboolean)(self->arg_cdma_system_info_prl_match);
    if (cdma_system_info_p_rev_valid)
        *cdma_system_info_p_rev_valid = (gboolean)(self->arg_cdma_system_info_p_rev_valid);
    if (cdma_system_info_p_rev)
        *cdma_system_info_p_rev = self->arg_cdma_system_info_p_rev;
    if (cdma_system_info_base_station_p_rev_valid)
        *cdma_system_info_base_station_p_rev_valid = (gboolean)(self->arg_cdma_system_info_base_station_p_rev_valid);
    if (cdma_system_info_base_station_p_rev)
        *cdma_system_info_base_station_p_rev = self->arg_cdma_system_info_base_station_p_rev;
    if (cdma_system_info_concurrent_service_support_valid)
        *cdma_system_info_concurrent_service_support_valid = (gboolean)(self->arg_cdma_system_info_concurrent_service_support_valid);
    if (cdma_system_info_concurrent_service_support)
        *cdma_system_info_concurrent_service_support = (gboolean)(self->arg_cdma_system_info_concurrent_service_support);
    if (cdma_system_info_cdma_system_id_valid)
        *cdma_system_info_cdma_system_id_valid = (gboolean)(self->arg_cdma_system_info_cdma_system_id_valid);
    if (cdma_system_info_sid)
        *cdma_system_info_sid = self->arg_cdma_system_info_sid;
    if (cdma_system_info_nid)
        *cdma_system_info_nid = self->arg_cdma_system_info_nid;
    if (cdma_system_info_base_station_info_valid)
        *cdma_system_info_base_station_info_valid = (gboolean)(self->arg_cdma_system_info_base_station_info_valid);
    if (cdma_system_info_base_station_id)
        *cdma_system_info_base_station_id = self->arg_cdma_system_info_base_station_id;
    if (cdma_system_info_base_station_latitude)
        *cdma_system_info_base_station_latitude = self->arg_cdma_system_info_base_station_latitude;
    if (cdma_system_info_base_station_longitude)
        *cdma_system_info_base_station_longitude = self->arg_cdma_system_info_base_station_longitude;
    if (cdma_system_info_packet_zone_valid)
        *cdma_system_info_packet_zone_valid = (gboolean)(self->arg_cdma_system_info_packet_zone_valid);
    if (cdma_system_info_packet_zone)
        *cdma_system_info_packet_zone = self->arg_cdma_system_info_packet_zone;
    if (cdma_system_info_network_id_valid)
        *cdma_system_info_network_id_valid = (gboolean)(self->arg_cdma_system_info_network_id_valid);
    if (cdma_system_info_mcc)
        *cdma_system_info_mcc = self->arg_cdma_system_info_mcc;
    if (cdma_system_info_mnc)
        *cdma_system_info_mnc = self->arg_cdma_system_info_mnc;

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_lte_service_status:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @lte_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @lte_service_status_true_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @lte_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_lte_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *lte_service_status_service_status,
    QmiNasServiceStatus *lte_service_status_true_service_status,
    gboolean *lte_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Service Status' was not found in the message");
        return FALSE;
    }

    if (lte_service_status_service_status)
        *lte_service_status_service_status = (QmiNasServiceStatus)(self->arg_lte_service_status_service_status);
    if (lte_service_status_true_service_status)
        *lte_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_lte_service_status_true_service_status);
    if (lte_service_status_preferred_data_path)
        *lte_service_status_preferred_data_path = (gboolean)(self->arg_lte_service_status_preferred_data_path);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_wcdma_service_status:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @wcdma_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @wcdma_service_status_true_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @wcdma_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'WCDMA Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_wcdma_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *wcdma_service_status_service_status,
    QmiNasServiceStatus *wcdma_service_status_true_service_status,
    gboolean *wcdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (wcdma_service_status_service_status)
        *wcdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_wcdma_service_status_service_status);
    if (wcdma_service_status_true_service_status)
        *wcdma_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_wcdma_service_status_true_service_status);
    if (wcdma_service_status_preferred_data_path)
        *wcdma_service_status_preferred_data_path = (gboolean)(self->arg_wcdma_service_status_preferred_data_path);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_gsm_service_status:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @gsm_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @gsm_service_status_true_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @gsm_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_gsm_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *gsm_service_status_service_status,
    QmiNasServiceStatus *gsm_service_status_true_service_status,
    gboolean *gsm_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Service Status' was not found in the message");
        return FALSE;
    }

    if (gsm_service_status_service_status)
        *gsm_service_status_service_status = (QmiNasServiceStatus)(self->arg_gsm_service_status_service_status);
    if (gsm_service_status_true_service_status)
        *gsm_service_status_true_service_status = (QmiNasServiceStatus)(self->arg_gsm_service_status_true_service_status);
    if (gsm_service_status_preferred_data_path)
        *gsm_service_status_preferred_data_path = (gboolean)(self->arg_gsm_service_status_preferred_data_path);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_hdr_service_status:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @hdr_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @hdr_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'HDR Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_hdr_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *hdr_service_status_service_status,
    gboolean *hdr_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Service Status' was not found in the message");
        return FALSE;
    }

    if (hdr_service_status_service_status)
        *hdr_service_status_service_status = (QmiNasServiceStatus)(self->arg_hdr_service_status_service_status);
    if (hdr_service_status_preferred_data_path)
        *hdr_service_status_preferred_data_path = (gboolean)(self->arg_hdr_service_status_preferred_data_path);

    return TRUE;
}

/**
 * qmi_indication_nas_system_info_output_get_cdma_service_status:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 * @cdma_service_status_service_status: a placeholder for the output #QmiNasServiceStatus, or %NULL if not required.
 * @cdma_service_status_preferred_data_path: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA Service Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_system_info_output_get_cdma_service_status (
    QmiIndicationNasSystemInfoOutput *self,
    QmiNasServiceStatus *cdma_service_status_service_status,
    gboolean *cdma_service_status_preferred_data_path,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_service_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Service Status' was not found in the message");
        return FALSE;
    }

    if (cdma_service_status_service_status)
        *cdma_service_status_service_status = (QmiNasServiceStatus)(self->arg_cdma_service_status_service_status);
    if (cdma_service_status_preferred_data_path)
        *cdma_service_status_preferred_data_path = (gboolean)(self->arg_cdma_service_status_preferred_data_path);

    return TRUE;
}

GType
qmi_indication_nas_system_info_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasSystemInfoOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_system_info_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_system_info_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_indication_nas_system_info_output_ref:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiIndicationNasSystemInfoOutput *
qmi_indication_nas_system_info_output_ref (QmiIndicationNasSystemInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_indication_nas_system_info_output_unref:
 * @self: a #QmiIndicationNasSystemInfoOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_indication_nas_system_info_output_unref (QmiIndicationNasSystemInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiIndicationNasSystemInfoOutput, self);
    }
}

static gboolean
qmi_indication_nas_system_info_output_sim_reject_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'SIM Reject Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'SIM Reject Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_sim_reject_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_sim_reject_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_SIM_REJECT_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_sim_reject_state_get_string ((QmiNasSimRejectState)tmp));
#elif defined  __QMI_NAS_SIM_REJECT_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_sim_reject_state_build_string_from_mask ((QmiNasSimRejectState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasSimRejectState
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'SIM Reject Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_lte_embms_coverage_info_support_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE eMBMS Coverage Info Support' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE eMBMS Coverage Info Support' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_lte_embms_coverage_info_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_lte_embms_coverage_info_support_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE eMBMS Coverage Info Support' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_td_scma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 3;
    expected_len += 3;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'TD SCMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'TD SCMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_td_scma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_td_scma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_info_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_cause = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " network_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_call_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_call_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_service_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_service = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_parameter_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_parameter_id = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_broadcast_support_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_broadcast_support = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cs_call_barring_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cs_call_barring_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_call_barring_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_call_barring_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cipher_domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cipher_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'TD SCMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_td_scdma_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'TD SCDMA Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'TD SCDMA Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_td_scdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_td_scdma_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " true_service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'TD SCDMA Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_plmn_not_changed_indication_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PLMN Not Changed Indication' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PLMN Not Changed Indication' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_plmn_not_changed_indication_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_plmn_not_changed_indication_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PLMN Not Changed Indication' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_wcdma_cipher_domain_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'WCDMA Cipher Domain' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'WCDMA Cipher Domain' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_wcdma_cipher_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_wcdma_cipher_domain_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'WCDMA Cipher Domain' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_gsm_cipher_domain_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM Cipher Domain' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM Cipher Domain' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_gsm_cipher_domain_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_gsm_cipher_domain_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM Cipher Domain' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_lte_voice_support_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE Voice Support' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE Voice Support' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_lte_voice_support_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_lte_voice_support_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE Voice Support' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_wcdma_call_barring_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'WCDMA Call Barring Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'WCDMA Call Barring Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_wcdma_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_wcdma_call_barring_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " cs_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'WCDMA Call Barring Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_gsm_call_barring_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM Call Barring Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM Call Barring Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_gsm_call_barring_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_gsm_call_barring_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " cs_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ps_status = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CALL_BARRING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_call_barring_status_get_string ((QmiNasCallBarringStatus)tmp));
#elif defined  __QMI_NAS_CALL_BARRING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_call_barring_status_build_string_from_mask ((QmiNasCallBarringStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCallBarringStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM Call Barring Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_additional_lte_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Additional LTE System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Additional LTE System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_additional_lte_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_additional_lte_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " geo_system_index = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Additional LTE System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_additional_wcdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Additional WCDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Additional WCDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_additional_wcdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_additional_wcdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " geo_system_index = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_broadcast_support = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Additional WCDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_additional_gsm_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Additional GSM System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Additional GSM System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_additional_gsm_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_additional_gsm_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " geo_system_index = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cell_broadcast_support = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_cell_broadcast_capability_get_string ((QmiNasCellBroadcastCapability)tmp));
#elif defined  __QMI_NAS_CELL_BROADCAST_CAPABILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_cell_broadcast_capability_build_string_from_mask ((QmiNasCellBroadcastCapability)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasCellBroadcastCapability
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Additional GSM System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_additional_hdr_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Additional HDR System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Additional HDR System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_additional_hdr_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_additional_hdr_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " geo_system_index = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Additional HDR System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_additional_cdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Additional CDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Additional CDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_additional_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_additional_cdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " geo_system_index = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_period = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Additional CDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_lte_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 3;
    expected_len += 3;
    expected_len += 1;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_lte_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_lte_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_info_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_cause = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " network_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " tac_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " tac = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_wcdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 3;
    expected_len += 3;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'WCDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'WCDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_wcdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_wcdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_info_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_cause = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " network_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_call_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_call_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_service_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " hs_service = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_wcdma_hs_service_get_string ((QmiNasWcdmaHsService)tmp));
#elif defined  __QMI_NAS_WCDMA_HS_SERVICE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_wcdma_hs_service_build_string_from_mask ((QmiNasWcdmaHsService)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasWcdmaHsService
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " primary_scrambling_code_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " primary_scrambling_code = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'WCDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_gsm_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 3;
    expected_len += 3;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_gsm_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_gsm_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lac = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cid = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_info_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " registration_reject_cause = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " network_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " egprs_support_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " egprs_support = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " dtm_support_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " dtm_support = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_hdr_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 16;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'HDR System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'HDR System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_hdr_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_hdr_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " prl_match_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " prl_match = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " personality_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " personality = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_HDR_PERSONALITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_hdr_personality_get_string ((QmiNasHdrPersonality)tmp));
#elif defined  __QMI_NAS_HDR_PERSONALITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_hdr_personality_build_string_from_mask ((QmiNasHdrPersonality)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasHdrPersonality
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " protocol_revision_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " protocol_revision = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_HDR_PROTOCOL_REVISION_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_hdr_protocol_revision_get_string ((QmiNasHdrProtocolRevision)tmp));
#elif defined  __QMI_NAS_HDR_PROTOCOL_REVISION_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_hdr_protocol_revision_build_string_from_mask ((QmiNasHdrProtocolRevision)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasHdrProtocolRevision
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " is_856_system_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " is_856_system_id = '");

        {
            gchar tmp[17];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                16,
                &tmp[0]);
            tmp[16] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'HDR System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_cdma_system_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 2;
    expected_len += 1;
    expected_len += 2;
    expected_len += 4;
    expected_len += 4;
    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 3;
    expected_len += 3;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA System Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA System Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_cdma_system_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_cdma_system_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " domain_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " domain = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_network_service_domain_get_string ((QmiNasNetworkServiceDomain)tmp));
#elif defined  __QMI_NAS_NETWORK_SERVICE_DOMAIN_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_network_service_domain_build_string_from_mask ((QmiNasNetworkServiceDomain)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasNetworkServiceDomain
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " roaming_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_ROAMING_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_roaming_status_get_string ((QmiNasRoamingStatus)tmp));
#elif defined  __QMI_NAS_ROAMING_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_roaming_status_build_string_from_mask ((QmiNasRoamingStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasRoamingStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " forbidden = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " prl_match_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " prl_match = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " p_rev_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " p_rev = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_p_rev_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_p_rev = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " concurrent_service_support_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " concurrent_service_support = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " cdma_system_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " sid = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " nid = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_info_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_id = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_latitude = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " base_station_longitude = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " packet_zone_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " packet_zone = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " network_id_valid = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mcc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mnc = '");

        {
            gchar tmp[4];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                3,
                &tmp[0]);
            tmp[3] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA System Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_lte_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_lte_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_lte_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " true_service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_wcdma_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'WCDMA Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'WCDMA Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_wcdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_wcdma_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " true_service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'WCDMA Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_gsm_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_gsm_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_gsm_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " true_service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_hdr_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'HDR Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'HDR Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_hdr_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_hdr_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'HDR Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_system_info_output_cdma_service_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA Service Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA Service Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_system_info_output_cdma_service_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_system_info_output_cdma_service_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_SERVICE_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_service_status_get_string ((QmiNasServiceStatus)tmp));
#elif defined  __QMI_NAS_SERVICE_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_service_status_build_string_from_mask ((QmiNasServiceStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasServiceStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " preferred_data_path = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA Service Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct indication_system_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_system_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_system_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    {
        switch (type) {
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO:
            tlv_type_str = "SIM Reject Info";
            translated_value = qmi_indication_nas_system_info_output_sim_reject_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT:
            tlv_type_str = "LTE eMBMS Coverage Info Support";
            translated_value = qmi_indication_nas_system_info_output_lte_embms_coverage_info_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCMA_SYSTEM_INFO:
            tlv_type_str = "TD SCMA System Info";
            translated_value = qmi_indication_nas_system_info_output_td_scma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS:
            tlv_type_str = "TD SCDMA Service Status";
            translated_value = qmi_indication_nas_system_info_output_td_scdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION:
            tlv_type_str = "PLMN Not Changed Indication";
            translated_value = qmi_indication_nas_system_info_output_plmn_not_changed_indication_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN:
            tlv_type_str = "WCDMA Cipher Domain";
            translated_value = qmi_indication_nas_system_info_output_wcdma_cipher_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN:
            tlv_type_str = "GSM Cipher Domain";
            translated_value = qmi_indication_nas_system_info_output_gsm_cipher_domain_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT:
            tlv_type_str = "LTE Voice Support";
            translated_value = qmi_indication_nas_system_info_output_lte_voice_support_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS:
            tlv_type_str = "WCDMA Call Barring Status";
            translated_value = qmi_indication_nas_system_info_output_wcdma_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS:
            tlv_type_str = "GSM Call Barring Status";
            translated_value = qmi_indication_nas_system_info_output_gsm_call_barring_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO:
            tlv_type_str = "Additional LTE System Info";
            translated_value = qmi_indication_nas_system_info_output_additional_lte_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO:
            tlv_type_str = "Additional WCDMA System Info";
            translated_value = qmi_indication_nas_system_info_output_additional_wcdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO:
            tlv_type_str = "Additional GSM System Info";
            translated_value = qmi_indication_nas_system_info_output_additional_gsm_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO:
            tlv_type_str = "Additional HDR System Info";
            translated_value = qmi_indication_nas_system_info_output_additional_hdr_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO:
            tlv_type_str = "Additional CDMA System Info";
            translated_value = qmi_indication_nas_system_info_output_additional_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO:
            tlv_type_str = "LTE System Info";
            translated_value = qmi_indication_nas_system_info_output_lte_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO:
            tlv_type_str = "WCDMA System Info";
            translated_value = qmi_indication_nas_system_info_output_wcdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO:
            tlv_type_str = "GSM System Info";
            translated_value = qmi_indication_nas_system_info_output_gsm_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO:
            tlv_type_str = "HDR System Info";
            translated_value = qmi_indication_nas_system_info_output_hdr_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO:
            tlv_type_str = "CDMA System Info";
            translated_value = qmi_indication_nas_system_info_output_cdma_system_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS:
            tlv_type_str = "LTE Service Status";
            translated_value = qmi_indication_nas_system_info_output_lte_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS:
            tlv_type_str = "WCDMA Service Status";
            translated_value = qmi_indication_nas_system_info_output_wcdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS:
            tlv_type_str = "GSM Service Status";
            translated_value = qmi_indication_nas_system_info_output_gsm_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS:
            tlv_type_str = "HDR Service Status";
            translated_value = qmi_indication_nas_system_info_output_hdr_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS:
            tlv_type_str = "CDMA Service Status";
            translated_value = qmi_indication_nas_system_info_output_cdma_service_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
indication_system_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"System Info\" (0x004E)\n",
                            line_prefix);

    {
        struct indication_system_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_system_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasSystemInfoOutput *
__qmi_indication_nas_system_info_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasSystemInfoOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_INDICATION_NAS_SYSTEM_INFO, NULL);

    self = g_slice_new0 (QmiIndicationNasSystemInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_SIM_REJECT_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_sim_reject_info_validate (buffer, buffer_len)) {
                self->arg_sim_reject_info_set = TRUE;

                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_sim_reject_info = (QmiNasSimRejectState)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'SIM Reject Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_EMBMS_COVERAGE_INFO_SUPPORT,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_lte_embms_coverage_info_support_validate (buffer, buffer_len)) {
                self->arg_lte_embms_coverage_info_support_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_embms_coverage_info_support = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE eMBMS Coverage Info Support' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_td_scma_system_info_validate (buffer, buffer_len)) {
                self->arg_td_scma_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_lac_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_td_scma_system_info_lac));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_cid_valid = (gboolean)tmp;
                }
                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_td_scma_system_info_cid));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_registration_reject_info_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_td_scma_system_info_registration_reject_cause));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_network_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_td_scma_system_info_mcc[0]);
                self->arg_td_scma_system_info_mcc[3] = '\0';
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_td_scma_system_info_mnc[0]);
                self->arg_td_scma_system_info_mnc[3] = '\0';
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_hs_call_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_hs_call_status = (QmiNasWcdmaHsService)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_hs_service_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_hs_service = (QmiNasWcdmaHsService)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_cell_parameter_id_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_td_scma_system_info_cell_parameter_id));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_cell_broadcast_support_valid = (gboolean)tmp;
                }
                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_td_scma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_cs_call_barring_status_valid = (gboolean)tmp;
                }
                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_td_scma_system_info_cs_call_barring_status = (QmiNasCallBarringStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_ps_call_barring_status_valid = (gboolean)tmp;
                }
                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_td_scma_system_info_ps_call_barring_status = (QmiNasCallBarringStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_cipher_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scma_system_info_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'TD SCMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_TD_SCDMA_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_td_scdma_service_status_validate (buffer, buffer_len)) {
                self->arg_td_scdma_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_service_status_true_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_td_scdma_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'TD SCDMA Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_PLMN_NOT_CHANGED_INDICATION,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_plmn_not_changed_indication_validate (buffer, buffer_len)) {
                self->arg_plmn_not_changed_indication_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_plmn_not_changed_indication = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PLMN Not Changed Indication' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CIPHER_DOMAIN,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_wcdma_cipher_domain_validate (buffer, buffer_len)) {
                self->arg_wcdma_cipher_domain_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'WCDMA Cipher Domain' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CIPHER_DOMAIN,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_gsm_cipher_domain_validate (buffer, buffer_len)) {
                self->arg_gsm_cipher_domain_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_cipher_domain = (QmiNasNetworkServiceDomain)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM Cipher Domain' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_VOICE_SUPPORT,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_lte_voice_support_validate (buffer, buffer_len)) {
                self->arg_lte_voice_support_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_voice_support = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE Voice Support' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_CALL_BARRING_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_wcdma_call_barring_status_validate (buffer, buffer_len)) {
                self->arg_wcdma_call_barring_status_set = TRUE;

                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_wcdma_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
                }
                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_wcdma_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'WCDMA Call Barring Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_CALL_BARRING_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_gsm_call_barring_status_validate (buffer, buffer_len)) {
                self->arg_gsm_call_barring_status_set = TRUE;

                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_gsm_call_barring_status_cs_status = (QmiNasCallBarringStatus)tmp;
                }
                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_gsm_call_barring_status_ps_status = (QmiNasCallBarringStatus)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM Call Barring Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_LTE_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_additional_lte_system_info_validate (buffer, buffer_len)) {
                self->arg_additional_lte_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_lte_system_info_geo_system_index));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Additional LTE System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_WCDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_additional_wcdma_system_info_validate (buffer, buffer_len)) {
                self->arg_additional_wcdma_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_wcdma_system_info_geo_system_index));
                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_additional_wcdma_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Additional WCDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_GSM_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_additional_gsm_system_info_validate (buffer, buffer_len)) {
                self->arg_additional_gsm_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_gsm_system_info_geo_system_index));
                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_additional_gsm_system_info_cell_broadcast_support = (QmiNasCellBroadcastCapability)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Additional GSM System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_HDR_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_additional_hdr_system_info_validate (buffer, buffer_len)) {
                self->arg_additional_hdr_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_hdr_system_info_geo_system_index));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Additional HDR System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_ADDITIONAL_CDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_additional_cdma_system_info_validate (buffer, buffer_len)) {
                self->arg_additional_cdma_system_info_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_cdma_system_info_geo_system_index));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_additional_cdma_system_info_registration_period));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Additional CDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_lte_system_info_validate (buffer, buffer_len)) {
                self->arg_lte_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_lac_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_system_info_lac));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_cid_valid = (gboolean)tmp;
                }
                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_system_info_cid));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_registration_reject_info_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_lte_system_info_registration_reject_cause));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_network_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_lte_system_info_mcc[0]);
                self->arg_lte_system_info_mcc[3] = '\0';
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_lte_system_info_mnc[0]);
                self->arg_lte_system_info_mnc[3] = '\0';
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_system_info_tac_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_system_info_tac));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_wcdma_system_info_validate (buffer, buffer_len)) {
                self->arg_wcdma_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_lac_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_wcdma_system_info_lac));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_cid_valid = (gboolean)tmp;
                }
                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_wcdma_system_info_cid));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_registration_reject_info_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_wcdma_system_info_registration_reject_cause));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_network_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_wcdma_system_info_mcc[0]);
                self->arg_wcdma_system_info_mcc[3] = '\0';
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_wcdma_system_info_mnc[0]);
                self->arg_wcdma_system_info_mnc[3] = '\0';
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_hs_call_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_hs_call_status = (QmiNasWcdmaHsService)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_hs_service_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_hs_service = (QmiNasWcdmaHsService)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_system_info_primary_scrambling_code_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_wcdma_system_info_primary_scrambling_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'WCDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_gsm_system_info_validate (buffer, buffer_len)) {
                self->arg_gsm_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_lac_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_gsm_system_info_lac));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_cid_valid = (gboolean)tmp;
                }
                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_gsm_system_info_cid));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_registration_reject_info_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_registration_reject_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_gsm_system_info_registration_reject_cause));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_network_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_gsm_system_info_mcc[0]);
                self->arg_gsm_system_info_mcc[3] = '\0';
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_gsm_system_info_mnc[0]);
                self->arg_gsm_system_info_mnc[3] = '\0';
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_egprs_support_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_egprs_support = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_dtm_support_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_system_info_dtm_support = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_hdr_system_info_validate (buffer, buffer_len)) {
                self->arg_hdr_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_prl_match_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_prl_match = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_personality_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_personality = (QmiNasHdrPersonality)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_protocol_revision_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_protocol_revision = (QmiNasHdrProtocolRevision)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_system_info_is_856_system_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    16,
                    &self->arg_hdr_system_info_is_856_system_id[0]);
                self->arg_hdr_system_info_is_856_system_id[16] = '\0';

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'HDR System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SYSTEM_INFO,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_cdma_system_info_validate (buffer, buffer_len)) {
                self->arg_cdma_system_info_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_domain_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_domain = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_service_capability_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_service_capability = (QmiNasNetworkServiceDomain)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_roaming_status_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_roaming_status = (QmiNasRoamingStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_forbidden_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_forbidden = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_prl_match_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_prl_match = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_p_rev_valid = (gboolean)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_system_info_p_rev));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_base_station_p_rev_valid = (gboolean)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_system_info_base_station_p_rev));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_concurrent_service_support_valid = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_concurrent_service_support = (gboolean)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_cdma_system_id_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_sid));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_nid));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_base_station_info_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_base_station_id));
                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_base_station_latitude));
                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_base_station_longitude));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_packet_zone_valid = (gboolean)tmp;
                }
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_system_info_packet_zone));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_system_info_network_id_valid = (gboolean)tmp;
                }
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_cdma_system_info_mcc[0]);
                self->arg_cdma_system_info_mcc[3] = '\0';
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    3,
                    &self->arg_cdma_system_info_mnc[0]);
                self->arg_cdma_system_info_mnc[3] = '\0';

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA System Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_LTE_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_lte_service_status_validate (buffer, buffer_len)) {
                self->arg_lte_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_service_status_true_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_lte_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_WCDMA_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_wcdma_service_status_validate (buffer, buffer_len)) {
                self->arg_wcdma_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_service_status_true_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wcdma_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'WCDMA Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_GSM_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_gsm_service_status_validate (buffer, buffer_len)) {
                self->arg_gsm_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_service_status_true_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_gsm_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_HDR_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_hdr_service_status_validate (buffer, buffer_len)) {
                self->arg_hdr_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'HDR Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SYSTEM_INFO_OUTPUT_TLV_CDMA_SERVICE_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_system_info_output_cdma_service_status_validate (buffer, buffer_len)) {
                self->arg_cdma_service_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_service_status_service_status = (QmiNasServiceStatus)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_cdma_service_status_preferred_data_path = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA Service Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get Signal Info */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_signal_info_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_SIGNAL_INFO);

    return self;
}

/* --- Output -- */

struct _QmiMessageNasGetSignalInfoOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* TDMA Signal Strength */
    gboolean arg_tdma_signal_strength_set;
    gint8 arg_tdma_signal_strength;

    /* LTE Signal Strength */
    gboolean arg_lte_signal_strength_set;
    gint8 arg_lte_signal_strength_rssi;
    gint8 arg_lte_signal_strength_rsrq;
    gint16 arg_lte_signal_strength_rsrp;
    gint16 arg_lte_signal_strength_snr;

    /* WCDMA Signal Strength */
    gboolean arg_wcdma_signal_strength_set;
    gint8 arg_wcdma_signal_strength_rssi;
    gint16 arg_wcdma_signal_strength_ecio;

    /* GSM Signal Strength */
    gboolean arg_gsm_signal_strength_set;
    gint8 arg_gsm_signal_strength;

    /* HDR Signal Strength */
    gboolean arg_hdr_signal_strength_set;
    gint8 arg_hdr_signal_strength_rssi;
    gint16 arg_hdr_signal_strength_ecio;
    guint8 arg_hdr_signal_strength_sinr;
    gint32 arg_hdr_signal_strength_io;

    /* CDMA Signal Strength */
    gboolean arg_cdma_signal_strength_set;
    gint8 arg_cdma_signal_strength_rssi;
    gint16 arg_cdma_signal_strength_ecio;
};

#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH 0x15
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH 0x14
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH 0x13
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH 0x12
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH 0x11
#define QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH 0x10

/**
 * qmi_message_nas_get_signal_info_output_get_result:
 * @self: a QmiMessageNasGetSignalInfoOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_get_signal_info_output_get_result (
    QmiMessageNasGetSignalInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_nas_get_signal_info_output_get_tdma_signal_strength:
 * @self: a #QmiMessageNasGetSignalInfoOutput.
 * @tdma_signal_strength: a placeholder for the output #gint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'TDMA Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_info_output_get_tdma_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *tdma_signal_strength,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_tdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (tdma_signal_strength)
        *tdma_signal_strength = self->arg_tdma_signal_strength;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_info_output_get_lte_signal_strength:
 * @self: a #QmiMessageNasGetSignalInfoOutput.
 * @lte_signal_strength_rssi: a placeholder for the output #gint8, or %NULL if not required.
 * @lte_signal_strength_rsrq: a placeholder for the output #gint8, or %NULL if not required.
 * @lte_signal_strength_rsrp: a placeholder for the output #gint16, or %NULL if not required.
 * @lte_signal_strength_snr: a placeholder for the output #gint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_info_output_get_lte_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *lte_signal_strength_rssi,
    gint8 *lte_signal_strength_rsrq,
    gint16 *lte_signal_strength_rsrp,
    gint16 *lte_signal_strength_snr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Signal Strength' was not found in the message");
        return FALSE;
    }

    if (lte_signal_strength_rssi)
        *lte_signal_strength_rssi = self->arg_lte_signal_strength_rssi;
    if (lte_signal_strength_rsrq)
        *lte_signal_strength_rsrq = self->arg_lte_signal_strength_rsrq;
    if (lte_signal_strength_rsrp)
        *lte_signal_strength_rsrp = self->arg_lte_signal_strength_rsrp;
    if (lte_signal_strength_snr)
        *lte_signal_strength_snr = self->arg_lte_signal_strength_snr;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_info_output_get_wcdma_signal_strength:
 * @self: a #QmiMessageNasGetSignalInfoOutput.
 * @wcdma_signal_strength_rssi: a placeholder for the output #gint8, or %NULL if not required.
 * @wcdma_signal_strength_ecio: a placeholder for the output #gint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'WCDMA Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_info_output_get_wcdma_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *wcdma_signal_strength_rssi,
    gint16 *wcdma_signal_strength_ecio,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (wcdma_signal_strength_rssi)
        *wcdma_signal_strength_rssi = self->arg_wcdma_signal_strength_rssi;
    if (wcdma_signal_strength_ecio)
        *wcdma_signal_strength_ecio = self->arg_wcdma_signal_strength_ecio;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_info_output_get_gsm_signal_strength:
 * @self: a #QmiMessageNasGetSignalInfoOutput.
 * @gsm_signal_strength: a placeholder for the output #gint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_info_output_get_gsm_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *gsm_signal_strength,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Signal Strength' was not found in the message");
        return FALSE;
    }

    if (gsm_signal_strength)
        *gsm_signal_strength = self->arg_gsm_signal_strength;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_info_output_get_hdr_signal_strength:
 * @self: a #QmiMessageNasGetSignalInfoOutput.
 * @hdr_signal_strength_rssi: a placeholder for the output #gint8, or %NULL if not required.
 * @hdr_signal_strength_ecio: a placeholder for the output #gint16, or %NULL if not required.
 * @hdr_signal_strength_sinr: a placeholder for the output #QmiNasEvdoSinrLevel, or %NULL if not required.
 * @hdr_signal_strength_io: a placeholder for the output #gint32, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'HDR Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_info_output_get_hdr_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *hdr_signal_strength_rssi,
    gint16 *hdr_signal_strength_ecio,
    QmiNasEvdoSinrLevel *hdr_signal_strength_sinr,
    gint32 *hdr_signal_strength_io,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Signal Strength' was not found in the message");
        return FALSE;
    }

    if (hdr_signal_strength_rssi)
        *hdr_signal_strength_rssi = self->arg_hdr_signal_strength_rssi;
    if (hdr_signal_strength_ecio)
        *hdr_signal_strength_ecio = self->arg_hdr_signal_strength_ecio;
    if (hdr_signal_strength_sinr)
        *hdr_signal_strength_sinr = (QmiNasEvdoSinrLevel)(self->arg_hdr_signal_strength_sinr);
    if (hdr_signal_strength_io)
        *hdr_signal_strength_io = self->arg_hdr_signal_strength_io;

    return TRUE;
}

/**
 * qmi_message_nas_get_signal_info_output_get_cdma_signal_strength:
 * @self: a #QmiMessageNasGetSignalInfoOutput.
 * @cdma_signal_strength_rssi: a placeholder for the output #gint8, or %NULL if not required.
 * @cdma_signal_strength_ecio: a placeholder for the output #gint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_signal_info_output_get_cdma_signal_strength (
    QmiMessageNasGetSignalInfoOutput *self,
    gint8 *cdma_signal_strength_rssi,
    gint16 *cdma_signal_strength_ecio,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (cdma_signal_strength_rssi)
        *cdma_signal_strength_rssi = self->arg_cdma_signal_strength_rssi;
    if (cdma_signal_strength_ecio)
        *cdma_signal_strength_ecio = self->arg_cdma_signal_strength_ecio;

    return TRUE;
}

GType
qmi_message_nas_get_signal_info_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetSignalInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_signal_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_signal_info_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_get_signal_info_output_ref:
 * @self: a #QmiMessageNasGetSignalInfoOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasGetSignalInfoOutput *
qmi_message_nas_get_signal_info_output_ref (QmiMessageNasGetSignalInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_get_signal_info_output_unref:
 * @self: a #QmiMessageNasGetSignalInfoOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_get_signal_info_output_unref (QmiMessageNasGetSignalInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasGetSignalInfoOutput, self);
    }
}

static gboolean
qmi_message_nas_get_signal_info_output_tdma_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'TDMA Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'TDMA Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_info_output_tdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_info_output_tdma_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'TDMA Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_info_output_lte_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_info_output_lte_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_info_output_lte_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rssi = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " rsrq = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " rsrp = '");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " snr = '");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_info_output_wcdma_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'WCDMA Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'WCDMA Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_info_output_wcdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_info_output_wcdma_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rssi = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ecio = '");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'WCDMA Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_info_output_gsm_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_info_output_gsm_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_info_output_gsm_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_info_output_hdr_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'HDR Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'HDR Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_info_output_hdr_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_info_output_hdr_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rssi = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ecio = '");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " sinr = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_evdo_sinr_level_get_string ((QmiNasEvdoSinrLevel)tmp));
#elif defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_evdo_sinr_level_build_string_from_mask ((QmiNasEvdoSinrLevel)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasEvdoSinrLevel
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " io = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'HDR Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_get_signal_info_output_cdma_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_signal_info_output_cdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_signal_info_output_cdma_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rssi = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ecio = '");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_signal_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_signal_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_signal_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH:
            tlv_type_str = "TDMA Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_tdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH:
            tlv_type_str = "LTE Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_lte_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH:
            tlv_type_str = "WCDMA Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_wcdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH:
            tlv_type_str = "GSM Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_gsm_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH:
            tlv_type_str = "HDR Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_hdr_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH:
            tlv_type_str = "CDMA Signal Strength";
            translated_value = qmi_message_nas_get_signal_info_output_cdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_signal_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Signal Info\" (0x004F)\n",
                            line_prefix);

    {
        struct message_get_signal_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_signal_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetSignalInfoOutput *
__qmi_message_nas_get_signal_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetSignalInfoOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_GET_SIGNAL_INFO, NULL);

    self = g_slice_new0 (QmiMessageNasGetSignalInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_get_signal_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_info_output_tdma_signal_strength_validate (buffer, buffer_len)) {
                self->arg_tdma_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_tdma_signal_strength));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'TDMA Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_info_output_lte_signal_strength_validate (buffer, buffer_len)) {
                self->arg_lte_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_lte_signal_strength_rssi));
                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_lte_signal_strength_rsrq));
                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_signal_strength_rsrp));
                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_signal_strength_snr));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_info_output_wcdma_signal_strength_validate (buffer, buffer_len)) {
                self->arg_wcdma_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_wcdma_signal_strength_rssi));
                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_wcdma_signal_strength_ecio));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'WCDMA Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_info_output_gsm_signal_strength_validate (buffer, buffer_len)) {
                self->arg_gsm_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_gsm_signal_strength));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_info_output_hdr_signal_strength_validate (buffer, buffer_len)) {
                self->arg_hdr_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_hdr_signal_strength_rssi));
                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_hdr_signal_strength_ecio));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_signal_strength_sinr = (QmiNasEvdoSinrLevel)tmp;
                }
                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_hdr_signal_strength_io));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'HDR Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_signal_info_output_cdma_signal_strength_validate (buffer, buffer_len)) {
                self->arg_cdma_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_signal_strength_rssi));
                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_signal_strength_ecio));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Config Signal Info */


/* --- Input -- */

struct _QmiMessageNasConfigSignalInfoInput {
    volatile gint ref_count;

    /* RSCP Threshold */
    gboolean arg_rscp_threshold_set;
    GArray *arg_rscp_threshold;

    /* LTE Report */
    gboolean arg_lte_report_set;
    guint8 arg_lte_report_rate;
    guint8 arg_lte_report_average_period;

    /* RSRP Threshold */
    gboolean arg_rsrp_threshold_set;
    GArray *arg_rsrp_threshold;

    /* RSRQ Threshold */
    gboolean arg_rsrq_threshold_set;
    GArray *arg_rsrq_threshold;

    /* IO Threshold */
    gboolean arg_io_threshold_set;
    GArray *arg_io_threshold;

    /* LTE SNR Threshold */
    gboolean arg_lte_snr_threshold_set;
    GArray *arg_lte_snr_threshold;

    /* SINR Threshold */
    gboolean arg_sinr_threshold_set;
    GArray *arg_sinr_threshold;

    /* ECIO Threshold */
    gboolean arg_ecio_threshold_set;
    GArray *arg_ecio_threshold;

    /* RSSI Threshold */
    gboolean arg_rssi_threshold_set;
    GArray *arg_rssi_threshold;
};

#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSCP_THRESHOLD 0x18
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_REPORT 0x17
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRP_THRESHOLD 0x16
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRQ_THRESHOLD 0x15
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_IO_THRESHOLD 0x14
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_SNR_THRESHOLD 0x13
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_SINR_THRESHOLD 0x12
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_ECIO_THRESHOLD 0x11
#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSSI_THRESHOLD 0x10

/**
 * qmi_message_nas_config_signal_info_input_get_rscp_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @rscp_threshold: a placeholder for the output #GArray of #gint8 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RSCP Threshold' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_get_rscp_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **rscp_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rscp_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSCP Threshold' was not found in the message");
        return FALSE;
    }

    if (rscp_threshold)
        *rscp_threshold = self->arg_rscp_threshold;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_set_rscp_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @rscp_threshold: a #GArray of #gint8 elements. A new reference to @rscp_threshold will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'RSCP Threshold' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_set_rscp_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *rscp_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_rscp_threshold)
        g_array_unref (self->arg_rscp_threshold);
    self->arg_rscp_threshold = g_array_ref (rscp_threshold);
    self->arg_rscp_threshold_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_get_lte_report:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @lte_report_rate: a placeholder for the output #guint8, or %NULL if not required.
 * @lte_report_average_period: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE Report' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_get_lte_report (
    QmiMessageNasConfigSignalInfoInput *self,
    guint8 *lte_report_rate,
    guint8 *lte_report_average_period,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_report_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Report' was not found in the message");
        return FALSE;
    }

    if (lte_report_rate)
        *lte_report_rate = self->arg_lte_report_rate;
    if (lte_report_average_period)
        *lte_report_average_period = self->arg_lte_report_average_period;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_set_lte_report:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @lte_report_rate: a #guint8.
 * @lte_report_average_period: a #guint8.
 * @error: Return location for error or %NULL.
 *
 * Set the 'LTE Report' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_set_lte_report (
    QmiMessageNasConfigSignalInfoInput *self,
    guint8 lte_report_rate,
    guint8 lte_report_average_period,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_lte_report_rate = lte_report_rate;
    self->arg_lte_report_average_period = lte_report_average_period;
    self->arg_lte_report_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_get_rsrp_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @rsrp_threshold: a placeholder for the output #GArray of #gint16 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RSRP Threshold' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_get_rsrp_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **rsrp_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rsrp_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSRP Threshold' was not found in the message");
        return FALSE;
    }

    if (rsrp_threshold)
        *rsrp_threshold = self->arg_rsrp_threshold;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_set_rsrp_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @rsrp_threshold: a #GArray of #gint16 elements. A new reference to @rsrp_threshold will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'RSRP Threshold' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_set_rsrp_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *rsrp_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_rsrp_threshold)
        g_array_unref (self->arg_rsrp_threshold);
    self->arg_rsrp_threshold = g_array_ref (rsrp_threshold);
    self->arg_rsrp_threshold_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_get_rsrq_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @rsrq_threshold: a placeholder for the output #GArray of #gint8 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RSRQ Threshold' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_get_rsrq_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **rsrq_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rsrq_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSRQ Threshold' was not found in the message");
        return FALSE;
    }

    if (rsrq_threshold)
        *rsrq_threshold = self->arg_rsrq_threshold;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_set_rsrq_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @rsrq_threshold: a #GArray of #gint8 elements. A new reference to @rsrq_threshold will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'RSRQ Threshold' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_set_rsrq_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *rsrq_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_rsrq_threshold)
        g_array_unref (self->arg_rsrq_threshold);
    self->arg_rsrq_threshold = g_array_ref (rsrq_threshold);
    self->arg_rsrq_threshold_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_get_io_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @io_threshold: a placeholder for the output #GArray of #gint32 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'IO Threshold' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_get_io_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **io_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_io_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'IO Threshold' was not found in the message");
        return FALSE;
    }

    if (io_threshold)
        *io_threshold = self->arg_io_threshold;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_set_io_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @io_threshold: a #GArray of #gint32 elements. A new reference to @io_threshold will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'IO Threshold' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_set_io_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *io_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_io_threshold)
        g_array_unref (self->arg_io_threshold);
    self->arg_io_threshold = g_array_ref (io_threshold);
    self->arg_io_threshold_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_get_lte_snr_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @lte_snr_threshold: a placeholder for the output #GArray of #gint16 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE SNR Threshold' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_get_lte_snr_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **lte_snr_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_snr_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE SNR Threshold' was not found in the message");
        return FALSE;
    }

    if (lte_snr_threshold)
        *lte_snr_threshold = self->arg_lte_snr_threshold;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_set_lte_snr_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @lte_snr_threshold: a #GArray of #gint16 elements. A new reference to @lte_snr_threshold will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'LTE SNR Threshold' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_set_lte_snr_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *lte_snr_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_lte_snr_threshold)
        g_array_unref (self->arg_lte_snr_threshold);
    self->arg_lte_snr_threshold = g_array_ref (lte_snr_threshold);
    self->arg_lte_snr_threshold_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_get_sinr_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @sinr_threshold: a placeholder for the output #GArray of #guint8 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'SINR Threshold' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_get_sinr_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **sinr_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sinr_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SINR Threshold' was not found in the message");
        return FALSE;
    }

    if (sinr_threshold)
        *sinr_threshold = self->arg_sinr_threshold;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_set_sinr_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @sinr_threshold: a #GArray of #guint8 elements. A new reference to @sinr_threshold will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'SINR Threshold' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_set_sinr_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *sinr_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_sinr_threshold)
        g_array_unref (self->arg_sinr_threshold);
    self->arg_sinr_threshold = g_array_ref (sinr_threshold);
    self->arg_sinr_threshold_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_get_ecio_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @ecio_threshold: a placeholder for the output #GArray of #gint16 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'ECIO Threshold' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_get_ecio_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **ecio_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ecio_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ECIO Threshold' was not found in the message");
        return FALSE;
    }

    if (ecio_threshold)
        *ecio_threshold = self->arg_ecio_threshold;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_set_ecio_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @ecio_threshold: a #GArray of #gint16 elements. A new reference to @ecio_threshold will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'ECIO Threshold' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_set_ecio_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *ecio_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_ecio_threshold)
        g_array_unref (self->arg_ecio_threshold);
    self->arg_ecio_threshold = g_array_ref (ecio_threshold);
    self->arg_ecio_threshold_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_get_rssi_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @rssi_threshold: a placeholder for the output #GArray of #gint8 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'RSSI Threshold' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_get_rssi_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray **rssi_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_rssi_threshold_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'RSSI Threshold' was not found in the message");
        return FALSE;
    }

    if (rssi_threshold)
        *rssi_threshold = self->arg_rssi_threshold;

    return TRUE;
}

/**
 * qmi_message_nas_config_signal_info_input_set_rssi_threshold:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 * @rssi_threshold: a #GArray of #gint8 elements. A new reference to @rssi_threshold will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'RSSI Threshold' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_nas_config_signal_info_input_set_rssi_threshold (
    QmiMessageNasConfigSignalInfoInput *self,
    GArray *rssi_threshold,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_rssi_threshold)
        g_array_unref (self->arg_rssi_threshold);
    self->arg_rssi_threshold = g_array_ref (rssi_threshold);
    self->arg_rssi_threshold_set = TRUE;

    return TRUE;
}

GType
qmi_message_nas_config_signal_info_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasConfigSignalInfoInput"),
                                          (GBoxedCopyFunc) qmi_message_nas_config_signal_info_input_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_config_signal_info_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_config_signal_info_input_ref:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasConfigSignalInfoInput *
qmi_message_nas_config_signal_info_input_ref (QmiMessageNasConfigSignalInfoInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_config_signal_info_input_unref:
 * @self: a #QmiMessageNasConfigSignalInfoInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_config_signal_info_input_unref (QmiMessageNasConfigSignalInfoInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_rscp_threshold)
            g_array_unref (self->arg_rscp_threshold);
        if (self->arg_rsrp_threshold)
            g_array_unref (self->arg_rsrp_threshold);
        if (self->arg_rsrq_threshold)
            g_array_unref (self->arg_rsrq_threshold);
        if (self->arg_io_threshold)
            g_array_unref (self->arg_io_threshold);
        if (self->arg_lte_snr_threshold)
            g_array_unref (self->arg_lte_snr_threshold);
        if (self->arg_sinr_threshold)
            g_array_unref (self->arg_sinr_threshold);
        if (self->arg_ecio_threshold)
            g_array_unref (self->arg_ecio_threshold);
        if (self->arg_rssi_threshold)
            g_array_unref (self->arg_rssi_threshold);
        g_slice_free (QmiMessageNasConfigSignalInfoInput, self);
    }
}

/**
 * qmi_message_nas_config_signal_info_input_new:
 *
 * Allocates a new #QmiMessageNasConfigSignalInfoInput.
 *
 * Returns: the newly created #QmiMessageNasConfigSignalInfoInput. The returned value should be freed with qmi_message_nas_config_signal_info_input_unref().
 */
QmiMessageNasConfigSignalInfoInput *
qmi_message_nas_config_signal_info_input_new (void)
{
    QmiMessageNasConfigSignalInfoInput *self;

    self = g_slice_new0 (QmiMessageNasConfigSignalInfoInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_nas_config_signal_info_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageNasConfigSignalInfoInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return self;

    /* Try to add the 'RSCP Threshold' TLV */
    if (input->arg_rscp_threshold_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint rscp_threshold_i;
            guint8 rscp_threshold_n_items;

            /* Write the number of items in the array first */
            rscp_threshold_n_items = (guint8) input->arg_rscp_threshold->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(rscp_threshold_n_items));

            for (rscp_threshold_i = 0; rscp_threshold_i < input->arg_rscp_threshold->len; rscp_threshold_i++) {
                /* Write the gint8 variable to the buffer */
                qmi_utils_write_gint8_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    &(g_array_index (input->arg_rscp_threshold, gint8,rscp_threshold_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSCP_THRESHOLD,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the RSCP Threshold TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'LTE Report' TLV */
    if (input->arg_lte_report_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_lte_report_rate));
        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_lte_report_average_period));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_REPORT,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the LTE Report TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'RSRP Threshold' TLV */
    if (input->arg_rsrp_threshold_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint rsrp_threshold_i;
            guint8 rsrp_threshold_n_items;

            /* Write the number of items in the array first */
            rsrp_threshold_n_items = (guint8) input->arg_rsrp_threshold->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(rsrp_threshold_n_items));

            for (rsrp_threshold_i = 0; rsrp_threshold_i < input->arg_rsrp_threshold->len; rsrp_threshold_i++) {
                /* Write the gint16 variable to the buffer */
                qmi_utils_write_gint16_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(g_array_index (input->arg_rsrp_threshold, gint16,rsrp_threshold_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRP_THRESHOLD,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the RSRP Threshold TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'RSRQ Threshold' TLV */
    if (input->arg_rsrq_threshold_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint rsrq_threshold_i;
            guint8 rsrq_threshold_n_items;

            /* Write the number of items in the array first */
            rsrq_threshold_n_items = (guint8) input->arg_rsrq_threshold->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(rsrq_threshold_n_items));

            for (rsrq_threshold_i = 0; rsrq_threshold_i < input->arg_rsrq_threshold->len; rsrq_threshold_i++) {
                /* Write the gint8 variable to the buffer */
                qmi_utils_write_gint8_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    &(g_array_index (input->arg_rsrq_threshold, gint8,rsrq_threshold_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRQ_THRESHOLD,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the RSRQ Threshold TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'IO Threshold' TLV */
    if (input->arg_io_threshold_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint io_threshold_i;
            guint8 io_threshold_n_items;

            /* Write the number of items in the array first */
            io_threshold_n_items = (guint8) input->arg_io_threshold->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(io_threshold_n_items));

            for (io_threshold_i = 0; io_threshold_i < input->arg_io_threshold->len; io_threshold_i++) {
                /* Write the gint32 variable to the buffer */
                qmi_utils_write_gint32_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(g_array_index (input->arg_io_threshold, gint32,io_threshold_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_IO_THRESHOLD,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the IO Threshold TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'LTE SNR Threshold' TLV */
    if (input->arg_lte_snr_threshold_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint lte_snr_threshold_i;
            guint8 lte_snr_threshold_n_items;

            /* Write the number of items in the array first */
            lte_snr_threshold_n_items = (guint8) input->arg_lte_snr_threshold->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(lte_snr_threshold_n_items));

            for (lte_snr_threshold_i = 0; lte_snr_threshold_i < input->arg_lte_snr_threshold->len; lte_snr_threshold_i++) {
                /* Write the gint16 variable to the buffer */
                qmi_utils_write_gint16_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(g_array_index (input->arg_lte_snr_threshold, gint16,lte_snr_threshold_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_SNR_THRESHOLD,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the LTE SNR Threshold TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'SINR Threshold' TLV */
    if (input->arg_sinr_threshold_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint sinr_threshold_i;
            guint8 sinr_threshold_n_items;

            /* Write the number of items in the array first */
            sinr_threshold_n_items = (guint8) input->arg_sinr_threshold->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(sinr_threshold_n_items));

            for (sinr_threshold_i = 0; sinr_threshold_i < input->arg_sinr_threshold->len; sinr_threshold_i++) {
                /* Write the guint8 variable to the buffer */
                qmi_utils_write_guint8_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    &(g_array_index (input->arg_sinr_threshold, guint8,sinr_threshold_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_SINR_THRESHOLD,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the SINR Threshold TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'ECIO Threshold' TLV */
    if (input->arg_ecio_threshold_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint ecio_threshold_i;
            guint8 ecio_threshold_n_items;

            /* Write the number of items in the array first */
            ecio_threshold_n_items = (guint8) input->arg_ecio_threshold->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(ecio_threshold_n_items));

            for (ecio_threshold_i = 0; ecio_threshold_i < input->arg_ecio_threshold->len; ecio_threshold_i++) {
                /* Write the gint16 variable to the buffer */
                qmi_utils_write_gint16_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(g_array_index (input->arg_ecio_threshold, gint16,ecio_threshold_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_ECIO_THRESHOLD,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the ECIO Threshold TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'RSSI Threshold' TLV */
    if (input->arg_rssi_threshold_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint rssi_threshold_i;
            guint8 rssi_threshold_n_items;

            /* Write the number of items in the array first */
            rssi_threshold_n_items = (guint8) input->arg_rssi_threshold->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(rssi_threshold_n_items));

            for (rssi_threshold_i = 0; rssi_threshold_i < input->arg_rssi_threshold->len; rssi_threshold_i++) {
                /* Write the gint8 variable to the buffer */
                qmi_utils_write_gint8_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    &(g_array_index (input->arg_rssi_threshold, gint8,rssi_threshold_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSSI_THRESHOLD,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the RSSI Threshold TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageNasConfigSignalInfoOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_nas_config_signal_info_output_get_result:
 * @self: a QmiMessageNasConfigSignalInfoOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_config_signal_info_output_get_result (
    QmiMessageNasConfigSignalInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_nas_config_signal_info_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasConfigSignalInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_config_signal_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_config_signal_info_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_config_signal_info_output_ref:
 * @self: a #QmiMessageNasConfigSignalInfoOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasConfigSignalInfoOutput *
qmi_message_nas_config_signal_info_output_ref (QmiMessageNasConfigSignalInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_config_signal_info_output_unref:
 * @self: a #QmiMessageNasConfigSignalInfoOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_config_signal_info_output_unref (QmiMessageNasConfigSignalInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageNasConfigSignalInfoOutput, self);
    }
}

static gboolean
qmi_message_nas_config_signal_info_input_rscp_threshold_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint rscp_threshold_i;
        guint8 rscp_threshold_n_items;
        const guint8 *rscp_threshold_aux_buffer = &buffer[expected_len];
        guint16 rscp_threshold_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &rscp_threshold_aux_buffer,
            &rscp_threshold_aux_buffer_len,
            &(rscp_threshold_n_items));
        for (rscp_threshold_i = 0; rscp_threshold_i < rscp_threshold_n_items; rscp_threshold_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RSCP Threshold' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RSCP Threshold' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_config_signal_info_input_rscp_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSCP_THRESHOLD,
                                      &buffer_len);
    if (buffer && qmi_message_nas_config_signal_info_input_rscp_threshold_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint rscp_threshold_i;
            guint8 rscp_threshold_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(rscp_threshold_n_items));

            g_string_append (printable, "{");

            for (rscp_threshold_i = 0; rscp_threshold_i < rscp_threshold_n_items; rscp_threshold_i++) {
                g_string_append_printf (printable, " [%u] = '", rscp_threshold_i);

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%d", (gint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RSCP Threshold' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_config_signal_info_input_lte_report_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE Report' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE Report' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_config_signal_info_input_lte_report_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_REPORT,
                                      &buffer_len);
    if (buffer && qmi_message_nas_config_signal_info_input_lte_report_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rate = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " average_period = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE Report' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_config_signal_info_input_rsrp_threshold_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint rsrp_threshold_i;
        guint8 rsrp_threshold_n_items;
        const guint8 *rsrp_threshold_aux_buffer = &buffer[expected_len];
        guint16 rsrp_threshold_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &rsrp_threshold_aux_buffer,
            &rsrp_threshold_aux_buffer_len,
            &(rsrp_threshold_n_items));
        for (rsrp_threshold_i = 0; rsrp_threshold_i < rsrp_threshold_n_items; rsrp_threshold_i++) {

            expected_len += 2;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RSRP Threshold' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RSRP Threshold' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_config_signal_info_input_rsrp_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRP_THRESHOLD,
                                      &buffer_len);
    if (buffer && qmi_message_nas_config_signal_info_input_rsrp_threshold_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint rsrp_threshold_i;
            guint8 rsrp_threshold_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(rsrp_threshold_n_items));

            g_string_append (printable, "{");

            for (rsrp_threshold_i = 0; rsrp_threshold_i < rsrp_threshold_n_items; rsrp_threshold_i++) {
                g_string_append_printf (printable, " [%u] = '", rsrp_threshold_i);

                {
                    gint16 tmp;

                    /* Read the gint16 variable from the buffer */
                    qmi_utils_read_gint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RSRP Threshold' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_config_signal_info_input_rsrq_threshold_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint rsrq_threshold_i;
        guint8 rsrq_threshold_n_items;
        const guint8 *rsrq_threshold_aux_buffer = &buffer[expected_len];
        guint16 rsrq_threshold_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &rsrq_threshold_aux_buffer,
            &rsrq_threshold_aux_buffer_len,
            &(rsrq_threshold_n_items));
        for (rsrq_threshold_i = 0; rsrq_threshold_i < rsrq_threshold_n_items; rsrq_threshold_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RSRQ Threshold' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RSRQ Threshold' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_config_signal_info_input_rsrq_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRQ_THRESHOLD,
                                      &buffer_len);
    if (buffer && qmi_message_nas_config_signal_info_input_rsrq_threshold_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint rsrq_threshold_i;
            guint8 rsrq_threshold_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(rsrq_threshold_n_items));

            g_string_append (printable, "{");

            for (rsrq_threshold_i = 0; rsrq_threshold_i < rsrq_threshold_n_items; rsrq_threshold_i++) {
                g_string_append_printf (printable, " [%u] = '", rsrq_threshold_i);

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%d", (gint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RSRQ Threshold' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_config_signal_info_input_io_threshold_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint io_threshold_i;
        guint8 io_threshold_n_items;
        const guint8 *io_threshold_aux_buffer = &buffer[expected_len];
        guint16 io_threshold_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &io_threshold_aux_buffer,
            &io_threshold_aux_buffer_len,
            &(io_threshold_n_items));
        for (io_threshold_i = 0; io_threshold_i < io_threshold_n_items; io_threshold_i++) {

            expected_len += 4;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'IO Threshold' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'IO Threshold' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_config_signal_info_input_io_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_IO_THRESHOLD,
                                      &buffer_len);
    if (buffer && qmi_message_nas_config_signal_info_input_io_threshold_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint io_threshold_i;
            guint8 io_threshold_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(io_threshold_n_items));

            g_string_append (printable, "{");

            for (io_threshold_i = 0; io_threshold_i < io_threshold_n_items; io_threshold_i++) {
                g_string_append_printf (printable, " [%u] = '", io_threshold_i);

                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'IO Threshold' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_config_signal_info_input_lte_snr_threshold_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint lte_snr_threshold_i;
        guint8 lte_snr_threshold_n_items;
        const guint8 *lte_snr_threshold_aux_buffer = &buffer[expected_len];
        guint16 lte_snr_threshold_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &lte_snr_threshold_aux_buffer,
            &lte_snr_threshold_aux_buffer_len,
            &(lte_snr_threshold_n_items));
        for (lte_snr_threshold_i = 0; lte_snr_threshold_i < lte_snr_threshold_n_items; lte_snr_threshold_i++) {

            expected_len += 2;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE SNR Threshold' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE SNR Threshold' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_config_signal_info_input_lte_snr_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_SNR_THRESHOLD,
                                      &buffer_len);
    if (buffer && qmi_message_nas_config_signal_info_input_lte_snr_threshold_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint lte_snr_threshold_i;
            guint8 lte_snr_threshold_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(lte_snr_threshold_n_items));

            g_string_append (printable, "{");

            for (lte_snr_threshold_i = 0; lte_snr_threshold_i < lte_snr_threshold_n_items; lte_snr_threshold_i++) {
                g_string_append_printf (printable, " [%u] = '", lte_snr_threshold_i);

                {
                    gint16 tmp;

                    /* Read the gint16 variable from the buffer */
                    qmi_utils_read_gint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE SNR Threshold' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_config_signal_info_input_sinr_threshold_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint sinr_threshold_i;
        guint8 sinr_threshold_n_items;
        const guint8 *sinr_threshold_aux_buffer = &buffer[expected_len];
        guint16 sinr_threshold_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &sinr_threshold_aux_buffer,
            &sinr_threshold_aux_buffer_len,
            &(sinr_threshold_n_items));
        for (sinr_threshold_i = 0; sinr_threshold_i < sinr_threshold_n_items; sinr_threshold_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'SINR Threshold' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'SINR Threshold' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_config_signal_info_input_sinr_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_SINR_THRESHOLD,
                                      &buffer_len);
    if (buffer && qmi_message_nas_config_signal_info_input_sinr_threshold_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint sinr_threshold_i;
            guint8 sinr_threshold_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(sinr_threshold_n_items));

            g_string_append (printable, "{");

            for (sinr_threshold_i = 0; sinr_threshold_i < sinr_threshold_n_items; sinr_threshold_i++) {
                g_string_append_printf (printable, " [%u] = '", sinr_threshold_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%u", (guint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'SINR Threshold' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_config_signal_info_input_ecio_threshold_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint ecio_threshold_i;
        guint8 ecio_threshold_n_items;
        const guint8 *ecio_threshold_aux_buffer = &buffer[expected_len];
        guint16 ecio_threshold_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &ecio_threshold_aux_buffer,
            &ecio_threshold_aux_buffer_len,
            &(ecio_threshold_n_items));
        for (ecio_threshold_i = 0; ecio_threshold_i < ecio_threshold_n_items; ecio_threshold_i++) {

            expected_len += 2;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'ECIO Threshold' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'ECIO Threshold' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_config_signal_info_input_ecio_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_ECIO_THRESHOLD,
                                      &buffer_len);
    if (buffer && qmi_message_nas_config_signal_info_input_ecio_threshold_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint ecio_threshold_i;
            guint8 ecio_threshold_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(ecio_threshold_n_items));

            g_string_append (printable, "{");

            for (ecio_threshold_i = 0; ecio_threshold_i < ecio_threshold_n_items; ecio_threshold_i++) {
                g_string_append_printf (printable, " [%u] = '", ecio_threshold_i);

                {
                    gint16 tmp;

                    /* Read the gint16 variable from the buffer */
                    qmi_utils_read_gint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'ECIO Threshold' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_nas_config_signal_info_input_rssi_threshold_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint rssi_threshold_i;
        guint8 rssi_threshold_n_items;
        const guint8 *rssi_threshold_aux_buffer = &buffer[expected_len];
        guint16 rssi_threshold_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &rssi_threshold_aux_buffer,
            &rssi_threshold_aux_buffer_len,
            &(rssi_threshold_n_items));
        for (rssi_threshold_i = 0; rssi_threshold_i < rssi_threshold_n_items; rssi_threshold_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'RSSI Threshold' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'RSSI Threshold' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_config_signal_info_input_rssi_threshold_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSSI_THRESHOLD,
                                      &buffer_len);
    if (buffer && qmi_message_nas_config_signal_info_input_rssi_threshold_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint rssi_threshold_i;
            guint8 rssi_threshold_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(rssi_threshold_n_items));

            g_string_append (printable, "{");

            for (rssi_threshold_i = 0; rssi_threshold_i < rssi_threshold_n_items; rssi_threshold_i++) {
                g_string_append_printf (printable, " [%u] = '", rssi_threshold_i);

                {
                    gint8 tmp;

                    /* Read the gint8 variable from the buffer */
                    qmi_utils_read_gint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%d", (gint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'RSSI Threshold' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_config_signal_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_config_signal_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_config_signal_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSCP_THRESHOLD:
            tlv_type_str = "RSCP Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_rscp_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_REPORT:
            tlv_type_str = "LTE Report";
            translated_value = qmi_message_nas_config_signal_info_input_lte_report_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRP_THRESHOLD:
            tlv_type_str = "RSRP Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_rsrp_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSRQ_THRESHOLD:
            tlv_type_str = "RSRQ Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_rsrq_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_IO_THRESHOLD:
            tlv_type_str = "IO Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_io_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_LTE_SNR_THRESHOLD:
            tlv_type_str = "LTE SNR Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_lte_snr_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_SINR_THRESHOLD:
            tlv_type_str = "SINR Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_sinr_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_ECIO_THRESHOLD:
            tlv_type_str = "ECIO Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_ecio_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_INPUT_TLV_RSSI_THRESHOLD:
            tlv_type_str = "RSSI Threshold";
            translated_value = qmi_message_nas_config_signal_info_input_rssi_threshold_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_config_signal_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Config Signal Info\" (0x0050)\n",
                            line_prefix);

    {
        struct message_config_signal_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_config_signal_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasConfigSignalInfoOutput *
__qmi_message_nas_config_signal_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasConfigSignalInfoOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO, NULL);

    self = g_slice_new0 (QmiMessageNasConfigSignalInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_config_signal_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication NAS Signal Info */


/* --- Output -- */

struct _QmiIndicationNasSignalInfoOutput {
    volatile gint ref_count;

    /* TDMA Signal Strength */
    gboolean arg_tdma_signal_strength_set;
    gint8 arg_tdma_signal_strength;

    /* LTE Signal Strength */
    gboolean arg_lte_signal_strength_set;
    gint8 arg_lte_signal_strength_rssi;
    gint8 arg_lte_signal_strength_rsrq;
    gint16 arg_lte_signal_strength_rsrp;
    gint16 arg_lte_signal_strength_snr;

    /* WCDMA Signal Strength */
    gboolean arg_wcdma_signal_strength_set;
    gint8 arg_wcdma_signal_strength_rssi;
    gint16 arg_wcdma_signal_strength_ecio;

    /* GSM Signal Strength */
    gboolean arg_gsm_signal_strength_set;
    gint8 arg_gsm_signal_strength;

    /* HDR Signal Strength */
    gboolean arg_hdr_signal_strength_set;
    gint8 arg_hdr_signal_strength_rssi;
    gint16 arg_hdr_signal_strength_ecio;
    guint8 arg_hdr_signal_strength_sinr;
    gint32 arg_hdr_signal_strength_io;

    /* CDMA Signal Strength */
    gboolean arg_cdma_signal_strength_set;
    gint8 arg_cdma_signal_strength_rssi;
    gint16 arg_cdma_signal_strength_ecio;
};

#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH 0x15
#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH 0x14
#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH 0x13
#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH 0x12
#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH 0x11
#define QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH 0x10

/**
 * qmi_indication_nas_signal_info_output_get_tdma_signal_strength:
 * @self: a #QmiIndicationNasSignalInfoOutput.
 * @tdma_signal_strength: a placeholder for the output #gint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'TDMA Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_signal_info_output_get_tdma_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *tdma_signal_strength,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_tdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'TDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (tdma_signal_strength)
        *tdma_signal_strength = self->arg_tdma_signal_strength;

    return TRUE;
}

/**
 * qmi_indication_nas_signal_info_output_get_lte_signal_strength:
 * @self: a #QmiIndicationNasSignalInfoOutput.
 * @lte_signal_strength_rssi: a placeholder for the output #gint8, or %NULL if not required.
 * @lte_signal_strength_rsrq: a placeholder for the output #gint8, or %NULL if not required.
 * @lte_signal_strength_rsrp: a placeholder for the output #gint16, or %NULL if not required.
 * @lte_signal_strength_snr: a placeholder for the output #gint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_signal_info_output_get_lte_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *lte_signal_strength_rssi,
    gint8 *lte_signal_strength_rsrq,
    gint16 *lte_signal_strength_rsrp,
    gint16 *lte_signal_strength_snr,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Signal Strength' was not found in the message");
        return FALSE;
    }

    if (lte_signal_strength_rssi)
        *lte_signal_strength_rssi = self->arg_lte_signal_strength_rssi;
    if (lte_signal_strength_rsrq)
        *lte_signal_strength_rsrq = self->arg_lte_signal_strength_rsrq;
    if (lte_signal_strength_rsrp)
        *lte_signal_strength_rsrp = self->arg_lte_signal_strength_rsrp;
    if (lte_signal_strength_snr)
        *lte_signal_strength_snr = self->arg_lte_signal_strength_snr;

    return TRUE;
}

/**
 * qmi_indication_nas_signal_info_output_get_wcdma_signal_strength:
 * @self: a #QmiIndicationNasSignalInfoOutput.
 * @wcdma_signal_strength_rssi: a placeholder for the output #gint8, or %NULL if not required.
 * @wcdma_signal_strength_ecio: a placeholder for the output #gint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'WCDMA Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_signal_info_output_get_wcdma_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *wcdma_signal_strength_rssi,
    gint16 *wcdma_signal_strength_ecio,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wcdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'WCDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (wcdma_signal_strength_rssi)
        *wcdma_signal_strength_rssi = self->arg_wcdma_signal_strength_rssi;
    if (wcdma_signal_strength_ecio)
        *wcdma_signal_strength_ecio = self->arg_wcdma_signal_strength_ecio;

    return TRUE;
}

/**
 * qmi_indication_nas_signal_info_output_get_gsm_signal_strength:
 * @self: a #QmiIndicationNasSignalInfoOutput.
 * @gsm_signal_strength: a placeholder for the output #gint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'GSM Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_signal_info_output_get_gsm_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *gsm_signal_strength,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_gsm_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'GSM Signal Strength' was not found in the message");
        return FALSE;
    }

    if (gsm_signal_strength)
        *gsm_signal_strength = self->arg_gsm_signal_strength;

    return TRUE;
}

/**
 * qmi_indication_nas_signal_info_output_get_hdr_signal_strength:
 * @self: a #QmiIndicationNasSignalInfoOutput.
 * @hdr_signal_strength_rssi: a placeholder for the output #gint8, or %NULL if not required.
 * @hdr_signal_strength_ecio: a placeholder for the output #gint16, or %NULL if not required.
 * @hdr_signal_strength_sinr: a placeholder for the output #QmiNasEvdoSinrLevel, or %NULL if not required.
 * @hdr_signal_strength_io: a placeholder for the output #gint32, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'HDR Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_signal_info_output_get_hdr_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *hdr_signal_strength_rssi,
    gint16 *hdr_signal_strength_ecio,
    QmiNasEvdoSinrLevel *hdr_signal_strength_sinr,
    gint32 *hdr_signal_strength_io,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hdr_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'HDR Signal Strength' was not found in the message");
        return FALSE;
    }

    if (hdr_signal_strength_rssi)
        *hdr_signal_strength_rssi = self->arg_hdr_signal_strength_rssi;
    if (hdr_signal_strength_ecio)
        *hdr_signal_strength_ecio = self->arg_hdr_signal_strength_ecio;
    if (hdr_signal_strength_sinr)
        *hdr_signal_strength_sinr = (QmiNasEvdoSinrLevel)(self->arg_hdr_signal_strength_sinr);
    if (hdr_signal_strength_io)
        *hdr_signal_strength_io = self->arg_hdr_signal_strength_io;

    return TRUE;
}

/**
 * qmi_indication_nas_signal_info_output_get_cdma_signal_strength:
 * @self: a #QmiIndicationNasSignalInfoOutput.
 * @cdma_signal_strength_rssi: a placeholder for the output #gint8, or %NULL if not required.
 * @cdma_signal_strength_ecio: a placeholder for the output #gint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA Signal Strength' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_nas_signal_info_output_get_cdma_signal_strength (
    QmiIndicationNasSignalInfoOutput *self,
    gint8 *cdma_signal_strength_rssi,
    gint16 *cdma_signal_strength_ecio,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_signal_strength_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Signal Strength' was not found in the message");
        return FALSE;
    }

    if (cdma_signal_strength_rssi)
        *cdma_signal_strength_rssi = self->arg_cdma_signal_strength_rssi;
    if (cdma_signal_strength_ecio)
        *cdma_signal_strength_ecio = self->arg_cdma_signal_strength_ecio;

    return TRUE;
}

GType
qmi_indication_nas_signal_info_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationNasSignalInfoOutput"),
                                          (GBoxedCopyFunc) qmi_indication_nas_signal_info_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_nas_signal_info_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_indication_nas_signal_info_output_ref:
 * @self: a #QmiIndicationNasSignalInfoOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiIndicationNasSignalInfoOutput *
qmi_indication_nas_signal_info_output_ref (QmiIndicationNasSignalInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_indication_nas_signal_info_output_unref:
 * @self: a #QmiIndicationNasSignalInfoOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_indication_nas_signal_info_output_unref (QmiIndicationNasSignalInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiIndicationNasSignalInfoOutput, self);
    }
}

static gboolean
qmi_indication_nas_signal_info_output_tdma_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'TDMA Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'TDMA Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_signal_info_output_tdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_signal_info_output_tdma_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'TDMA Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_signal_info_output_lte_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 2;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_signal_info_output_lte_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_signal_info_output_lte_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rssi = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " rsrq = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " rsrp = '");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " snr = '");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_signal_info_output_wcdma_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'WCDMA Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'WCDMA Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_signal_info_output_wcdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_signal_info_output_wcdma_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rssi = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ecio = '");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'WCDMA Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_signal_info_output_gsm_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'GSM Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'GSM Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_signal_info_output_gsm_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_signal_info_output_gsm_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'GSM Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_signal_info_output_hdr_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 2;
    expected_len += 1;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'HDR Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'HDR Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_signal_info_output_hdr_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_signal_info_output_hdr_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rssi = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ecio = '");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " sinr = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_nas_evdo_sinr_level_get_string ((QmiNasEvdoSinrLevel)tmp));
#elif defined  __QMI_NAS_EVDO_SINR_LEVEL_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_nas_evdo_sinr_level_build_string_from_mask ((QmiNasEvdoSinrLevel)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiNasEvdoSinrLevel
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " io = '");

        {
            gint32 tmp;

            /* Read the gint32 variable from the buffer */
            qmi_utils_read_gint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'HDR Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_nas_signal_info_output_cdma_signal_strength_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA Signal Strength' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA Signal Strength' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_nas_signal_info_output_cdma_signal_strength_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH,
                                      &buffer_len);
    if (buffer && qmi_indication_nas_signal_info_output_cdma_signal_strength_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " rssi = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ecio = '");

        {
            gint16 tmp;

            /* Read the gint16 variable from the buffer */
            qmi_utils_read_gint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA Signal Strength' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct indication_signal_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_signal_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_signal_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    {
        switch (type) {
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH:
            tlv_type_str = "TDMA Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_tdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH:
            tlv_type_str = "LTE Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_lte_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH:
            tlv_type_str = "WCDMA Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_wcdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH:
            tlv_type_str = "GSM Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_gsm_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH:
            tlv_type_str = "HDR Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_hdr_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH:
            tlv_type_str = "CDMA Signal Strength";
            translated_value = qmi_indication_nas_signal_info_output_cdma_signal_strength_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
indication_signal_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Signal Info\" (0x0051)\n",
                            line_prefix);

    {
        struct indication_signal_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_signal_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationNasSignalInfoOutput *
__qmi_indication_nas_signal_info_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationNasSignalInfoOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_INDICATION_NAS_SIGNAL_INFO, NULL);

    self = g_slice_new0 (QmiIndicationNasSignalInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_TDMA_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_signal_info_output_tdma_signal_strength_validate (buffer, buffer_len)) {
                self->arg_tdma_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_tdma_signal_strength));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'TDMA Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_LTE_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_signal_info_output_lte_signal_strength_validate (buffer, buffer_len)) {
                self->arg_lte_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_lte_signal_strength_rssi));
                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_lte_signal_strength_rsrq));
                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_signal_strength_rsrp));
                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_lte_signal_strength_snr));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_WCDMA_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_signal_info_output_wcdma_signal_strength_validate (buffer, buffer_len)) {
                self->arg_wcdma_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_wcdma_signal_strength_rssi));
                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_wcdma_signal_strength_ecio));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'WCDMA Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_GSM_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_signal_info_output_gsm_signal_strength_validate (buffer, buffer_len)) {
                self->arg_gsm_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_gsm_signal_strength));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'GSM Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_HDR_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_signal_info_output_hdr_signal_strength_validate (buffer, buffer_len)) {
                self->arg_hdr_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_hdr_signal_strength_rssi));
                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_hdr_signal_strength_ecio));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hdr_signal_strength_sinr = (QmiNasEvdoSinrLevel)tmp;
                }
                /* Read the gint32 variable from the buffer */
                qmi_utils_read_gint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_hdr_signal_strength_io));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'HDR Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_NAS_SIGNAL_INFO_OUTPUT_TLV_CDMA_SIGNAL_STRENGTH,
                                              &buffer_len);
            if (buffer && qmi_indication_nas_signal_info_output_cdma_signal_strength_validate (buffer, buffer_len)) {
                self->arg_cdma_signal_strength_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_signal_strength_rssi));
                /* Read the gint16 variable from the buffer */
                qmi_utils_read_gint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_cdma_signal_strength_ecio));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA Signal Strength' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message NAS Get CDMA Position Info */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_nas_get_cdma_position_info_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_NAS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO);

    return self;
}

/* --- Output -- */

struct _QmiMessageNasGetCdmaPositionInfoOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* CDMA Position Info */
    gboolean arg_cdma_position_info_set;
    gint8 arg_cdma_position_info_ui_in_idle_mode;
    GArray *arg_cdma_position_info_basestations;
};

#define QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_CDMA_POSITION_INFO 0x10

/**
 * qmi_message_nas_get_cdma_position_info_output_get_result:
 * @self: a QmiMessageNasGetCdmaPositionInfoOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_nas_get_cdma_position_info_output_get_result (
    QmiMessageNasGetCdmaPositionInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_nas_get_cdma_position_info_output_get_cdma_position_info:
 * @self: a #QmiMessageNasGetCdmaPositionInfoOutput.
 * @cdma_position_info_ui_in_idle_mode: a placeholder for the output #gint8, or %NULL if not required.
 * @cdma_position_info_basestations: a placeholder for the output #GArray of #QmiMessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CDMA Position Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_nas_get_cdma_position_info_output_get_cdma_position_info (
    QmiMessageNasGetCdmaPositionInfoOutput *self,
    gint8 *cdma_position_info_ui_in_idle_mode,
    GArray **cdma_position_info_basestations,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_cdma_position_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CDMA Position Info' was not found in the message");
        return FALSE;
    }

    if (cdma_position_info_ui_in_idle_mode)
        *cdma_position_info_ui_in_idle_mode = self->arg_cdma_position_info_ui_in_idle_mode;
    if (cdma_position_info_basestations)
        *cdma_position_info_basestations = self->arg_cdma_position_info_basestations;

    return TRUE;
}

GType
qmi_message_nas_get_cdma_position_info_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageNasGetCdmaPositionInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_nas_get_cdma_position_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_nas_get_cdma_position_info_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_nas_get_cdma_position_info_output_ref:
 * @self: a #QmiMessageNasGetCdmaPositionInfoOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageNasGetCdmaPositionInfoOutput *
qmi_message_nas_get_cdma_position_info_output_ref (QmiMessageNasGetCdmaPositionInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_nas_get_cdma_position_info_output_unref:
 * @self: a #QmiMessageNasGetCdmaPositionInfoOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_nas_get_cdma_position_info_output_unref (QmiMessageNasGetCdmaPositionInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_cdma_position_info_basestations)
            g_array_unref (self->arg_cdma_position_info_basestations);
        g_slice_free (QmiMessageNasGetCdmaPositionInfoOutput, self);
    }
}

static gboolean
qmi_message_nas_get_cdma_position_info_output_cdma_position_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    {
        guint basestations_i;
        guint8 basestations_n_items;
        const guint8 *basestations_aux_buffer = &buffer[expected_len];
        guint16 basestations_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &basestations_aux_buffer,
            &basestations_aux_buffer_len,
            &(basestations_n_items));
        for (basestations_i = 0; basestations_i < basestations_n_items; basestations_i++) {

            expected_len += 4;
            expected_len += 2;
            expected_len += 2;
            expected_len += 2;
            expected_len += 2;
            expected_len += 2;
            expected_len += 4;
            expected_len += 4;
            expected_len += 8;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CDMA Position Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CDMA Position Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_nas_get_cdma_position_info_output_cdma_position_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_CDMA_POSITION_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_nas_get_cdma_position_info_output_cdma_position_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " ui_in_idle_mode = '");

        {
            gint8 tmp;

            /* Read the gint8 variable from the buffer */
            qmi_utils_read_gint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%d", (gint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " basestations = '");
        {
            guint basestations_i;
            guint8 basestations_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(basestations_n_items));

            g_string_append (printable, "{");

            for (basestations_i = 0; basestations_i < basestations_n_items; basestations_i++) {
                g_string_append_printf (printable, " [%u] = '", basestations_i);
                g_string_append (printable, "[");
                g_string_append (printable, " pilot_type = '");

                {
                    guint32 tmp;

                    /* Read the guint32 variable from the buffer */
                    qmi_utils_read_guint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

#if defined  __QMI_NAS_CDMA_PILOT_TYPE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_nas_cdma_pilot_type_get_string ((QmiNasCdmaPilotType)tmp));
#elif defined  __QMI_NAS_CDMA_PILOT_TYPE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_nas_cdma_pilot_type_build_string_from_mask ((QmiNasCdmaPilotType)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiNasCdmaPilotType
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " system_id = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " network_id = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " base_station_id = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " pilot_pn = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " pilot_strength = '");

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " latitude = '");

                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " longitude = '");

                {
                    gint32 tmp;

                    /* Read the gint32 variable from the buffer */
                    qmi_utils_read_gint32_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GINT32_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " gps_time_in_milliseconds = '");

                {
                    guint64 tmp;

                    /* Read the guint64 variable from the buffer */
                    qmi_utils_read_guint64_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);

                    g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CDMA Position Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_cdma_position_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_cdma_position_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_cdma_position_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_CDMA_POSITION_INFO:
            tlv_type_str = "CDMA Position Info";
            translated_value = qmi_message_nas_get_cdma_position_info_output_cdma_position_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_cdma_position_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get CDMA Position Info\" (0x0065)\n",
                            line_prefix);

    {
        struct message_get_cdma_position_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_cdma_position_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageNasGetCdmaPositionInfoOutput *
__qmi_message_nas_get_cdma_position_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageNasGetCdmaPositionInfoOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO, NULL);

    self = g_slice_new0 (QmiMessageNasGetCdmaPositionInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_nas_get_cdma_position_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO_OUTPUT_TLV_CDMA_POSITION_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_nas_get_cdma_position_info_output_cdma_position_info_validate (buffer, buffer_len)) {
                self->arg_cdma_position_info_set = TRUE;

                /* Read the gint8 variable from the buffer */
                qmi_utils_read_gint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_cdma_position_info_ui_in_idle_mode));
                {
                    guint basestations_i;
                    guint8 basestations_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(basestations_n_items));

                    self->arg_cdma_position_info_basestations = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation),
                        (guint)basestations_n_items);

                    for (basestations_i = 0; basestations_i < basestations_n_items; basestations_i++) {
                        QmiMessageNasGetCdmaPositionInfoOutputCdmaPositionInfoBasestationsBasestation basestations_aux;

                        {
                            guint32 tmp;

                            /* Read the guint32 variable from the buffer */
                            qmi_utils_read_guint32_from_buffer (
                                &buffer,
                                &buffer_len,
                                QMI_ENDIAN_LITTLE,
                                &tmp);
                            basestations_aux.pilot_type = (QmiNasCdmaPilotType)tmp;
                        }
                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(basestations_aux.system_id));
                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(basestations_aux.network_id));
                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(basestations_aux.base_station_id));
                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(basestations_aux.pilot_pn));
                        /* Read the guint16 variable from the buffer */
                        qmi_utils_read_guint16_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(basestations_aux.pilot_strength));
                        /* Read the gint32 variable from the buffer */
                        qmi_utils_read_gint32_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(basestations_aux.latitude));
                        /* Read the gint32 variable from the buffer */
                        qmi_utils_read_gint32_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(basestations_aux.longitude));
                        /* Read the guint64 variable from the buffer */
                        qmi_utils_read_guint64_from_buffer (
                            &buffer,
                            &buffer_len,
                            QMI_ENDIAN_LITTLE,
                            &(basestations_aux.gps_time_in_milliseconds));
                        g_array_insert_val (self->arg_cdma_position_info_basestations, basestations_i, basestations_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CDMA Position Info' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* Service-specific printable: NAS */


gchar *
__qmi_message_nas_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    if (qmi_message_is_indication (self)) {
        switch (qmi_message_get_message_id (self)) {
        case QMI_INDICATION_NAS_EVENT_REPORT:
            return indication_event_report_get_printable (self, line_prefix);
        case QMI_INDICATION_NAS_SERVING_SYSTEM:
            return indication_serving_system_get_printable (self, line_prefix);
        case QMI_INDICATION_NAS_NETWORK_TIME:
            return indication_network_time_get_printable (self, line_prefix);
        case QMI_INDICATION_NAS_SYSTEM_INFO:
            return indication_system_info_get_printable (self, line_prefix);
        case QMI_INDICATION_NAS_SIGNAL_INFO:
            return indication_signal_info_get_printable (self, line_prefix);
         default:
             return NULL;
        }
    } else {
        switch (qmi_message_get_message_id (self)) {
        case QMI_MESSAGE_NAS_RESET:
            return message_reset_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_ABORT:
            return message_abort_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_SET_EVENT_REPORT:
            return message_set_event_report_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_REGISTER_INDICATIONS:
            return message_register_indications_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH:
            return message_get_signal_strength_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_NETWORK_SCAN:
            return message_network_scan_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER:
            return message_initiate_network_register_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM:
            return message_get_serving_system_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_GET_HOME_NETWORK:
            return message_get_home_network_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE:
            return message_set_technology_preference_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE:
            return message_get_technology_preference_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION:
            return message_get_rf_band_information_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE:
            return message_set_system_selection_preference_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE:
            return message_get_system_selection_preference_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_GET_SYSTEM_INFO:
            return message_get_system_info_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_GET_SIGNAL_INFO:
            return message_get_signal_info_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO:
            return message_config_signal_info_get_printable (self, line_prefix);
        case QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO:
            return message_get_cdma_position_info_get_printable (self, line_prefix);
         default:
             return NULL;
        }
    }
}

gboolean
__qmi_message_nas_get_version_introduced (
    QmiMessage *self,
    guint *major,
    guint *minor)
{
    switch (qmi_message_get_message_id (self)) {
    case QMI_MESSAGE_NAS_RESET:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_NAS_ABORT:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_NAS_SET_EVENT_REPORT:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_NAS_REGISTER_INDICATIONS:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_NAS_GET_SIGNAL_STRENGTH:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_NAS_NETWORK_SCAN:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_NAS_INITIATE_NETWORK_REGISTER:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_NAS_GET_SERVING_SYSTEM:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_NAS_GET_HOME_NETWORK:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_NAS_SET_TECHNOLOGY_PREFERENCE:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_NAS_GET_TECHNOLOGY_PREFERENCE:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_NAS_GET_RF_BAND_INFORMATION:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_NAS_SET_SYSTEM_SELECTION_PREFERENCE:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_NAS_GET_SYSTEM_SELECTION_PREFERENCE:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_NAS_GET_SYSTEM_INFO:
        *major = 1;
        *minor = 8;
        return TRUE;
    case QMI_MESSAGE_NAS_GET_SIGNAL_INFO:
        *major = 1;
        *minor = 8;
        return TRUE;
    case QMI_MESSAGE_NAS_CONFIG_SIGNAL_INFO:
        *major = 1;
        *minor = 8;
        return TRUE;
    case QMI_MESSAGE_NAS_GET_CDMA_POSITION_INFO:
        *major = 1;
        *minor = 3;
        return TRUE;
    default:
        return FALSE;
    }
}

/*****************************************************************************/
/* CLIENT: QMI Client NAS */


/**
 * SECTION: qmi-client-nas
 * @title: QmiClientNas
 * @short_description: #QmiClient for the NAS service.
 *
 * #QmiClient which handles operations in the NAS service.
 */

G_DEFINE_TYPE (QmiClientNas, qmi_client_nas, QMI_TYPE_CLIENT);

enum {
    SIGNAL_EVENT_REPORT,
    SIGNAL_SERVING_SYSTEM,
    SIGNAL_NETWORK_TIME,
    SIGNAL_SYSTEM_INFO,
    SIGNAL_SIGNAL_INFO,
    SIGNAL_LAST
};

static guint signals[SIGNAL_LAST] = { 0 };

static void
process_indication (QmiClient *self,
                    QmiMessage *message)
{
    switch (qmi_message_get_message_id (message)) {
        case QMI_INDICATION_NAS_EVENT_REPORT: {
            QmiIndicationNasEventReportOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_event_report_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Event Report' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_EVENT_REPORT], 0, output);
                qmi_indication_nas_event_report_output_unref (output);
            }
            break;
        }
        case QMI_INDICATION_NAS_SERVING_SYSTEM: {
            QmiIndicationNasServingSystemOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_serving_system_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Serving System' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_SERVING_SYSTEM], 0, output);
                qmi_indication_nas_serving_system_output_unref (output);
            }
            break;
        }
        case QMI_INDICATION_NAS_NETWORK_TIME: {
            QmiIndicationNasNetworkTimeOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_network_time_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Network Time' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_NETWORK_TIME], 0, output);
                qmi_indication_nas_network_time_output_unref (output);
            }
            break;
        }
        case QMI_INDICATION_NAS_SYSTEM_INFO: {
            QmiIndicationNasSystemInfoOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_system_info_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'System Info' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_SYSTEM_INFO], 0, output);
                qmi_indication_nas_system_info_output_unref (output);
            }
            break;
        }
        case QMI_INDICATION_NAS_SIGNAL_INFO: {
            QmiIndicationNasSignalInfoOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_nas_signal_info_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Signal Info' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_SIGNAL_INFO], 0, output);
                qmi_indication_nas_signal_info_output_unref (output);
            }
            break;
        }
        default:
            break;
    }
}

static void
qmi_client_nas_init (QmiClientNas *self)
{
}

static void
qmi_client_nas_class_init (QmiClientNasClass *klass)
{
    QmiClientClass *client_class = QMI_CLIENT_CLASS (klass);

    client_class->process_indication = process_indication;

    /**
     * QmiClientNas::event-report:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasEventReportOutput.
     *
     * The ::event-report signal gets emitted when a '<link linkend="libqmi-glib-NAS-Event-Report.top_of_page">Event Report</link>' indication is received.
     */
    signals[SIGNAL_EVENT_REPORT] =
        g_signal_new ("event-report",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_EVENT_REPORT_OUTPUT);

    /**
     * QmiClientNas::serving-system:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasServingSystemOutput.
     *
     * The ::serving-system signal gets emitted when a '<link linkend="libqmi-glib-NAS-Serving-System.top_of_page">Serving System</link>' indication is received.
     */
    signals[SIGNAL_SERVING_SYSTEM] =
        g_signal_new ("serving-system",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_SERVING_SYSTEM_OUTPUT);

    /**
     * QmiClientNas::network-time:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasNetworkTimeOutput.
     *
     * The ::network-time signal gets emitted when a '<link linkend="libqmi-glib-NAS-Network-Time.top_of_page">Network Time</link>' indication is received.
     */
    signals[SIGNAL_NETWORK_TIME] =
        g_signal_new ("network-time",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_NETWORK_TIME_OUTPUT);

    /**
     * QmiClientNas::system-info:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasSystemInfoOutput.
     *
     * The ::system-info signal gets emitted when a '<link linkend="libqmi-glib-NAS-System-Info.top_of_page">System Info</link>' indication is received.
     */
    signals[SIGNAL_SYSTEM_INFO] =
        g_signal_new ("system-info",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_SYSTEM_INFO_OUTPUT);

    /**
     * QmiClientNas::signal-info:
     * @object: A #QmiClientNas.
     * @output: A #QmiIndicationNasSignalInfoOutput.
     *
     * The ::signal-info signal gets emitted when a '<link linkend="libqmi-glib-NAS-Signal-Info.top_of_page">Signal Info</link>' indication is received.
     */
    signals[SIGNAL_SIGNAL_INFO] =
        g_signal_new ("signal-info",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_NAS_SIGNAL_INFO_OUTPUT);
}


/**
 * qmi_client_nas_reset_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_reset().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_reset().
 *
 * Returns: a #QmiMessageNasResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_reset_output_unref().
 */
QmiMessageNasResetOutput *
qmi_client_nas_reset_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_reset_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
reset_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasResetOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_reset_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_reset_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_reset:
 * @self: a #QmiClientNas.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Reset request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_reset_finish() to get the result of the operation.
 */
void
qmi_client_nas_reset (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_reset);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_reset_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)reset_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_set_event_report_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_event_report().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_set_event_report().
 *
 * Returns: a #QmiMessageNasSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_event_report_output_unref().
 */
QmiMessageNasSetEventReportOutput *
qmi_client_nas_set_event_report_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_set_event_report_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_event_report_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasSetEventReportOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_set_event_report_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_set_event_report_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_set_event_report:
 * @self: a #QmiClientNas.
 * @input: a #QmiMessageNasSetEventReportInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set Event Report request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_set_event_report_finish() to get the result of the operation.
 */
void
qmi_client_nas_set_event_report (
    QmiClientNas *self,
    QmiMessageNasSetEventReportInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_set_event_report);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_set_event_report_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_event_report_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_register_indications_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_register_indications().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_register_indications().
 *
 * Returns: a #QmiMessageNasRegisterIndicationsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_register_indications_output_unref().
 */
QmiMessageNasRegisterIndicationsOutput *
qmi_client_nas_register_indications_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_register_indications_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
register_indications_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasRegisterIndicationsOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_register_indications_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_register_indications_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_register_indications:
 * @self: a #QmiClientNas.
 * @input: a #QmiMessageNasRegisterIndicationsInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Register Indications request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_register_indications_finish() to get the result of the operation.
 */
void
qmi_client_nas_register_indications (
    QmiClientNas *self,
    QmiMessageNasRegisterIndicationsInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_register_indications);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_register_indications_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)register_indications_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_get_signal_strength_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_signal_strength().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_get_signal_strength().
 *
 * Returns: a #QmiMessageNasGetSignalStrengthOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_signal_strength_output_unref().
 */
QmiMessageNasGetSignalStrengthOutput *
qmi_client_nas_get_signal_strength_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_get_signal_strength_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_signal_strength_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetSignalStrengthOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_signal_strength_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_get_signal_strength_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_get_signal_strength:
 * @self: a #QmiClientNas.
 * @input: a #QmiMessageNasGetSignalStrengthInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Signal Strength request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_get_signal_strength_finish() to get the result of the operation.
 */
void
qmi_client_nas_get_signal_strength (
    QmiClientNas *self,
    QmiMessageNasGetSignalStrengthInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_get_signal_strength);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_signal_strength_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_signal_strength_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_network_scan_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_network_scan().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_network_scan().
 *
 * Returns: a #QmiMessageNasNetworkScanOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_network_scan_output_unref().
 */
QmiMessageNasNetworkScanOutput *
qmi_client_nas_network_scan_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_network_scan_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
network_scan_abort_ready (
    QmiDevice *device,
    GAsyncResult *res)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasAbortOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (reply) {
        output = __qmi_message_nas_abort_response_parse (reply, &error);
        if (output)
            qmi_message_nas_abort_output_unref (output);
        qmi_message_unref (reply);
    }

    if (error) {
        g_debug ("Operation to abort 'Network Scan' failed: %s", error->message);
        g_error_free (error);
    }
}

static void
network_scan_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasNetworkScanOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        if (g_error_matches (error, QMI_CORE_ERROR, QMI_CORE_ERROR_TIMEOUT) ||
            g_error_matches (error, QMI_PROTOCOL_ERROR, QMI_PROTOCOL_ERROR_ABORTED)) {
                QmiMessage *abort;
                GObject *self;
                guint16 transaction_id;
                QmiMessageNasAbortInput *input;

                self = g_async_result_get_source_object (G_ASYNC_RESULT (simple));
                g_assert (self != NULL);

                transaction_id = (guint16) GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (simple),
                                                                                "transaction-id"));
                g_assert (transaction_id != 0);

                input = qmi_message_nas_abort_input_new ();
                qmi_message_nas_abort_input_set_transaction_id (
                    input,
                    transaction_id,
                    NULL);
                abort = __qmi_message_nas_abort_request_create (
                            qmi_client_get_next_transaction_id (QMI_CLIENT (self)),
                            qmi_client_get_cid (QMI_CLIENT (self)),
                            input,
                            NULL);
                g_assert (abort != NULL);
                qmi_device_command (device,
                                    abort,
                                    30,
                                    NULL,
                                    (GAsyncReadyCallback)network_scan_abort_ready,
                                    NULL);
                qmi_message_nas_abort_input_unref (input);
                qmi_message_unref (abort);
                g_object_unref (self);
            }

        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_network_scan_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_network_scan_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_network_scan:
 * @self: a #QmiClientNas.
 * @input: a #QmiMessageNasNetworkScanInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Network Scan request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_network_scan_finish() to get the result of the operation.
 */
void
qmi_client_nas_network_scan (
    QmiClientNas *self,
    QmiMessageNasNetworkScanInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_network_scan);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_network_scan_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    g_object_set_data (G_OBJECT (result),
                       "transaction-id",
                       GUINT_TO_POINTER (transaction_id));

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)network_scan_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_initiate_network_register_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_initiate_network_register().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_initiate_network_register().
 *
 * Returns: a #QmiMessageNasInitiateNetworkRegisterOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_initiate_network_register_output_unref().
 */
QmiMessageNasInitiateNetworkRegisterOutput *
qmi_client_nas_initiate_network_register_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_initiate_network_register_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
initiate_network_register_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasInitiateNetworkRegisterOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_initiate_network_register_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_initiate_network_register_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_initiate_network_register:
 * @self: a #QmiClientNas.
 * @input: a #QmiMessageNasInitiateNetworkRegisterInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Initiate Network Register request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_initiate_network_register_finish() to get the result of the operation.
 */
void
qmi_client_nas_initiate_network_register (
    QmiClientNas *self,
    QmiMessageNasInitiateNetworkRegisterInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_initiate_network_register);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_initiate_network_register_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)initiate_network_register_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_get_serving_system_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_serving_system().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_get_serving_system().
 *
 * Returns: a #QmiMessageNasGetServingSystemOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_serving_system_output_unref().
 */
QmiMessageNasGetServingSystemOutput *
qmi_client_nas_get_serving_system_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_get_serving_system_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_serving_system_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetServingSystemOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_serving_system_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_get_serving_system_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_get_serving_system:
 * @self: a #QmiClientNas.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Serving System request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_get_serving_system_finish() to get the result of the operation.
 */
void
qmi_client_nas_get_serving_system (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_get_serving_system);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_serving_system_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_serving_system_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_get_home_network_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_home_network().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_get_home_network().
 *
 * Returns: a #QmiMessageNasGetHomeNetworkOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_home_network_output_unref().
 */
QmiMessageNasGetHomeNetworkOutput *
qmi_client_nas_get_home_network_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_get_home_network_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_home_network_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetHomeNetworkOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_home_network_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_get_home_network_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_get_home_network:
 * @self: a #QmiClientNas.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Home Network request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_get_home_network_finish() to get the result of the operation.
 */
void
qmi_client_nas_get_home_network (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_get_home_network);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_home_network_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_home_network_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_set_technology_preference_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_technology_preference().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_set_technology_preference().
 *
 * Returns: a #QmiMessageNasSetTechnologyPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_technology_preference_output_unref().
 */
QmiMessageNasSetTechnologyPreferenceOutput *
qmi_client_nas_set_technology_preference_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_set_technology_preference_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_technology_preference_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasSetTechnologyPreferenceOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_set_technology_preference_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_set_technology_preference_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_set_technology_preference:
 * @self: a #QmiClientNas.
 * @input: a #QmiMessageNasSetTechnologyPreferenceInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set Technology Preference request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_set_technology_preference_finish() to get the result of the operation.
 */
void
qmi_client_nas_set_technology_preference (
    QmiClientNas *self,
    QmiMessageNasSetTechnologyPreferenceInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_set_technology_preference);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_set_technology_preference_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_technology_preference_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_get_technology_preference_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_technology_preference().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_get_technology_preference().
 *
 * Returns: a #QmiMessageNasGetTechnologyPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_technology_preference_output_unref().
 */
QmiMessageNasGetTechnologyPreferenceOutput *
qmi_client_nas_get_technology_preference_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_get_technology_preference_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_technology_preference_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetTechnologyPreferenceOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_technology_preference_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_get_technology_preference_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_get_technology_preference:
 * @self: a #QmiClientNas.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Technology Preference request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_get_technology_preference_finish() to get the result of the operation.
 */
void
qmi_client_nas_get_technology_preference (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_get_technology_preference);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_technology_preference_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_technology_preference_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_get_rf_band_information_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_rf_band_information().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_get_rf_band_information().
 *
 * Returns: a #QmiMessageNasGetRfBandInformationOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_rf_band_information_output_unref().
 */
QmiMessageNasGetRfBandInformationOutput *
qmi_client_nas_get_rf_band_information_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_get_rf_band_information_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_rf_band_information_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetRfBandInformationOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_rf_band_information_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_get_rf_band_information_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_get_rf_band_information:
 * @self: a #QmiClientNas.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get RF Band Information request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_get_rf_band_information_finish() to get the result of the operation.
 */
void
qmi_client_nas_get_rf_band_information (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_get_rf_band_information);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_rf_band_information_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_rf_band_information_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_set_system_selection_preference_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_set_system_selection_preference().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_set_system_selection_preference().
 *
 * Returns: a #QmiMessageNasSetSystemSelectionPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_set_system_selection_preference_output_unref().
 */
QmiMessageNasSetSystemSelectionPreferenceOutput *
qmi_client_nas_set_system_selection_preference_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_set_system_selection_preference_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_system_selection_preference_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasSetSystemSelectionPreferenceOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_set_system_selection_preference_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_set_system_selection_preference_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_set_system_selection_preference:
 * @self: a #QmiClientNas.
 * @input: a #QmiMessageNasSetSystemSelectionPreferenceInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set System Selection Preference request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_set_system_selection_preference_finish() to get the result of the operation.
 */
void
qmi_client_nas_set_system_selection_preference (
    QmiClientNas *self,
    QmiMessageNasSetSystemSelectionPreferenceInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_set_system_selection_preference);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_set_system_selection_preference_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_system_selection_preference_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_get_system_selection_preference_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_system_selection_preference().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_get_system_selection_preference().
 *
 * Returns: a #QmiMessageNasGetSystemSelectionPreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_system_selection_preference_output_unref().
 */
QmiMessageNasGetSystemSelectionPreferenceOutput *
qmi_client_nas_get_system_selection_preference_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_get_system_selection_preference_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_system_selection_preference_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetSystemSelectionPreferenceOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_system_selection_preference_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_get_system_selection_preference_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_get_system_selection_preference:
 * @self: a #QmiClientNas.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get System Selection Preference request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_get_system_selection_preference_finish() to get the result of the operation.
 */
void
qmi_client_nas_get_system_selection_preference (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_get_system_selection_preference);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_system_selection_preference_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_system_selection_preference_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_get_system_info_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_system_info().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_get_system_info().
 *
 * Returns: a #QmiMessageNasGetSystemInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_system_info_output_unref().
 */
QmiMessageNasGetSystemInfoOutput *
qmi_client_nas_get_system_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_get_system_info_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_system_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetSystemInfoOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_system_info_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_get_system_info_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_get_system_info:
 * @self: a #QmiClientNas.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get System Info request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_get_system_info_finish() to get the result of the operation.
 */
void
qmi_client_nas_get_system_info (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_get_system_info);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_system_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_system_info_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_get_signal_info_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_signal_info().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_get_signal_info().
 *
 * Returns: a #QmiMessageNasGetSignalInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_signal_info_output_unref().
 */
QmiMessageNasGetSignalInfoOutput *
qmi_client_nas_get_signal_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_get_signal_info_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_signal_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetSignalInfoOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_signal_info_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_get_signal_info_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_get_signal_info:
 * @self: a #QmiClientNas.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Signal Info request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_get_signal_info_finish() to get the result of the operation.
 */
void
qmi_client_nas_get_signal_info (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_get_signal_info);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_signal_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_signal_info_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_config_signal_info_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_config_signal_info().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_config_signal_info().
 *
 * Returns: a #QmiMessageNasConfigSignalInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_config_signal_info_output_unref().
 */
QmiMessageNasConfigSignalInfoOutput *
qmi_client_nas_config_signal_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_config_signal_info_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
config_signal_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasConfigSignalInfoOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_config_signal_info_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_config_signal_info_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_config_signal_info:
 * @self: a #QmiClientNas.
 * @input: a #QmiMessageNasConfigSignalInfoInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Config Signal Info request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_config_signal_info_finish() to get the result of the operation.
 */
void
qmi_client_nas_config_signal_info (
    QmiClientNas *self,
    QmiMessageNasConfigSignalInfoInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_config_signal_info);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_config_signal_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)config_signal_info_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_nas_get_cdma_position_info_finish:
 * @self: a #QmiClientNas.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_nas_get_cdma_position_info().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_nas_get_cdma_position_info().
 *
 * Returns: a #QmiMessageNasGetCdmaPositionInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_nas_get_cdma_position_info_output_unref().
 */
QmiMessageNasGetCdmaPositionInfoOutput *
qmi_client_nas_get_cdma_position_info_finish (
    QmiClientNas *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_nas_get_cdma_position_info_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_cdma_position_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageNasGetCdmaPositionInfoOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_nas_get_cdma_position_info_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_nas_get_cdma_position_info_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_nas_get_cdma_position_info:
 * @self: a #QmiClientNas.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get CDMA Position Info request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_nas_get_cdma_position_info_finish() to get the result of the operation.
 */
void
qmi_client_nas_get_cdma_position_info (
    QmiClientNas *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_nas_get_cdma_position_info);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_nas_get_cdma_position_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_cdma_position_info_ready,
                        result);
    qmi_message_unref (request);
}

