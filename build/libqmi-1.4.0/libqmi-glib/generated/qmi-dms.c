
/* GENERATED CODE... DO NOT EDIT */

/*
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301 USA.
 *
 * Copyright (C) 2012 Lanedo GmbH
 */


#include <string.h>

#include "qmi-dms.h"
#include "qmi-enum-types.h"
#include "qmi-enum-types-private.h"
#include "qmi-flags64-types.h"
#include "qmi-error-types.h"
#include "qmi-device.h"
#include "qmi-utils.h"

#define QMI_STATUS_SUCCESS 0x0000
#define QMI_STATUS_FAILURE 0x0001


typedef enum {
    QMI_MESSAGE_DMS_RESET = 0x0000,
    QMI_MESSAGE_DMS_SET_EVENT_REPORT = 0x0001,
    QMI_MESSAGE_DMS_GET_CAPABILITIES = 0x0020,
    QMI_MESSAGE_DMS_GET_MANUFACTURER = 0x0021,
    QMI_MESSAGE_DMS_GET_MODEL = 0x0022,
    QMI_MESSAGE_DMS_GET_REVISION = 0x0023,
    QMI_MESSAGE_DMS_GET_MSISDN = 0x0024,
    QMI_MESSAGE_DMS_GET_IDS = 0x0025,
    QMI_MESSAGE_DMS_GET_POWER_STATE = 0x0026,
    QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION = 0x0027,
    QMI_MESSAGE_DMS_UIM_VERIFY_PIN = 0x0028,
    QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN = 0x0029,
    QMI_MESSAGE_DMS_UIM_CHANGE_PIN = 0x002A,
    QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS = 0x002B,
    QMI_MESSAGE_DMS_GET_HARDWARE_REVISION = 0x002C,
    QMI_MESSAGE_DMS_GET_OPERATING_MODE = 0x002D,
    QMI_MESSAGE_DMS_SET_OPERATING_MODE = 0x002E,
    QMI_MESSAGE_DMS_GET_TIME = 0x002F,
    QMI_MESSAGE_DMS_GET_PRL_VERSION = 0x0030,
    QMI_MESSAGE_DMS_GET_ACTIVATION_STATE = 0x0031,
    QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC = 0x0032,
    QMI_MESSAGE_DMS_ACTIVATE_MANUAL = 0x0033,
    QMI_MESSAGE_DMS_GET_USER_LOCK_STATE = 0x0034,
    QMI_MESSAGE_DMS_SET_USER_LOCK_STATE = 0x0035,
    QMI_MESSAGE_DMS_SET_USER_LOCK_CODE = 0x0036,
    QMI_MESSAGE_DMS_READ_USER_DATA = 0x0037,
    QMI_MESSAGE_DMS_WRITE_USER_DATA = 0x0038,
    QMI_MESSAGE_DMS_READ_ERI_FILE = 0x0039,
    QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS = 0x003A,
    QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE = 0x003B,
    QMI_MESSAGE_DMS_UIM_GET_ICCID = 0x003C,
    QMI_MESSAGE_DMS_UIM_GET_CK_STATUS = 0x0040,
    QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION = 0x0041,
    QMI_MESSAGE_DMS_UIM_UNBLOCK_CK = 0x0042,
    QMI_MESSAGE_DMS_UIM_GET_IMSI = 0x0043,
    QMI_MESSAGE_DMS_UIM_GET_STATE = 0x0044,
    QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES = 0x0045,
    QMI_MESSAGE_DMS_GET_FACTORY_SKU = 0x0046,
    QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE = 0x0047,
    QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE = 0x0048,
    QMI_MESSAGE_DMS_LIST_STORED_IMAGES = 0x0049,
    QMI_MESSAGE_DMS_DELETE_STORED_IMAGE = 0x004A,
    QMI_MESSAGE_DMS_SET_TIME = 0x004B,
    QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO = 0x004C,
    QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG = 0x004D,
    QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG = 0x004E,
    QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION = 0x0051,
    QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE = 0x0052,
} QmiMessageDms;


typedef enum {
    QMI_INDICATION_DMS_EVENT_REPORT = 0x0001,
} QmiIndicationDms;


/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Reset */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_reset_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_RESET);

    return self;
}

/* --- Output -- */

/**
 * QmiMessageResult:
 * @error_status: a #guint16.
 * @error_code: a #guint16.
 *
 * A QmiMessageResult struct.
 */
typedef struct _QmiMessageResult {
    guint16 error_status;
    guint16 error_code;
} QmiMessageResult;

struct _QmiMessageDmsResetOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_RESET_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_reset_output_get_result:
 * @self: a QmiMessageDmsResetOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_reset_output_get_result (
    QmiMessageDmsResetOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_reset_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsResetOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_reset_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_reset_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_reset_output_ref:
 * @self: a #QmiMessageDmsResetOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsResetOutput *
qmi_message_dms_reset_output_ref (QmiMessageDmsResetOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_reset_output_unref:
 * @self: a #QmiMessageDmsResetOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_reset_output_unref (QmiMessageDmsResetOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsResetOutput, self);
    }
}

static gboolean
qmi_message_result_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    static const guint expected_len = 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Result' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    return TRUE;
}

static gchar *
qmi_message_result_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (self,
                                      QMI_MESSAGE_DMS_RESET_OUTPUT_TLV_RESULT,
                                      &buffer_len);
    if (buffer) {
        GString *printable;
        guint16 error_status;
        guint16 error_code;

        printable = g_string_new ("");
        qmi_utils_read_guint16_from_buffer (
            &buffer,
            &buffer_len,
            QMI_ENDIAN_LITTLE,
            &error_status);
        qmi_utils_read_guint16_from_buffer (
            &buffer,
            &buffer_len,
            QMI_ENDIAN_LITTLE,
            &error_code);

        g_warn_if_fail (buffer_len == 0);

        if (error_status == QMI_STATUS_SUCCESS)
            g_string_append (printable, "SUCCESS");
        else
            g_string_append_printf (printable,
                                    "FAILURE: %s",
                                    qmi_protocol_error_get_string ((QmiProtocolError) error_code));

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_reset_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_reset_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_reset_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_RESET_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_reset_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Reset\" (0x0000)\n",
                            line_prefix);

    {
        struct message_reset_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_reset_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsResetOutput *
__qmi_message_dms_reset_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsResetOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_RESET, NULL);

    self = g_slice_new0 (QmiMessageDmsResetOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_RESET_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_reset_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Set Event Report */


/* --- Input -- */

struct _QmiMessageDmsSetEventReportInput {
    volatile gint ref_count;

    /* PRL Init Reporting */
    gboolean arg_prl_init_reporting_set;
    guint8 arg_prl_init_reporting;

    /* Wireless Disable State Reporting */
    gboolean arg_wireless_disable_state_reporting_set;
    guint8 arg_wireless_disable_state_reporting;

    /* UIM State Reporting */
    gboolean arg_uim_state_reporting_set;
    guint8 arg_uim_state_reporting;

    /* Operating Mode Reporting */
    gboolean arg_operating_mode_reporting_set;
    guint8 arg_operating_mode_reporting;

    /* Activation State Reporting */
    gboolean arg_activation_state_reporting_set;
    guint8 arg_activation_state_reporting;

    /* PIN State Reporting */
    gboolean arg_pin_state_reporting_set;
    guint8 arg_pin_state_reporting;

    /* Battery Level Report Limits */
    gboolean arg_battery_level_report_limits_set;
    guint8 arg_battery_level_report_limits_lower_limit;
    guint8 arg_battery_level_report_limits_upper_limit;

    /* Power State Reporting */
    gboolean arg_power_state_reporting_set;
    guint8 arg_power_state_reporting;
};

#define QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_PRL_INIT_REPORTING 0x17
#define QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_WIRELESS_DISABLE_STATE_REPORTING 0x16
#define QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_UIM_STATE_REPORTING 0x15
#define QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_OPERATING_MODE_REPORTING 0x14
#define QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_ACTIVATION_STATE_REPORTING 0x13
#define QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_PIN_STATE_REPORTING 0x12
#define QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_BATTERY_LEVEL_REPORT_LIMITS 0x11
#define QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_POWER_STATE_REPORTING 0x10

/**
 * qmi_message_dms_set_event_report_input_get_prl_init_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @prl_init_reporting: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PRL Init Reporting' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_get_prl_init_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean *prl_init_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_prl_init_reporting_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PRL Init Reporting' was not found in the message");
        return FALSE;
    }

    if (prl_init_reporting)
        *prl_init_reporting = (gboolean)(self->arg_prl_init_reporting);

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_set_prl_init_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @prl_init_reporting: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'PRL Init Reporting' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_set_prl_init_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean prl_init_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_prl_init_reporting = (guint8)(prl_init_reporting);
    self->arg_prl_init_reporting_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_get_wireless_disable_state_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @wireless_disable_state_reporting: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Wireless Disable State Reporting' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_get_wireless_disable_state_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean *wireless_disable_state_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wireless_disable_state_reporting_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Wireless Disable State Reporting' was not found in the message");
        return FALSE;
    }

    if (wireless_disable_state_reporting)
        *wireless_disable_state_reporting = (gboolean)(self->arg_wireless_disable_state_reporting);

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_set_wireless_disable_state_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @wireless_disable_state_reporting: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Wireless Disable State Reporting' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_set_wireless_disable_state_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean wireless_disable_state_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_wireless_disable_state_reporting = (guint8)(wireless_disable_state_reporting);
    self->arg_wireless_disable_state_reporting_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_get_uim_state_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @uim_state_reporting: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'UIM State Reporting' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_get_uim_state_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean *uim_state_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_uim_state_reporting_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'UIM State Reporting' was not found in the message");
        return FALSE;
    }

    if (uim_state_reporting)
        *uim_state_reporting = (gboolean)(self->arg_uim_state_reporting);

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_set_uim_state_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @uim_state_reporting: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'UIM State Reporting' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_set_uim_state_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean uim_state_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_uim_state_reporting = (guint8)(uim_state_reporting);
    self->arg_uim_state_reporting_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_get_operating_mode_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @operating_mode_reporting: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Operating Mode Reporting' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_get_operating_mode_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean *operating_mode_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_operating_mode_reporting_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Operating Mode Reporting' was not found in the message");
        return FALSE;
    }

    if (operating_mode_reporting)
        *operating_mode_reporting = (gboolean)(self->arg_operating_mode_reporting);

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_set_operating_mode_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @operating_mode_reporting: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Operating Mode Reporting' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_set_operating_mode_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean operating_mode_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_operating_mode_reporting = (guint8)(operating_mode_reporting);
    self->arg_operating_mode_reporting_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_get_activation_state_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @activation_state_reporting: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Activation State Reporting' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_get_activation_state_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean *activation_state_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_activation_state_reporting_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Activation State Reporting' was not found in the message");
        return FALSE;
    }

    if (activation_state_reporting)
        *activation_state_reporting = (gboolean)(self->arg_activation_state_reporting);

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_set_activation_state_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @activation_state_reporting: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Activation State Reporting' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_set_activation_state_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean activation_state_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_activation_state_reporting = (guint8)(activation_state_reporting);
    self->arg_activation_state_reporting_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_get_pin_state_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @pin_state_reporting: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PIN State Reporting' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_get_pin_state_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean *pin_state_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_pin_state_reporting_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PIN State Reporting' was not found in the message");
        return FALSE;
    }

    if (pin_state_reporting)
        *pin_state_reporting = (gboolean)(self->arg_pin_state_reporting);

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_set_pin_state_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @pin_state_reporting: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'PIN State Reporting' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_set_pin_state_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean pin_state_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_pin_state_reporting = (guint8)(pin_state_reporting);
    self->arg_pin_state_reporting_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_get_battery_level_report_limits:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @battery_level_report_limits_lower_limit: a placeholder for the output #guint8, or %NULL if not required.
 * @battery_level_report_limits_upper_limit: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Battery Level Report Limits' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_get_battery_level_report_limits (
    QmiMessageDmsSetEventReportInput *self,
    guint8 *battery_level_report_limits_lower_limit,
    guint8 *battery_level_report_limits_upper_limit,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_battery_level_report_limits_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Battery Level Report Limits' was not found in the message");
        return FALSE;
    }

    if (battery_level_report_limits_lower_limit)
        *battery_level_report_limits_lower_limit = self->arg_battery_level_report_limits_lower_limit;
    if (battery_level_report_limits_upper_limit)
        *battery_level_report_limits_upper_limit = self->arg_battery_level_report_limits_upper_limit;

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_set_battery_level_report_limits:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @battery_level_report_limits_lower_limit: a #guint8.
 * @battery_level_report_limits_upper_limit: a #guint8.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Battery Level Report Limits' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_set_battery_level_report_limits (
    QmiMessageDmsSetEventReportInput *self,
    guint8 battery_level_report_limits_lower_limit,
    guint8 battery_level_report_limits_upper_limit,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_battery_level_report_limits_lower_limit = battery_level_report_limits_lower_limit;
    self->arg_battery_level_report_limits_upper_limit = battery_level_report_limits_upper_limit;
    self->arg_battery_level_report_limits_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_get_power_state_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @power_state_reporting: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Power State Reporting' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_get_power_state_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean *power_state_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_power_state_reporting_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Power State Reporting' was not found in the message");
        return FALSE;
    }

    if (power_state_reporting)
        *power_state_reporting = (gboolean)(self->arg_power_state_reporting);

    return TRUE;
}

/**
 * qmi_message_dms_set_event_report_input_set_power_state_reporting:
 * @self: a #QmiMessageDmsSetEventReportInput.
 * @power_state_reporting: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Power State Reporting' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_event_report_input_set_power_state_reporting (
    QmiMessageDmsSetEventReportInput *self,
    gboolean power_state_reporting,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_power_state_reporting = (guint8)(power_state_reporting);
    self->arg_power_state_reporting_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_set_event_report_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetEventReportInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_event_report_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_event_report_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_event_report_input_ref:
 * @self: a #QmiMessageDmsSetEventReportInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetEventReportInput *
qmi_message_dms_set_event_report_input_ref (QmiMessageDmsSetEventReportInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_event_report_input_unref:
 * @self: a #QmiMessageDmsSetEventReportInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_event_report_input_unref (QmiMessageDmsSetEventReportInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetEventReportInput, self);
    }
}

/**
 * qmi_message_dms_set_event_report_input_new:
 *
 * Allocates a new #QmiMessageDmsSetEventReportInput.
 *
 * Returns: the newly created #QmiMessageDmsSetEventReportInput. The returned value should be freed with qmi_message_dms_set_event_report_input_unref().
 */
QmiMessageDmsSetEventReportInput *
qmi_message_dms_set_event_report_input_new (void)
{
    QmiMessageDmsSetEventReportInput *self;

    self = g_slice_new0 (QmiMessageDmsSetEventReportInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_set_event_report_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsSetEventReportInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_SET_EVENT_REPORT);

    /* All TLVs are optional, we allow NULL input */
    if (!input)
        return self;

    /* Try to add the 'PRL Init Reporting' TLV */
    if (input->arg_prl_init_reporting_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_prl_init_reporting;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_PRL_INIT_REPORTING,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the PRL Init Reporting TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Wireless Disable State Reporting' TLV */
    if (input->arg_wireless_disable_state_reporting_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_wireless_disable_state_reporting;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_WIRELESS_DISABLE_STATE_REPORTING,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Wireless Disable State Reporting TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'UIM State Reporting' TLV */
    if (input->arg_uim_state_reporting_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_uim_state_reporting;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_UIM_STATE_REPORTING,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the UIM State Reporting TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Operating Mode Reporting' TLV */
    if (input->arg_operating_mode_reporting_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_operating_mode_reporting;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_OPERATING_MODE_REPORTING,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Operating Mode Reporting TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Activation State Reporting' TLV */
    if (input->arg_activation_state_reporting_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_activation_state_reporting;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_ACTIVATION_STATE_REPORTING,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Activation State Reporting TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'PIN State Reporting' TLV */
    if (input->arg_pin_state_reporting_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_pin_state_reporting;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_PIN_STATE_REPORTING,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the PIN State Reporting TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Battery Level Report Limits' TLV */
    if (input->arg_battery_level_report_limits_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_battery_level_report_limits_lower_limit));
        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_battery_level_report_limits_upper_limit));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_BATTERY_LEVEL_REPORT_LIMITS,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Battery Level Report Limits TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Power State Reporting' TLV */
    if (input->arg_power_state_reporting_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_power_state_reporting;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_POWER_STATE_REPORTING,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Power State Reporting TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsSetEventReportOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_SET_EVENT_REPORT_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_set_event_report_output_get_result:
 * @self: a QmiMessageDmsSetEventReportOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_set_event_report_output_get_result (
    QmiMessageDmsSetEventReportOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_set_event_report_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetEventReportOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_event_report_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_event_report_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_event_report_output_ref:
 * @self: a #QmiMessageDmsSetEventReportOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetEventReportOutput *
qmi_message_dms_set_event_report_output_ref (QmiMessageDmsSetEventReportOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_event_report_output_unref:
 * @self: a #QmiMessageDmsSetEventReportOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_event_report_output_unref (QmiMessageDmsSetEventReportOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetEventReportOutput, self);
    }
}

static gboolean
qmi_message_dms_set_event_report_input_prl_init_reporting_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PRL Init Reporting' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PRL Init Reporting' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_event_report_input_prl_init_reporting_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_PRL_INIT_REPORTING,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_event_report_input_prl_init_reporting_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PRL Init Reporting' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_event_report_input_wireless_disable_state_reporting_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Wireless Disable State Reporting' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Wireless Disable State Reporting' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_event_report_input_wireless_disable_state_reporting_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_WIRELESS_DISABLE_STATE_REPORTING,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_event_report_input_wireless_disable_state_reporting_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Wireless Disable State Reporting' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_event_report_input_uim_state_reporting_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'UIM State Reporting' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'UIM State Reporting' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_event_report_input_uim_state_reporting_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_UIM_STATE_REPORTING,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_event_report_input_uim_state_reporting_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'UIM State Reporting' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_event_report_input_operating_mode_reporting_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Operating Mode Reporting' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Operating Mode Reporting' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_event_report_input_operating_mode_reporting_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_OPERATING_MODE_REPORTING,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_event_report_input_operating_mode_reporting_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Operating Mode Reporting' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_event_report_input_activation_state_reporting_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Activation State Reporting' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Activation State Reporting' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_event_report_input_activation_state_reporting_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_ACTIVATION_STATE_REPORTING,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_event_report_input_activation_state_reporting_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Activation State Reporting' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_event_report_input_pin_state_reporting_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PIN State Reporting' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PIN State Reporting' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_event_report_input_pin_state_reporting_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_PIN_STATE_REPORTING,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_event_report_input_pin_state_reporting_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PIN State Reporting' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_event_report_input_battery_level_report_limits_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Battery Level Report Limits' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Battery Level Report Limits' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_event_report_input_battery_level_report_limits_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_BATTERY_LEVEL_REPORT_LIMITS,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_event_report_input_battery_level_report_limits_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " lower_limit = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " upper_limit = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Battery Level Report Limits' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_event_report_input_power_state_reporting_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Power State Reporting' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Power State Reporting' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_event_report_input_power_state_reporting_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_POWER_STATE_REPORTING,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_event_report_input_power_state_reporting_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Power State Reporting' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_event_report_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_event_report_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_event_report_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_PRL_INIT_REPORTING:
            tlv_type_str = "PRL Init Reporting";
            translated_value = qmi_message_dms_set_event_report_input_prl_init_reporting_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_WIRELESS_DISABLE_STATE_REPORTING:
            tlv_type_str = "Wireless Disable State Reporting";
            translated_value = qmi_message_dms_set_event_report_input_wireless_disable_state_reporting_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_UIM_STATE_REPORTING:
            tlv_type_str = "UIM State Reporting";
            translated_value = qmi_message_dms_set_event_report_input_uim_state_reporting_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_OPERATING_MODE_REPORTING:
            tlv_type_str = "Operating Mode Reporting";
            translated_value = qmi_message_dms_set_event_report_input_operating_mode_reporting_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_ACTIVATION_STATE_REPORTING:
            tlv_type_str = "Activation State Reporting";
            translated_value = qmi_message_dms_set_event_report_input_activation_state_reporting_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_PIN_STATE_REPORTING:
            tlv_type_str = "PIN State Reporting";
            translated_value = qmi_message_dms_set_event_report_input_pin_state_reporting_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_BATTERY_LEVEL_REPORT_LIMITS:
            tlv_type_str = "Battery Level Report Limits";
            translated_value = qmi_message_dms_set_event_report_input_battery_level_report_limits_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_EVENT_REPORT_INPUT_TLV_POWER_STATE_REPORTING:
            tlv_type_str = "Power State Reporting";
            translated_value = qmi_message_dms_set_event_report_input_power_state_reporting_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_EVENT_REPORT_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_event_report_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Event Report\" (0x0001)\n",
                            line_prefix);

    {
        struct message_set_event_report_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_event_report_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsSetEventReportOutput *
__qmi_message_dms_set_event_report_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsSetEventReportOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_SET_EVENT_REPORT, NULL);

    self = g_slice_new0 (QmiMessageDmsSetEventReportOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_SET_EVENT_REPORT_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_set_event_report_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* INDICATION: Qmi Indication DMS Event Report */


/* --- Output -- */

struct _QmiIndicationDmsEventReportOutput {
    volatile gint ref_count;

    /* PRL Init Notification */
    gboolean arg_prl_init_notification_set;
    guint8 arg_prl_init_notification;

    /* Wireless Disable State */
    gboolean arg_wireless_disable_state_set;
    guint8 arg_wireless_disable_state;

    /* UIM State */
    gboolean arg_uim_state_set;
    guint8 arg_uim_state;

    /* Operating Mode */
    gboolean arg_operating_mode_set;
    guint8 arg_operating_mode;

    /* Activation State */
    gboolean arg_activation_state_set;
    guint16 arg_activation_state;

    /* PIN2 Status */
    gboolean arg_pin2_status_set;
    guint8 arg_pin2_status_current_status;
    guint8 arg_pin2_status_verify_retries_left;
    guint8 arg_pin2_status_unblock_retries_left;

    /* PIN1 Status */
    gboolean arg_pin1_status_set;
    guint8 arg_pin1_status_current_status;
    guint8 arg_pin1_status_verify_retries_left;
    guint8 arg_pin1_status_unblock_retries_left;

    /* Power State */
    gboolean arg_power_state_set;
    guint8 arg_power_state_power_state_flags;
    guint8 arg_power_state_battery_level;
};

#define QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PRL_INIT_NOTIFICATION 0x17
#define QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_WIRELESS_DISABLE_STATE 0x16
#define QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_UIM_STATE 0x15
#define QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_OPERATING_MODE 0x14
#define QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_ACTIVATION_STATE 0x13
#define QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PIN2_STATUS 0x12
#define QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PIN1_STATUS 0x11
#define QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_POWER_STATE 0x10

/**
 * qmi_indication_dms_event_report_output_get_prl_init_notification:
 * @self: a #QmiIndicationDmsEventReportOutput.
 * @prl_init_notification: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PRL Init Notification' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_dms_event_report_output_get_prl_init_notification (
    QmiIndicationDmsEventReportOutput *self,
    gboolean *prl_init_notification,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_prl_init_notification_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PRL Init Notification' was not found in the message");
        return FALSE;
    }

    if (prl_init_notification)
        *prl_init_notification = (gboolean)(self->arg_prl_init_notification);

    return TRUE;
}

/**
 * qmi_indication_dms_event_report_output_get_wireless_disable_state:
 * @self: a #QmiIndicationDmsEventReportOutput.
 * @wireless_disable_state: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Wireless Disable State' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_dms_event_report_output_get_wireless_disable_state (
    QmiIndicationDmsEventReportOutput *self,
    gboolean *wireless_disable_state,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_wireless_disable_state_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Wireless Disable State' was not found in the message");
        return FALSE;
    }

    if (wireless_disable_state)
        *wireless_disable_state = (gboolean)(self->arg_wireless_disable_state);

    return TRUE;
}

/**
 * qmi_indication_dms_event_report_output_get_uim_state:
 * @self: a #QmiIndicationDmsEventReportOutput.
 * @uim_state: a placeholder for the output #QmiDmsUimState, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'UIM State' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_dms_event_report_output_get_uim_state (
    QmiIndicationDmsEventReportOutput *self,
    QmiDmsUimState *uim_state,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_uim_state_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'UIM State' was not found in the message");
        return FALSE;
    }

    if (uim_state)
        *uim_state = (QmiDmsUimState)(self->arg_uim_state);

    return TRUE;
}

/**
 * qmi_indication_dms_event_report_output_get_operating_mode:
 * @self: a #QmiIndicationDmsEventReportOutput.
 * @operating_mode: a placeholder for the output #QmiDmsOperatingMode, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Operating Mode' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_dms_event_report_output_get_operating_mode (
    QmiIndicationDmsEventReportOutput *self,
    QmiDmsOperatingMode *operating_mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_operating_mode_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Operating Mode' was not found in the message");
        return FALSE;
    }

    if (operating_mode)
        *operating_mode = (QmiDmsOperatingMode)(self->arg_operating_mode);

    return TRUE;
}

/**
 * qmi_indication_dms_event_report_output_get_activation_state:
 * @self: a #QmiIndicationDmsEventReportOutput.
 * @activation_state: a placeholder for the output #QmiDmsActivationState, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Activation State' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_dms_event_report_output_get_activation_state (
    QmiIndicationDmsEventReportOutput *self,
    QmiDmsActivationState *activation_state,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_activation_state_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Activation State' was not found in the message");
        return FALSE;
    }

    if (activation_state)
        *activation_state = (QmiDmsActivationState)(self->arg_activation_state);

    return TRUE;
}

/**
 * qmi_indication_dms_event_report_output_get_pin2_status:
 * @self: a #QmiIndicationDmsEventReportOutput.
 * @pin2_status_current_status: a placeholder for the output #QmiDmsUimPinStatus, or %NULL if not required.
 * @pin2_status_verify_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @pin2_status_unblock_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PIN2 Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_dms_event_report_output_get_pin2_status (
    QmiIndicationDmsEventReportOutput *self,
    QmiDmsUimPinStatus *pin2_status_current_status,
    guint8 *pin2_status_verify_retries_left,
    guint8 *pin2_status_unblock_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_pin2_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PIN2 Status' was not found in the message");
        return FALSE;
    }

    if (pin2_status_current_status)
        *pin2_status_current_status = (QmiDmsUimPinStatus)(self->arg_pin2_status_current_status);
    if (pin2_status_verify_retries_left)
        *pin2_status_verify_retries_left = self->arg_pin2_status_verify_retries_left;
    if (pin2_status_unblock_retries_left)
        *pin2_status_unblock_retries_left = self->arg_pin2_status_unblock_retries_left;

    return TRUE;
}

/**
 * qmi_indication_dms_event_report_output_get_pin1_status:
 * @self: a #QmiIndicationDmsEventReportOutput.
 * @pin1_status_current_status: a placeholder for the output #QmiDmsUimPinStatus, or %NULL if not required.
 * @pin1_status_verify_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @pin1_status_unblock_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PIN1 Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_dms_event_report_output_get_pin1_status (
    QmiIndicationDmsEventReportOutput *self,
    QmiDmsUimPinStatus *pin1_status_current_status,
    guint8 *pin1_status_verify_retries_left,
    guint8 *pin1_status_unblock_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_pin1_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PIN1 Status' was not found in the message");
        return FALSE;
    }

    if (pin1_status_current_status)
        *pin1_status_current_status = (QmiDmsUimPinStatus)(self->arg_pin1_status_current_status);
    if (pin1_status_verify_retries_left)
        *pin1_status_verify_retries_left = self->arg_pin1_status_verify_retries_left;
    if (pin1_status_unblock_retries_left)
        *pin1_status_unblock_retries_left = self->arg_pin1_status_unblock_retries_left;

    return TRUE;
}

/**
 * qmi_indication_dms_event_report_output_get_power_state:
 * @self: a #QmiIndicationDmsEventReportOutput.
 * @power_state_power_state_flags: a placeholder for the output #guint8, or %NULL if not required.
 * @power_state_battery_level: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Power State' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_indication_dms_event_report_output_get_power_state (
    QmiIndicationDmsEventReportOutput *self,
    guint8 *power_state_power_state_flags,
    guint8 *power_state_battery_level,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_power_state_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Power State' was not found in the message");
        return FALSE;
    }

    if (power_state_power_state_flags)
        *power_state_power_state_flags = self->arg_power_state_power_state_flags;
    if (power_state_battery_level)
        *power_state_battery_level = self->arg_power_state_battery_level;

    return TRUE;
}

GType
qmi_indication_dms_event_report_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiIndicationDmsEventReportOutput"),
                                          (GBoxedCopyFunc) qmi_indication_dms_event_report_output_ref,
                                          (GBoxedFreeFunc) qmi_indication_dms_event_report_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_indication_dms_event_report_output_ref:
 * @self: a #QmiIndicationDmsEventReportOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiIndicationDmsEventReportOutput *
qmi_indication_dms_event_report_output_ref (QmiIndicationDmsEventReportOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_indication_dms_event_report_output_unref:
 * @self: a #QmiIndicationDmsEventReportOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_indication_dms_event_report_output_unref (QmiIndicationDmsEventReportOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiIndicationDmsEventReportOutput, self);
    }
}

static gboolean
qmi_indication_dms_event_report_output_prl_init_notification_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PRL Init Notification' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PRL Init Notification' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_dms_event_report_output_prl_init_notification_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PRL_INIT_NOTIFICATION,
                                      &buffer_len);
    if (buffer && qmi_indication_dms_event_report_output_prl_init_notification_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PRL Init Notification' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_dms_event_report_output_wireless_disable_state_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Wireless Disable State' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Wireless Disable State' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_dms_event_report_output_wireless_disable_state_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_WIRELESS_DISABLE_STATE,
                                      &buffer_len);
    if (buffer && qmi_indication_dms_event_report_output_wireless_disable_state_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Wireless Disable State' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_dms_event_report_output_uim_state_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'UIM State' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'UIM State' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_dms_event_report_output_uim_state_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_UIM_STATE,
                                      &buffer_len);
    if (buffer && qmi_indication_dms_event_report_output_uim_state_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_state_get_string ((QmiDmsUimState)tmp));
#elif defined  __QMI_DMS_UIM_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_state_build_string_from_mask ((QmiDmsUimState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimState
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'UIM State' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_dms_event_report_output_operating_mode_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Operating Mode' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Operating Mode' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_dms_event_report_output_operating_mode_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_OPERATING_MODE,
                                      &buffer_len);
    if (buffer && qmi_indication_dms_event_report_output_operating_mode_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_OPERATING_MODE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_operating_mode_get_string ((QmiDmsOperatingMode)tmp));
#elif defined  __QMI_DMS_OPERATING_MODE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_operating_mode_build_string_from_mask ((QmiDmsOperatingMode)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsOperatingMode
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Operating Mode' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_dms_event_report_output_activation_state_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Activation State' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Activation State' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_dms_event_report_output_activation_state_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_ACTIVATION_STATE,
                                      &buffer_len);
    if (buffer && qmi_indication_dms_event_report_output_activation_state_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_DMS_ACTIVATION_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_activation_state_get_string ((QmiDmsActivationState)tmp));
#elif defined  __QMI_DMS_ACTIVATION_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_activation_state_build_string_from_mask ((QmiDmsActivationState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsActivationState
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Activation State' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_dms_event_report_output_pin2_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PIN2 Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PIN2 Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_dms_event_report_output_pin2_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PIN2_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_dms_event_report_output_pin2_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " current_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_PIN_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_pin_status_get_string ((QmiDmsUimPinStatus)tmp));
#elif defined  __QMI_DMS_UIM_PIN_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_pin_status_build_string_from_mask ((QmiDmsUimPinStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimPinStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " verify_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unblock_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PIN2 Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_dms_event_report_output_pin1_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PIN1 Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PIN1 Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_dms_event_report_output_pin1_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PIN1_STATUS,
                                      &buffer_len);
    if (buffer && qmi_indication_dms_event_report_output_pin1_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " current_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_PIN_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_pin_status_get_string ((QmiDmsUimPinStatus)tmp));
#elif defined  __QMI_DMS_UIM_PIN_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_pin_status_build_string_from_mask ((QmiDmsUimPinStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimPinStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " verify_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unblock_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PIN1 Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_indication_dms_event_report_output_power_state_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Power State' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Power State' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_indication_dms_event_report_output_power_state_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_POWER_STATE,
                                      &buffer_len);
    if (buffer && qmi_indication_dms_event_report_output_power_state_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " power_state_flags = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " battery_level = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Power State' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct indication_event_report_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
indication_event_report_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct indication_event_report_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    {
        switch (type) {
        case QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PRL_INIT_NOTIFICATION:
            tlv_type_str = "PRL Init Notification";
            translated_value = qmi_indication_dms_event_report_output_prl_init_notification_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_WIRELESS_DISABLE_STATE:
            tlv_type_str = "Wireless Disable State";
            translated_value = qmi_indication_dms_event_report_output_wireless_disable_state_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_UIM_STATE:
            tlv_type_str = "UIM State";
            translated_value = qmi_indication_dms_event_report_output_uim_state_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_OPERATING_MODE:
            tlv_type_str = "Operating Mode";
            translated_value = qmi_indication_dms_event_report_output_operating_mode_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_ACTIVATION_STATE:
            tlv_type_str = "Activation State";
            translated_value = qmi_indication_dms_event_report_output_activation_state_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PIN2_STATUS:
            tlv_type_str = "PIN2 Status";
            translated_value = qmi_indication_dms_event_report_output_pin2_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PIN1_STATUS:
            tlv_type_str = "PIN1 Status";
            translated_value = qmi_indication_dms_event_report_output_pin1_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_POWER_STATE:
            tlv_type_str = "Power State";
            translated_value = qmi_indication_dms_event_report_output_power_state_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
indication_event_report_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Event Report\" (0x0001)\n",
                            line_prefix);

    {
        struct indication_event_report_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)indication_event_report_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiIndicationDmsEventReportOutput *
__qmi_indication_dms_event_report_indication_parse (
    QmiMessage *message,
    GError **error)
{
    QmiIndicationDmsEventReportOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_INDICATION_DMS_EVENT_REPORT, NULL);

    self = g_slice_new0 (QmiIndicationDmsEventReportOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PRL_INIT_NOTIFICATION,
                                              &buffer_len);
            if (buffer && qmi_indication_dms_event_report_output_prl_init_notification_validate (buffer, buffer_len)) {
                self->arg_prl_init_notification_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_prl_init_notification = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PRL Init Notification' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_WIRELESS_DISABLE_STATE,
                                              &buffer_len);
            if (buffer && qmi_indication_dms_event_report_output_wireless_disable_state_validate (buffer, buffer_len)) {
                self->arg_wireless_disable_state_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_wireless_disable_state = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Wireless Disable State' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_UIM_STATE,
                                              &buffer_len);
            if (buffer && qmi_indication_dms_event_report_output_uim_state_validate (buffer, buffer_len)) {
                self->arg_uim_state_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_uim_state = (QmiDmsUimState)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'UIM State' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_OPERATING_MODE,
                                              &buffer_len);
            if (buffer && qmi_indication_dms_event_report_output_operating_mode_validate (buffer, buffer_len)) {
                self->arg_operating_mode_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_operating_mode = (QmiDmsOperatingMode)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Operating Mode' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_ACTIVATION_STATE,
                                              &buffer_len);
            if (buffer && qmi_indication_dms_event_report_output_activation_state_validate (buffer, buffer_len)) {
                self->arg_activation_state_set = TRUE;

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_activation_state = (QmiDmsActivationState)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Activation State' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PIN2_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_dms_event_report_output_pin2_status_validate (buffer, buffer_len)) {
                self->arg_pin2_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_pin2_status_current_status = (QmiDmsUimPinStatus)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin2_status_verify_retries_left));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin2_status_unblock_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PIN2 Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_PIN1_STATUS,
                                              &buffer_len);
            if (buffer && qmi_indication_dms_event_report_output_pin1_status_validate (buffer, buffer_len)) {
                self->arg_pin1_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_pin1_status_current_status = (QmiDmsUimPinStatus)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin1_status_verify_retries_left));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin1_status_unblock_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PIN1 Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_INDICATION_DMS_EVENT_REPORT_OUTPUT_TLV_POWER_STATE,
                                              &buffer_len);
            if (buffer && qmi_indication_dms_event_report_output_power_state_validate (buffer, buffer_len)) {
                self->arg_power_state_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_power_state_power_state_flags));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_power_state_battery_level));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Power State' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Capabilities */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_capabilities_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_CAPABILITIES);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetCapabilitiesOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Info */
    gboolean arg_info_set;
    guint32 arg_info_max_tx_channel_rate;
    guint32 arg_info_max_rx_channel_rate;
    guint8 arg_info_data_service_capability;
    guint8 arg_info_sim_capability;
    GArray *arg_info_radio_interface_list;
};

#define QMI_MESSAGE_DMS_GET_CAPABILITIES_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_CAPABILITIES_OUTPUT_TLV_INFO 0x01

/**
 * qmi_message_dms_get_capabilities_output_get_result:
 * @self: a QmiMessageDmsGetCapabilitiesOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_capabilities_output_get_result (
    QmiMessageDmsGetCapabilitiesOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_capabilities_output_get_info:
 * @self: a #QmiMessageDmsGetCapabilitiesOutput.
 * @info_max_tx_channel_rate: a placeholder for the output #guint32, or %NULL if not required.
 * @info_max_rx_channel_rate: a placeholder for the output #guint32, or %NULL if not required.
 * @info_data_service_capability: a placeholder for the output #QmiDmsDataServiceCapability, or %NULL if not required.
 * @info_sim_capability: a placeholder for the output #QmiDmsSimCapability, or %NULL if not required.
 * @info_radio_interface_list: a placeholder for the output #GArray of #QmiDmsRadioInterface elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_capabilities_output_get_info (
    QmiMessageDmsGetCapabilitiesOutput *self,
    guint32 *info_max_tx_channel_rate,
    guint32 *info_max_rx_channel_rate,
    QmiDmsDataServiceCapability *info_data_service_capability,
    QmiDmsSimCapability *info_sim_capability,
    GArray **info_radio_interface_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (info_max_tx_channel_rate)
        *info_max_tx_channel_rate = self->arg_info_max_tx_channel_rate;
    if (info_max_rx_channel_rate)
        *info_max_rx_channel_rate = self->arg_info_max_rx_channel_rate;
    if (info_data_service_capability)
        *info_data_service_capability = (QmiDmsDataServiceCapability)(self->arg_info_data_service_capability);
    if (info_sim_capability)
        *info_sim_capability = (QmiDmsSimCapability)(self->arg_info_sim_capability);
    if (info_radio_interface_list)
        *info_radio_interface_list = self->arg_info_radio_interface_list;

    return TRUE;
}

GType
qmi_message_dms_get_capabilities_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetCapabilitiesOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_capabilities_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_capabilities_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_capabilities_output_ref:
 * @self: a #QmiMessageDmsGetCapabilitiesOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetCapabilitiesOutput *
qmi_message_dms_get_capabilities_output_ref (QmiMessageDmsGetCapabilitiesOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_capabilities_output_unref:
 * @self: a #QmiMessageDmsGetCapabilitiesOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_capabilities_output_unref (QmiMessageDmsGetCapabilitiesOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_info_radio_interface_list)
            g_array_unref (self->arg_info_radio_interface_list);
        g_slice_free (QmiMessageDmsGetCapabilitiesOutput, self);
    }
}

static gboolean
qmi_message_dms_get_capabilities_output_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;
    expected_len += 4;
    expected_len += 1;
    expected_len += 1;
    {
        guint radio_interface_list_i;
        guint8 radio_interface_list_n_items;
        const guint8 *radio_interface_list_aux_buffer = &buffer[expected_len];
        guint16 radio_interface_list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &radio_interface_list_aux_buffer,
            &radio_interface_list_aux_buffer_len,
            &(radio_interface_list_n_items));
        for (radio_interface_list_i = 0; radio_interface_list_i < radio_interface_list_n_items; radio_interface_list_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_capabilities_output_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_CAPABILITIES_OUTPUT_TLV_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_capabilities_output_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " max_tx_channel_rate = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " max_rx_channel_rate = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " data_service_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_DATA_SERVICE_CAPABILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_data_service_capability_get_string ((QmiDmsDataServiceCapability)tmp));
#elif defined  __QMI_DMS_DATA_SERVICE_CAPABILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_data_service_capability_build_string_from_mask ((QmiDmsDataServiceCapability)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsDataServiceCapability
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " sim_capability = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_SIM_CAPABILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_sim_capability_get_string ((QmiDmsSimCapability)tmp));
#elif defined  __QMI_DMS_SIM_CAPABILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_sim_capability_build_string_from_mask ((QmiDmsSimCapability)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsSimCapability
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " radio_interface_list = '");
        {
            guint radio_interface_list_i;
            guint8 radio_interface_list_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(radio_interface_list_n_items));

            g_string_append (printable, "{");

            for (radio_interface_list_i = 0; radio_interface_list_i < radio_interface_list_n_items; radio_interface_list_i++) {
                g_string_append_printf (printable, " [%u] = '", radio_interface_list_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_DMS_RADIO_INTERFACE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_dms_radio_interface_get_string ((QmiDmsRadioInterface)tmp));
#elif defined  __QMI_DMS_RADIO_INTERFACE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_dms_radio_interface_build_string_from_mask ((QmiDmsRadioInterface)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiDmsRadioInterface
#endif
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_capabilities_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_capabilities_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_capabilities_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_CAPABILITIES_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_CAPABILITIES_OUTPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_dms_get_capabilities_output_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_capabilities_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Capabilities\" (0x0020)\n",
                            line_prefix);

    {
        struct message_get_capabilities_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_capabilities_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetCapabilitiesOutput *
__qmi_message_dms_get_capabilities_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetCapabilitiesOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_CAPABILITIES, NULL);

    self = g_slice_new0 (QmiMessageDmsGetCapabilitiesOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_CAPABILITIES_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_capabilities_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_CAPABILITIES_OUTPUT_TLV_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_capabilities_output_info_validate (buffer, buffer_len)) {
                self->arg_info_set = TRUE;

                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_info_max_tx_channel_rate));
                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_info_max_rx_channel_rate));
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_info_data_service_capability = (QmiDmsDataServiceCapability)tmp;
                }
                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_info_sim_capability = (QmiDmsSimCapability)tmp;
                }
                {
                    guint radio_interface_list_i;
                    guint8 radio_interface_list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(radio_interface_list_n_items));

                    self->arg_info_radio_interface_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiDmsRadioInterface),
                        (guint)radio_interface_list_n_items);

                    for (radio_interface_list_i = 0; radio_interface_list_i < radio_interface_list_n_items; radio_interface_list_i++) {
                        QmiDmsRadioInterface radio_interface_list_aux;

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            radio_interface_list_aux = (QmiDmsRadioInterface)tmp;
                        }
                        g_array_insert_val (self->arg_info_radio_interface_list, radio_interface_list_i, radio_interface_list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Info' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Info TLV: Not found");
                qmi_message_dms_get_capabilities_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Manufacturer */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_manufacturer_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_MANUFACTURER);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetManufacturerOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Manufacturer */
    gboolean arg_manufacturer_set;
    gchar *arg_manufacturer;
};

#define QMI_MESSAGE_DMS_GET_MANUFACTURER_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_MANUFACTURER_OUTPUT_TLV_MANUFACTURER 0x01

/**
 * qmi_message_dms_get_manufacturer_output_get_result:
 * @self: a QmiMessageDmsGetManufacturerOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_manufacturer_output_get_result (
    QmiMessageDmsGetManufacturerOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_manufacturer_output_get_manufacturer:
 * @self: a #QmiMessageDmsGetManufacturerOutput.
 * @manufacturer: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Manufacturer' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_manufacturer_output_get_manufacturer (
    QmiMessageDmsGetManufacturerOutput *self,
    const gchar **manufacturer,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_manufacturer_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Manufacturer' was not found in the message");
        return FALSE;
    }

    if (manufacturer)
        *manufacturer = self->arg_manufacturer;

    return TRUE;
}

GType
qmi_message_dms_get_manufacturer_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetManufacturerOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_manufacturer_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_manufacturer_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_manufacturer_output_ref:
 * @self: a #QmiMessageDmsGetManufacturerOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetManufacturerOutput *
qmi_message_dms_get_manufacturer_output_ref (QmiMessageDmsGetManufacturerOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_manufacturer_output_unref:
 * @self: a #QmiMessageDmsGetManufacturerOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_manufacturer_output_unref (QmiMessageDmsGetManufacturerOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_manufacturer);
        g_slice_free (QmiMessageDmsGetManufacturerOutput, self);
    }
}

static gboolean
qmi_message_dms_get_manufacturer_output_manufacturer_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Manufacturer' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Manufacturer' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_manufacturer_output_manufacturer_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_MANUFACTURER_OUTPUT_TLV_MANUFACTURER,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_manufacturer_output_manufacturer_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Manufacturer' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_manufacturer_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_manufacturer_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_manufacturer_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_MANUFACTURER_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_MANUFACTURER_OUTPUT_TLV_MANUFACTURER:
            tlv_type_str = "Manufacturer";
            translated_value = qmi_message_dms_get_manufacturer_output_manufacturer_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_manufacturer_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Manufacturer\" (0x0021)\n",
                            line_prefix);

    {
        struct message_get_manufacturer_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_manufacturer_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetManufacturerOutput *
__qmi_message_dms_get_manufacturer_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetManufacturerOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_MANUFACTURER, NULL);

    self = g_slice_new0 (QmiMessageDmsGetManufacturerOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_MANUFACTURER_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_manufacturer_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_MANUFACTURER_OUTPUT_TLV_MANUFACTURER,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_manufacturer_output_manufacturer_validate (buffer, buffer_len)) {
                self->arg_manufacturer_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_manufacturer));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Manufacturer' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Manufacturer TLV: Not found");
                qmi_message_dms_get_manufacturer_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Model */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_model_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_MODEL);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetModelOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Model */
    gboolean arg_model_set;
    gchar *arg_model;
};

#define QMI_MESSAGE_DMS_GET_MODEL_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_MODEL_OUTPUT_TLV_MODEL 0x01

/**
 * qmi_message_dms_get_model_output_get_result:
 * @self: a QmiMessageDmsGetModelOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_model_output_get_result (
    QmiMessageDmsGetModelOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_model_output_get_model:
 * @self: a #QmiMessageDmsGetModelOutput.
 * @model: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Model' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_model_output_get_model (
    QmiMessageDmsGetModelOutput *self,
    const gchar **model,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_model_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Model' was not found in the message");
        return FALSE;
    }

    if (model)
        *model = self->arg_model;

    return TRUE;
}

GType
qmi_message_dms_get_model_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetModelOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_model_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_model_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_model_output_ref:
 * @self: a #QmiMessageDmsGetModelOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetModelOutput *
qmi_message_dms_get_model_output_ref (QmiMessageDmsGetModelOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_model_output_unref:
 * @self: a #QmiMessageDmsGetModelOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_model_output_unref (QmiMessageDmsGetModelOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_model);
        g_slice_free (QmiMessageDmsGetModelOutput, self);
    }
}

static gboolean
qmi_message_dms_get_model_output_model_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Model' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Model' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_model_output_model_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_MODEL_OUTPUT_TLV_MODEL,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_model_output_model_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Model' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_model_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_model_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_model_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_MODEL_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_MODEL_OUTPUT_TLV_MODEL:
            tlv_type_str = "Model";
            translated_value = qmi_message_dms_get_model_output_model_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_model_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Model\" (0x0022)\n",
                            line_prefix);

    {
        struct message_get_model_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_model_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetModelOutput *
__qmi_message_dms_get_model_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetModelOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_MODEL, NULL);

    self = g_slice_new0 (QmiMessageDmsGetModelOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_MODEL_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_model_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_MODEL_OUTPUT_TLV_MODEL,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_model_output_model_validate (buffer, buffer_len)) {
                self->arg_model_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_model));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Model' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Model TLV: Not found");
                qmi_message_dms_get_model_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Revision */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_revision_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_REVISION);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetRevisionOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Revision */
    gboolean arg_revision_set;
    gchar *arg_revision;
};

#define QMI_MESSAGE_DMS_GET_REVISION_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_REVISION_OUTPUT_TLV_REVISION 0x01

/**
 * qmi_message_dms_get_revision_output_get_result:
 * @self: a QmiMessageDmsGetRevisionOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_revision_output_get_result (
    QmiMessageDmsGetRevisionOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_revision_output_get_revision:
 * @self: a #QmiMessageDmsGetRevisionOutput.
 * @revision: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Revision' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_revision_output_get_revision (
    QmiMessageDmsGetRevisionOutput *self,
    const gchar **revision,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_revision_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Revision' was not found in the message");
        return FALSE;
    }

    if (revision)
        *revision = self->arg_revision;

    return TRUE;
}

GType
qmi_message_dms_get_revision_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetRevisionOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_revision_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_revision_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_revision_output_ref:
 * @self: a #QmiMessageDmsGetRevisionOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetRevisionOutput *
qmi_message_dms_get_revision_output_ref (QmiMessageDmsGetRevisionOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_revision_output_unref:
 * @self: a #QmiMessageDmsGetRevisionOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_revision_output_unref (QmiMessageDmsGetRevisionOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_revision);
        g_slice_free (QmiMessageDmsGetRevisionOutput, self);
    }
}

static gboolean
qmi_message_dms_get_revision_output_revision_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Revision' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Revision' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_revision_output_revision_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_REVISION_OUTPUT_TLV_REVISION,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_revision_output_revision_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Revision' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_revision_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_revision_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_revision_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_REVISION_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_REVISION_OUTPUT_TLV_REVISION:
            tlv_type_str = "Revision";
            translated_value = qmi_message_dms_get_revision_output_revision_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_revision_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Revision\" (0x0023)\n",
                            line_prefix);

    {
        struct message_get_revision_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_revision_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetRevisionOutput *
__qmi_message_dms_get_revision_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetRevisionOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_REVISION, NULL);

    self = g_slice_new0 (QmiMessageDmsGetRevisionOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_REVISION_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_revision_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_REVISION_OUTPUT_TLV_REVISION,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_revision_output_revision_validate (buffer, buffer_len)) {
                self->arg_revision_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_revision));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Revision' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Revision TLV: Not found");
                qmi_message_dms_get_revision_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get MSISDN */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_msisdn_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_MSISDN);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetMsisdnOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* MSISDN */
    gboolean arg_msisdn_set;
    gchar *arg_msisdn;
};

#define QMI_MESSAGE_DMS_GET_MSISDN_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_MSISDN_OUTPUT_TLV_MSISDN 0x01

/**
 * qmi_message_dms_get_msisdn_output_get_result:
 * @self: a QmiMessageDmsGetMsisdnOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_msisdn_output_get_result (
    QmiMessageDmsGetMsisdnOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_msisdn_output_get_msisdn:
 * @self: a #QmiMessageDmsGetMsisdnOutput.
 * @msisdn: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'MSISDN' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_msisdn_output_get_msisdn (
    QmiMessageDmsGetMsisdnOutput *self,
    const gchar **msisdn,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_msisdn_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MSISDN' was not found in the message");
        return FALSE;
    }

    if (msisdn)
        *msisdn = self->arg_msisdn;

    return TRUE;
}

GType
qmi_message_dms_get_msisdn_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetMsisdnOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_msisdn_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_msisdn_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_msisdn_output_ref:
 * @self: a #QmiMessageDmsGetMsisdnOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetMsisdnOutput *
qmi_message_dms_get_msisdn_output_ref (QmiMessageDmsGetMsisdnOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_msisdn_output_unref:
 * @self: a #QmiMessageDmsGetMsisdnOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_msisdn_output_unref (QmiMessageDmsGetMsisdnOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_msisdn);
        g_slice_free (QmiMessageDmsGetMsisdnOutput, self);
    }
}

static gboolean
qmi_message_dms_get_msisdn_output_msisdn_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'MSISDN' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'MSISDN' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_msisdn_output_msisdn_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_MSISDN_OUTPUT_TLV_MSISDN,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_msisdn_output_msisdn_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'MSISDN' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_msisdn_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_msisdn_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_msisdn_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_MSISDN_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_MSISDN_OUTPUT_TLV_MSISDN:
            tlv_type_str = "MSISDN";
            translated_value = qmi_message_dms_get_msisdn_output_msisdn_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_msisdn_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get MSISDN\" (0x0024)\n",
                            line_prefix);

    {
        struct message_get_msisdn_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_msisdn_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetMsisdnOutput *
__qmi_message_dms_get_msisdn_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetMsisdnOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_MSISDN, NULL);

    self = g_slice_new0 (QmiMessageDmsGetMsisdnOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_MSISDN_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_msisdn_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_MSISDN_OUTPUT_TLV_MSISDN,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_msisdn_output_msisdn_validate (buffer, buffer_len)) {
                self->arg_msisdn_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_msisdn));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'MSISDN' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the MSISDN TLV: Not found");
                qmi_message_dms_get_msisdn_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get IDs */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_ids_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_IDS);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetIdsOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Esn */
    gboolean arg_esn_set;
    gchar *arg_esn;

    /* Imei */
    gboolean arg_imei_set;
    gchar *arg_imei;

    /* Meid */
    gboolean arg_meid_set;
    gchar *arg_meid;
};

#define QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_ESN 0x10
#define QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_IMEI 0x11
#define QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_MEID 0x12

/**
 * qmi_message_dms_get_ids_output_get_result:
 * @self: a QmiMessageDmsGetIdsOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_ids_output_get_result (
    QmiMessageDmsGetIdsOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_ids_output_get_esn:
 * @self: a #QmiMessageDmsGetIdsOutput.
 * @esn: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Esn' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_ids_output_get_esn (
    QmiMessageDmsGetIdsOutput *self,
    const gchar **esn,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_esn_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Esn' was not found in the message");
        return FALSE;
    }

    if (esn)
        *esn = self->arg_esn;

    return TRUE;
}

/**
 * qmi_message_dms_get_ids_output_get_imei:
 * @self: a #QmiMessageDmsGetIdsOutput.
 * @imei: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Imei' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_ids_output_get_imei (
    QmiMessageDmsGetIdsOutput *self,
    const gchar **imei,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_imei_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Imei' was not found in the message");
        return FALSE;
    }

    if (imei)
        *imei = self->arg_imei;

    return TRUE;
}

/**
 * qmi_message_dms_get_ids_output_get_meid:
 * @self: a #QmiMessageDmsGetIdsOutput.
 * @meid: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Meid' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_ids_output_get_meid (
    QmiMessageDmsGetIdsOutput *self,
    const gchar **meid,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_meid_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Meid' was not found in the message");
        return FALSE;
    }

    if (meid)
        *meid = self->arg_meid;

    return TRUE;
}

GType
qmi_message_dms_get_ids_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetIdsOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_ids_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_ids_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_ids_output_ref:
 * @self: a #QmiMessageDmsGetIdsOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetIdsOutput *
qmi_message_dms_get_ids_output_ref (QmiMessageDmsGetIdsOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_ids_output_unref:
 * @self: a #QmiMessageDmsGetIdsOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_ids_output_unref (QmiMessageDmsGetIdsOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_esn);
        g_free (self->arg_imei);
        g_free (self->arg_meid);
        g_slice_free (QmiMessageDmsGetIdsOutput, self);
    }
}

static gboolean
qmi_message_dms_get_ids_output_esn_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Esn' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Esn' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_ids_output_esn_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_ESN,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_ids_output_esn_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Esn' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_ids_output_imei_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Imei' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Imei' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_ids_output_imei_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_IMEI,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_ids_output_imei_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                15,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Imei' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_ids_output_meid_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Meid' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Meid' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_ids_output_meid_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_MEID,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_ids_output_meid_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Meid' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_ids_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_ids_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_ids_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_ESN:
            tlv_type_str = "Esn";
            translated_value = qmi_message_dms_get_ids_output_esn_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_IMEI:
            tlv_type_str = "Imei";
            translated_value = qmi_message_dms_get_ids_output_imei_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_MEID:
            tlv_type_str = "Meid";
            translated_value = qmi_message_dms_get_ids_output_meid_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_ids_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get IDs\" (0x0025)\n",
                            line_prefix);

    {
        struct message_get_ids_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_ids_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetIdsOutput *
__qmi_message_dms_get_ids_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetIdsOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_IDS, NULL);

    self = g_slice_new0 (QmiMessageDmsGetIdsOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_ids_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_ESN,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_ids_output_esn_validate (buffer, buffer_len)) {
                self->arg_esn_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_esn));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Esn' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_IMEI,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_ids_output_imei_validate (buffer, buffer_len)) {
                self->arg_imei_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    15,
                    &(self->arg_imei));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Imei' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_IDS_OUTPUT_TLV_MEID,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_ids_output_meid_validate (buffer, buffer_len)) {
                self->arg_meid_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_meid));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Meid' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Power State */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_power_state_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_POWER_STATE);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetPowerStateOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Info */
    gboolean arg_info_set;
    guint8 arg_info_power_state_flags;
    guint8 arg_info_battery_level;
};

#define QMI_MESSAGE_DMS_GET_POWER_STATE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_POWER_STATE_OUTPUT_TLV_INFO 0x01

/**
 * qmi_message_dms_get_power_state_output_get_result:
 * @self: a QmiMessageDmsGetPowerStateOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_power_state_output_get_result (
    QmiMessageDmsGetPowerStateOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_power_state_output_get_info:
 * @self: a #QmiMessageDmsGetPowerStateOutput.
 * @info_power_state_flags: a placeholder for the output #guint8, or %NULL if not required.
 * @info_battery_level: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_power_state_output_get_info (
    QmiMessageDmsGetPowerStateOutput *self,
    guint8 *info_power_state_flags,
    guint8 *info_battery_level,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (info_power_state_flags)
        *info_power_state_flags = self->arg_info_power_state_flags;
    if (info_battery_level)
        *info_battery_level = self->arg_info_battery_level;

    return TRUE;
}

GType
qmi_message_dms_get_power_state_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetPowerStateOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_power_state_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_power_state_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_power_state_output_ref:
 * @self: a #QmiMessageDmsGetPowerStateOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetPowerStateOutput *
qmi_message_dms_get_power_state_output_ref (QmiMessageDmsGetPowerStateOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_power_state_output_unref:
 * @self: a #QmiMessageDmsGetPowerStateOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_power_state_output_unref (QmiMessageDmsGetPowerStateOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsGetPowerStateOutput, self);
    }
}

static gboolean
qmi_message_dms_get_power_state_output_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_power_state_output_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_POWER_STATE_OUTPUT_TLV_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_power_state_output_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " power_state_flags = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " battery_level = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_power_state_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_power_state_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_power_state_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_POWER_STATE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_POWER_STATE_OUTPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_dms_get_power_state_output_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_power_state_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Power State\" (0x0026)\n",
                            line_prefix);

    {
        struct message_get_power_state_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_power_state_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetPowerStateOutput *
__qmi_message_dms_get_power_state_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetPowerStateOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_POWER_STATE, NULL);

    self = g_slice_new0 (QmiMessageDmsGetPowerStateOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_POWER_STATE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_power_state_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_POWER_STATE_OUTPUT_TLV_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_power_state_output_info_validate (buffer, buffer_len)) {
                self->arg_info_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_info_power_state_flags));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_info_battery_level));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Info' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Info TLV: Not found");
                qmi_message_dms_get_power_state_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Set PIN Protection */


/* --- Input -- */

struct _QmiMessageDmsUimSetPinProtectionInput {
    volatile gint ref_count;

    /* Info */
    gboolean arg_info_set;
    guint8 arg_info_pin_id;
    guint8 arg_info_protection_enabled;
    gchar *arg_info_pin;
};

#define QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_INPUT_TLV_INFO 0x01

/**
 * qmi_message_dms_uim_set_pin_protection_input_get_info:
 * @self: a #QmiMessageDmsUimSetPinProtectionInput.
 * @info_pin_id: a placeholder for the output #QmiDmsUimPinId, or %NULL if not required.
 * @info_protection_enabled: a placeholder for the output #gboolean, or %NULL if not required.
 * @info_pin: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_set_pin_protection_input_get_info (
    QmiMessageDmsUimSetPinProtectionInput *self,
    QmiDmsUimPinId *info_pin_id,
    gboolean *info_protection_enabled,
    const gchar **info_pin,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (info_pin_id)
        *info_pin_id = (QmiDmsUimPinId)(self->arg_info_pin_id);
    if (info_protection_enabled)
        *info_protection_enabled = (gboolean)(self->arg_info_protection_enabled);
    if (info_pin)
        *info_pin = self->arg_info_pin;

    return TRUE;
}

/**
 * qmi_message_dms_uim_set_pin_protection_input_set_info:
 * @self: a #QmiMessageDmsUimSetPinProtectionInput.
 * @info_pin_id: a #QmiDmsUimPinId.
 * @info_protection_enabled: a #gboolean.
 * @info_pin: a constant string.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Info' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_set_pin_protection_input_set_info (
    QmiMessageDmsUimSetPinProtectionInput *self,
    QmiDmsUimPinId info_pin_id,
    gboolean info_protection_enabled,
    const gchar *info_pin,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_info_pin_id = (guint8)(info_pin_id);
    self->arg_info_protection_enabled = (guint8)(info_protection_enabled);
    g_free (self->arg_info_pin);
    self->arg_info_pin = g_strdup (info_pin ? info_pin : "");
    self->arg_info_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_uim_set_pin_protection_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimSetPinProtectionInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_set_pin_protection_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_set_pin_protection_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_set_pin_protection_input_ref:
 * @self: a #QmiMessageDmsUimSetPinProtectionInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimSetPinProtectionInput *
qmi_message_dms_uim_set_pin_protection_input_ref (QmiMessageDmsUimSetPinProtectionInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_set_pin_protection_input_unref:
 * @self: a #QmiMessageDmsUimSetPinProtectionInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_set_pin_protection_input_unref (QmiMessageDmsUimSetPinProtectionInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_info_pin);
        g_slice_free (QmiMessageDmsUimSetPinProtectionInput, self);
    }
}

/**
 * qmi_message_dms_uim_set_pin_protection_input_new:
 *
 * Allocates a new #QmiMessageDmsUimSetPinProtectionInput.
 *
 * Returns: the newly created #QmiMessageDmsUimSetPinProtectionInput. The returned value should be freed with qmi_message_dms_uim_set_pin_protection_input_unref().
 */
QmiMessageDmsUimSetPinProtectionInput *
qmi_message_dms_uim_set_pin_protection_input_new (void)
{
    QmiMessageDmsUimSetPinProtectionInput *self;

    self = g_slice_new0 (QmiMessageDmsUimSetPinProtectionInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_uim_set_pin_protection_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsUimSetPinProtectionInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'UIM Set PIN Protection' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Info' TLV */
    if (input->arg_info_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_info_pin_id;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        {
            guint8 tmp;

            tmp = (guint8)input->arg_info_protection_enabled;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_info_pin);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_INPUT_TLV_INFO,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Info TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Info' in message 'UIM Set PIN Protection'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimSetPinProtectionOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Pin Retries Status */
    gboolean arg_pin_retries_status_set;
    guint8 arg_pin_retries_status_verify_retries_left;
    guint8 arg_pin_retries_status_unblock_retries_left;
};

#define QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_OUTPUT_TLV_PIN_RETRIES_STATUS 0x10

/**
 * qmi_message_dms_uim_set_pin_protection_output_get_result:
 * @self: a QmiMessageDmsUimSetPinProtectionOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_set_pin_protection_output_get_result (
    QmiMessageDmsUimSetPinProtectionOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_set_pin_protection_output_get_pin_retries_status:
 * @self: a #QmiMessageDmsUimSetPinProtectionOutput.
 * @pin_retries_status_verify_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @pin_retries_status_unblock_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Pin Retries Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_set_pin_protection_output_get_pin_retries_status (
    QmiMessageDmsUimSetPinProtectionOutput *self,
    guint8 *pin_retries_status_verify_retries_left,
    guint8 *pin_retries_status_unblock_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_pin_retries_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Pin Retries Status' was not found in the message");
        return FALSE;
    }

    if (pin_retries_status_verify_retries_left)
        *pin_retries_status_verify_retries_left = self->arg_pin_retries_status_verify_retries_left;
    if (pin_retries_status_unblock_retries_left)
        *pin_retries_status_unblock_retries_left = self->arg_pin_retries_status_unblock_retries_left;

    return TRUE;
}

GType
qmi_message_dms_uim_set_pin_protection_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimSetPinProtectionOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_set_pin_protection_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_set_pin_protection_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_set_pin_protection_output_ref:
 * @self: a #QmiMessageDmsUimSetPinProtectionOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimSetPinProtectionOutput *
qmi_message_dms_uim_set_pin_protection_output_ref (QmiMessageDmsUimSetPinProtectionOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_set_pin_protection_output_unref:
 * @self: a #QmiMessageDmsUimSetPinProtectionOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_set_pin_protection_output_unref (QmiMessageDmsUimSetPinProtectionOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsUimSetPinProtectionOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_set_pin_protection_input_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_set_pin_protection_input_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_INPUT_TLV_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_set_pin_protection_input_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " pin_id = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_PIN_ID_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_pin_id_get_string ((QmiDmsUimPinId)tmp));
#elif defined  __QMI_DMS_UIM_PIN_ID_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_pin_id_build_string_from_mask ((QmiDmsUimPinId)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimPinId
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " protection_enabled = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " pin = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_uim_set_pin_protection_output_pin_retries_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Pin Retries Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Pin Retries Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_set_pin_protection_output_pin_retries_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_OUTPUT_TLV_PIN_RETRIES_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_set_pin_protection_output_pin_retries_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " verify_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unblock_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Pin Retries Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_set_pin_protection_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_set_pin_protection_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_set_pin_protection_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_INPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_dms_uim_set_pin_protection_input_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_OUTPUT_TLV_PIN_RETRIES_STATUS:
            tlv_type_str = "Pin Retries Status";
            translated_value = qmi_message_dms_uim_set_pin_protection_output_pin_retries_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_set_pin_protection_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Set PIN Protection\" (0x0027)\n",
                            line_prefix);

    {
        struct message_uim_set_pin_protection_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_set_pin_protection_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimSetPinProtectionOutput *
__qmi_message_dms_uim_set_pin_protection_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimSetPinProtectionOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION, NULL);

    self = g_slice_new0 (QmiMessageDmsUimSetPinProtectionOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_set_pin_protection_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status != QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION_OUTPUT_TLV_PIN_RETRIES_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_set_pin_protection_output_pin_retries_status_validate (buffer, buffer_len)) {
                self->arg_pin_retries_status_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin_retries_status_verify_retries_left));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin_retries_status_unblock_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Pin Retries Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Verify PIN */


/* --- Input -- */

struct _QmiMessageDmsUimVerifyPinInput {
    volatile gint ref_count;

    /* Info */
    gboolean arg_info_set;
    guint8 arg_info_pin_id;
    gchar *arg_info_pin;
};

#define QMI_MESSAGE_DMS_UIM_VERIFY_PIN_INPUT_TLV_INFO 0x01

/**
 * qmi_message_dms_uim_verify_pin_input_get_info:
 * @self: a #QmiMessageDmsUimVerifyPinInput.
 * @info_pin_id: a placeholder for the output #QmiDmsUimPinId, or %NULL if not required.
 * @info_pin: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_verify_pin_input_get_info (
    QmiMessageDmsUimVerifyPinInput *self,
    QmiDmsUimPinId *info_pin_id,
    const gchar **info_pin,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (info_pin_id)
        *info_pin_id = (QmiDmsUimPinId)(self->arg_info_pin_id);
    if (info_pin)
        *info_pin = self->arg_info_pin;

    return TRUE;
}

/**
 * qmi_message_dms_uim_verify_pin_input_set_info:
 * @self: a #QmiMessageDmsUimVerifyPinInput.
 * @info_pin_id: a #QmiDmsUimPinId.
 * @info_pin: a constant string.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Info' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_verify_pin_input_set_info (
    QmiMessageDmsUimVerifyPinInput *self,
    QmiDmsUimPinId info_pin_id,
    const gchar *info_pin,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_info_pin_id = (guint8)(info_pin_id);
    g_free (self->arg_info_pin);
    self->arg_info_pin = g_strdup (info_pin ? info_pin : "");
    self->arg_info_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_uim_verify_pin_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimVerifyPinInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_verify_pin_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_verify_pin_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_verify_pin_input_ref:
 * @self: a #QmiMessageDmsUimVerifyPinInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimVerifyPinInput *
qmi_message_dms_uim_verify_pin_input_ref (QmiMessageDmsUimVerifyPinInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_verify_pin_input_unref:
 * @self: a #QmiMessageDmsUimVerifyPinInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_verify_pin_input_unref (QmiMessageDmsUimVerifyPinInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_info_pin);
        g_slice_free (QmiMessageDmsUimVerifyPinInput, self);
    }
}

/**
 * qmi_message_dms_uim_verify_pin_input_new:
 *
 * Allocates a new #QmiMessageDmsUimVerifyPinInput.
 *
 * Returns: the newly created #QmiMessageDmsUimVerifyPinInput. The returned value should be freed with qmi_message_dms_uim_verify_pin_input_unref().
 */
QmiMessageDmsUimVerifyPinInput *
qmi_message_dms_uim_verify_pin_input_new (void)
{
    QmiMessageDmsUimVerifyPinInput *self;

    self = g_slice_new0 (QmiMessageDmsUimVerifyPinInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_uim_verify_pin_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsUimVerifyPinInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_VERIFY_PIN);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'UIM Verify PIN' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Info' TLV */
    if (input->arg_info_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_info_pin_id;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_info_pin);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_UIM_VERIFY_PIN_INPUT_TLV_INFO,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Info TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Info' in message 'UIM Verify PIN'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimVerifyPinOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Pin Retries Status */
    gboolean arg_pin_retries_status_set;
    guint8 arg_pin_retries_status_verify_retries_left;
    guint8 arg_pin_retries_status_unblock_retries_left;
};

#define QMI_MESSAGE_DMS_UIM_VERIFY_PIN_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_VERIFY_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS 0x10

/**
 * qmi_message_dms_uim_verify_pin_output_get_result:
 * @self: a QmiMessageDmsUimVerifyPinOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_verify_pin_output_get_result (
    QmiMessageDmsUimVerifyPinOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_verify_pin_output_get_pin_retries_status:
 * @self: a #QmiMessageDmsUimVerifyPinOutput.
 * @pin_retries_status_verify_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @pin_retries_status_unblock_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Pin Retries Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_verify_pin_output_get_pin_retries_status (
    QmiMessageDmsUimVerifyPinOutput *self,
    guint8 *pin_retries_status_verify_retries_left,
    guint8 *pin_retries_status_unblock_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_pin_retries_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Pin Retries Status' was not found in the message");
        return FALSE;
    }

    if (pin_retries_status_verify_retries_left)
        *pin_retries_status_verify_retries_left = self->arg_pin_retries_status_verify_retries_left;
    if (pin_retries_status_unblock_retries_left)
        *pin_retries_status_unblock_retries_left = self->arg_pin_retries_status_unblock_retries_left;

    return TRUE;
}

GType
qmi_message_dms_uim_verify_pin_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimVerifyPinOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_verify_pin_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_verify_pin_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_verify_pin_output_ref:
 * @self: a #QmiMessageDmsUimVerifyPinOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimVerifyPinOutput *
qmi_message_dms_uim_verify_pin_output_ref (QmiMessageDmsUimVerifyPinOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_verify_pin_output_unref:
 * @self: a #QmiMessageDmsUimVerifyPinOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_verify_pin_output_unref (QmiMessageDmsUimVerifyPinOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsUimVerifyPinOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_verify_pin_input_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_verify_pin_input_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_VERIFY_PIN_INPUT_TLV_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_verify_pin_input_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " pin_id = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_PIN_ID_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_pin_id_get_string ((QmiDmsUimPinId)tmp));
#elif defined  __QMI_DMS_UIM_PIN_ID_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_pin_id_build_string_from_mask ((QmiDmsUimPinId)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimPinId
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " pin = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_uim_verify_pin_output_pin_retries_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Pin Retries Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Pin Retries Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_verify_pin_output_pin_retries_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_VERIFY_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_verify_pin_output_pin_retries_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " verify_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unblock_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Pin Retries Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_verify_pin_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_verify_pin_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_verify_pin_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_VERIFY_PIN_INPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_dms_uim_verify_pin_input_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_VERIFY_PIN_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_VERIFY_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS:
            tlv_type_str = "Pin Retries Status";
            translated_value = qmi_message_dms_uim_verify_pin_output_pin_retries_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_verify_pin_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Verify PIN\" (0x0028)\n",
                            line_prefix);

    {
        struct message_uim_verify_pin_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_verify_pin_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimVerifyPinOutput *
__qmi_message_dms_uim_verify_pin_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimVerifyPinOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_VERIFY_PIN, NULL);

    self = g_slice_new0 (QmiMessageDmsUimVerifyPinOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_VERIFY_PIN_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_verify_pin_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status != QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_VERIFY_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_verify_pin_output_pin_retries_status_validate (buffer, buffer_len)) {
                self->arg_pin_retries_status_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin_retries_status_verify_retries_left));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin_retries_status_unblock_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Pin Retries Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Unblock PIN */


/* --- Input -- */

struct _QmiMessageDmsUimUnblockPinInput {
    volatile gint ref_count;

    /* Info */
    gboolean arg_info_set;
    guint8 arg_info_pin_id;
    gchar *arg_info_puk;
    gchar *arg_info_new_pin;
};

#define QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_INPUT_TLV_INFO 0x01

/**
 * qmi_message_dms_uim_unblock_pin_input_get_info:
 * @self: a #QmiMessageDmsUimUnblockPinInput.
 * @info_pin_id: a placeholder for the output #QmiDmsUimPinId, or %NULL if not required.
 * @info_puk: a placeholder for the output constant string, or %NULL if not required.
 * @info_new_pin: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_unblock_pin_input_get_info (
    QmiMessageDmsUimUnblockPinInput *self,
    QmiDmsUimPinId *info_pin_id,
    const gchar **info_puk,
    const gchar **info_new_pin,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (info_pin_id)
        *info_pin_id = (QmiDmsUimPinId)(self->arg_info_pin_id);
    if (info_puk)
        *info_puk = self->arg_info_puk;
    if (info_new_pin)
        *info_new_pin = self->arg_info_new_pin;

    return TRUE;
}

/**
 * qmi_message_dms_uim_unblock_pin_input_set_info:
 * @self: a #QmiMessageDmsUimUnblockPinInput.
 * @info_pin_id: a #QmiDmsUimPinId.
 * @info_puk: a constant string.
 * @info_new_pin: a constant string.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Info' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_unblock_pin_input_set_info (
    QmiMessageDmsUimUnblockPinInput *self,
    QmiDmsUimPinId info_pin_id,
    const gchar *info_puk,
    const gchar *info_new_pin,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_info_pin_id = (guint8)(info_pin_id);
    g_free (self->arg_info_puk);
    self->arg_info_puk = g_strdup (info_puk ? info_puk : "");
    g_free (self->arg_info_new_pin);
    self->arg_info_new_pin = g_strdup (info_new_pin ? info_new_pin : "");
    self->arg_info_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_uim_unblock_pin_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimUnblockPinInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_unblock_pin_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_unblock_pin_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_unblock_pin_input_ref:
 * @self: a #QmiMessageDmsUimUnblockPinInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimUnblockPinInput *
qmi_message_dms_uim_unblock_pin_input_ref (QmiMessageDmsUimUnblockPinInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_unblock_pin_input_unref:
 * @self: a #QmiMessageDmsUimUnblockPinInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_unblock_pin_input_unref (QmiMessageDmsUimUnblockPinInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_info_puk);
        g_free (self->arg_info_new_pin);
        g_slice_free (QmiMessageDmsUimUnblockPinInput, self);
    }
}

/**
 * qmi_message_dms_uim_unblock_pin_input_new:
 *
 * Allocates a new #QmiMessageDmsUimUnblockPinInput.
 *
 * Returns: the newly created #QmiMessageDmsUimUnblockPinInput. The returned value should be freed with qmi_message_dms_uim_unblock_pin_input_unref().
 */
QmiMessageDmsUimUnblockPinInput *
qmi_message_dms_uim_unblock_pin_input_new (void)
{
    QmiMessageDmsUimUnblockPinInput *self;

    self = g_slice_new0 (QmiMessageDmsUimUnblockPinInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_uim_unblock_pin_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsUimUnblockPinInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'UIM Unblock PIN' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Info' TLV */
    if (input->arg_info_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_info_pin_id;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_info_puk);
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_info_new_pin);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_INPUT_TLV_INFO,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Info TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Info' in message 'UIM Unblock PIN'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimUnblockPinOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Pin Retries Status */
    gboolean arg_pin_retries_status_set;
    guint8 arg_pin_retries_status_verify_retries_left;
    guint8 arg_pin_retries_status_unblock_retries_left;
};

#define QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS 0x10

/**
 * qmi_message_dms_uim_unblock_pin_output_get_result:
 * @self: a QmiMessageDmsUimUnblockPinOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_unblock_pin_output_get_result (
    QmiMessageDmsUimUnblockPinOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_unblock_pin_output_get_pin_retries_status:
 * @self: a #QmiMessageDmsUimUnblockPinOutput.
 * @pin_retries_status_verify_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @pin_retries_status_unblock_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Pin Retries Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_unblock_pin_output_get_pin_retries_status (
    QmiMessageDmsUimUnblockPinOutput *self,
    guint8 *pin_retries_status_verify_retries_left,
    guint8 *pin_retries_status_unblock_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_pin_retries_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Pin Retries Status' was not found in the message");
        return FALSE;
    }

    if (pin_retries_status_verify_retries_left)
        *pin_retries_status_verify_retries_left = self->arg_pin_retries_status_verify_retries_left;
    if (pin_retries_status_unblock_retries_left)
        *pin_retries_status_unblock_retries_left = self->arg_pin_retries_status_unblock_retries_left;

    return TRUE;
}

GType
qmi_message_dms_uim_unblock_pin_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimUnblockPinOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_unblock_pin_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_unblock_pin_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_unblock_pin_output_ref:
 * @self: a #QmiMessageDmsUimUnblockPinOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimUnblockPinOutput *
qmi_message_dms_uim_unblock_pin_output_ref (QmiMessageDmsUimUnblockPinOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_unblock_pin_output_unref:
 * @self: a #QmiMessageDmsUimUnblockPinOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_unblock_pin_output_unref (QmiMessageDmsUimUnblockPinOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsUimUnblockPinOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_unblock_pin_input_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_unblock_pin_input_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_INPUT_TLV_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_unblock_pin_input_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " pin_id = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_PIN_ID_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_pin_id_get_string ((QmiDmsUimPinId)tmp));
#elif defined  __QMI_DMS_UIM_PIN_ID_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_pin_id_build_string_from_mask ((QmiDmsUimPinId)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimPinId
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " puk = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " new_pin = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_uim_unblock_pin_output_pin_retries_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Pin Retries Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Pin Retries Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_unblock_pin_output_pin_retries_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_unblock_pin_output_pin_retries_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " verify_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unblock_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Pin Retries Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_unblock_pin_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_unblock_pin_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_unblock_pin_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_INPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_dms_uim_unblock_pin_input_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS:
            tlv_type_str = "Pin Retries Status";
            translated_value = qmi_message_dms_uim_unblock_pin_output_pin_retries_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_unblock_pin_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Unblock PIN\" (0x0029)\n",
                            line_prefix);

    {
        struct message_uim_unblock_pin_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_unblock_pin_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimUnblockPinOutput *
__qmi_message_dms_uim_unblock_pin_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimUnblockPinOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN, NULL);

    self = g_slice_new0 (QmiMessageDmsUimUnblockPinOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_unblock_pin_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status != QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_unblock_pin_output_pin_retries_status_validate (buffer, buffer_len)) {
                self->arg_pin_retries_status_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin_retries_status_verify_retries_left));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin_retries_status_unblock_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Pin Retries Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Change PIN */


/* --- Input -- */

struct _QmiMessageDmsUimChangePinInput {
    volatile gint ref_count;

    /* Info */
    gboolean arg_info_set;
    guint8 arg_info_pin_id;
    gchar *arg_info_old_pin;
    gchar *arg_info_new_pin;
};

#define QMI_MESSAGE_DMS_UIM_CHANGE_PIN_INPUT_TLV_INFO 0x01

/**
 * qmi_message_dms_uim_change_pin_input_get_info:
 * @self: a #QmiMessageDmsUimChangePinInput.
 * @info_pin_id: a placeholder for the output #QmiDmsUimPinId, or %NULL if not required.
 * @info_old_pin: a placeholder for the output constant string, or %NULL if not required.
 * @info_new_pin: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_change_pin_input_get_info (
    QmiMessageDmsUimChangePinInput *self,
    QmiDmsUimPinId *info_pin_id,
    const gchar **info_old_pin,
    const gchar **info_new_pin,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (info_pin_id)
        *info_pin_id = (QmiDmsUimPinId)(self->arg_info_pin_id);
    if (info_old_pin)
        *info_old_pin = self->arg_info_old_pin;
    if (info_new_pin)
        *info_new_pin = self->arg_info_new_pin;

    return TRUE;
}

/**
 * qmi_message_dms_uim_change_pin_input_set_info:
 * @self: a #QmiMessageDmsUimChangePinInput.
 * @info_pin_id: a #QmiDmsUimPinId.
 * @info_old_pin: a constant string.
 * @info_new_pin: a constant string.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Info' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_change_pin_input_set_info (
    QmiMessageDmsUimChangePinInput *self,
    QmiDmsUimPinId info_pin_id,
    const gchar *info_old_pin,
    const gchar *info_new_pin,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_info_pin_id = (guint8)(info_pin_id);
    g_free (self->arg_info_old_pin);
    self->arg_info_old_pin = g_strdup (info_old_pin ? info_old_pin : "");
    g_free (self->arg_info_new_pin);
    self->arg_info_new_pin = g_strdup (info_new_pin ? info_new_pin : "");
    self->arg_info_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_uim_change_pin_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimChangePinInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_change_pin_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_change_pin_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_change_pin_input_ref:
 * @self: a #QmiMessageDmsUimChangePinInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimChangePinInput *
qmi_message_dms_uim_change_pin_input_ref (QmiMessageDmsUimChangePinInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_change_pin_input_unref:
 * @self: a #QmiMessageDmsUimChangePinInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_change_pin_input_unref (QmiMessageDmsUimChangePinInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_info_old_pin);
        g_free (self->arg_info_new_pin);
        g_slice_free (QmiMessageDmsUimChangePinInput, self);
    }
}

/**
 * qmi_message_dms_uim_change_pin_input_new:
 *
 * Allocates a new #QmiMessageDmsUimChangePinInput.
 *
 * Returns: the newly created #QmiMessageDmsUimChangePinInput. The returned value should be freed with qmi_message_dms_uim_change_pin_input_unref().
 */
QmiMessageDmsUimChangePinInput *
qmi_message_dms_uim_change_pin_input_new (void)
{
    QmiMessageDmsUimChangePinInput *self;

    self = g_slice_new0 (QmiMessageDmsUimChangePinInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_uim_change_pin_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsUimChangePinInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_CHANGE_PIN);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'UIM Change PIN' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Info' TLV */
    if (input->arg_info_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_info_pin_id;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_info_old_pin);
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_info_new_pin);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_UIM_CHANGE_PIN_INPUT_TLV_INFO,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Info TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Info' in message 'UIM Change PIN'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimChangePinOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Pin Retries Status */
    gboolean arg_pin_retries_status_set;
    guint8 arg_pin_retries_status_verify_retries_left;
    guint8 arg_pin_retries_status_unblock_retries_left;
};

#define QMI_MESSAGE_DMS_UIM_CHANGE_PIN_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_CHANGE_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS 0x10

/**
 * qmi_message_dms_uim_change_pin_output_get_result:
 * @self: a QmiMessageDmsUimChangePinOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_change_pin_output_get_result (
    QmiMessageDmsUimChangePinOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_change_pin_output_get_pin_retries_status:
 * @self: a #QmiMessageDmsUimChangePinOutput.
 * @pin_retries_status_verify_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @pin_retries_status_unblock_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Pin Retries Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_change_pin_output_get_pin_retries_status (
    QmiMessageDmsUimChangePinOutput *self,
    guint8 *pin_retries_status_verify_retries_left,
    guint8 *pin_retries_status_unblock_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_pin_retries_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Pin Retries Status' was not found in the message");
        return FALSE;
    }

    if (pin_retries_status_verify_retries_left)
        *pin_retries_status_verify_retries_left = self->arg_pin_retries_status_verify_retries_left;
    if (pin_retries_status_unblock_retries_left)
        *pin_retries_status_unblock_retries_left = self->arg_pin_retries_status_unblock_retries_left;

    return TRUE;
}

GType
qmi_message_dms_uim_change_pin_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimChangePinOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_change_pin_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_change_pin_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_change_pin_output_ref:
 * @self: a #QmiMessageDmsUimChangePinOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimChangePinOutput *
qmi_message_dms_uim_change_pin_output_ref (QmiMessageDmsUimChangePinOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_change_pin_output_unref:
 * @self: a #QmiMessageDmsUimChangePinOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_change_pin_output_unref (QmiMessageDmsUimChangePinOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsUimChangePinOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_change_pin_input_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_change_pin_input_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_CHANGE_PIN_INPUT_TLV_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_change_pin_input_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " pin_id = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_PIN_ID_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_pin_id_get_string ((QmiDmsUimPinId)tmp));
#elif defined  __QMI_DMS_UIM_PIN_ID_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_pin_id_build_string_from_mask ((QmiDmsUimPinId)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimPinId
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " old_pin = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " new_pin = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_uim_change_pin_output_pin_retries_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Pin Retries Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Pin Retries Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_change_pin_output_pin_retries_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_CHANGE_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_change_pin_output_pin_retries_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " verify_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unblock_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Pin Retries Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_change_pin_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_change_pin_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_change_pin_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_CHANGE_PIN_INPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_dms_uim_change_pin_input_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_CHANGE_PIN_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_CHANGE_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS:
            tlv_type_str = "Pin Retries Status";
            translated_value = qmi_message_dms_uim_change_pin_output_pin_retries_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_change_pin_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Change PIN\" (0x002A)\n",
                            line_prefix);

    {
        struct message_uim_change_pin_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_change_pin_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimChangePinOutput *
__qmi_message_dms_uim_change_pin_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimChangePinOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_CHANGE_PIN, NULL);

    self = g_slice_new0 (QmiMessageDmsUimChangePinOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_CHANGE_PIN_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_change_pin_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status != QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_CHANGE_PIN_OUTPUT_TLV_PIN_RETRIES_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_change_pin_output_pin_retries_status_validate (buffer, buffer_len)) {
                self->arg_pin_retries_status_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin_retries_status_verify_retries_left));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin_retries_status_unblock_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Pin Retries Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Get PIN Status */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_uim_get_pin_status_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimGetPinStatusOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* PIN2 Status */
    gboolean arg_pin2_status_set;
    guint8 arg_pin2_status_current_status;
    guint8 arg_pin2_status_verify_retries_left;
    guint8 arg_pin2_status_unblock_retries_left;

    /* PIN1 Status */
    gboolean arg_pin1_status_set;
    guint8 arg_pin1_status_current_status;
    guint8 arg_pin1_status_verify_retries_left;
    guint8 arg_pin1_status_unblock_retries_left;
};

#define QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_PIN2_STATUS 0x12
#define QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_PIN1_STATUS 0x11

/**
 * qmi_message_dms_uim_get_pin_status_output_get_result:
 * @self: a QmiMessageDmsUimGetPinStatusOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_get_pin_status_output_get_result (
    QmiMessageDmsUimGetPinStatusOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_get_pin_status_output_get_pin2_status:
 * @self: a #QmiMessageDmsUimGetPinStatusOutput.
 * @pin2_status_current_status: a placeholder for the output #QmiDmsUimPinStatus, or %NULL if not required.
 * @pin2_status_verify_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @pin2_status_unblock_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PIN2 Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_get_pin_status_output_get_pin2_status (
    QmiMessageDmsUimGetPinStatusOutput *self,
    QmiDmsUimPinStatus *pin2_status_current_status,
    guint8 *pin2_status_verify_retries_left,
    guint8 *pin2_status_unblock_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_pin2_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PIN2 Status' was not found in the message");
        return FALSE;
    }

    if (pin2_status_current_status)
        *pin2_status_current_status = (QmiDmsUimPinStatus)(self->arg_pin2_status_current_status);
    if (pin2_status_verify_retries_left)
        *pin2_status_verify_retries_left = self->arg_pin2_status_verify_retries_left;
    if (pin2_status_unblock_retries_left)
        *pin2_status_unblock_retries_left = self->arg_pin2_status_unblock_retries_left;

    return TRUE;
}

/**
 * qmi_message_dms_uim_get_pin_status_output_get_pin1_status:
 * @self: a #QmiMessageDmsUimGetPinStatusOutput.
 * @pin1_status_current_status: a placeholder for the output #QmiDmsUimPinStatus, or %NULL if not required.
 * @pin1_status_verify_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @pin1_status_unblock_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PIN1 Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_get_pin_status_output_get_pin1_status (
    QmiMessageDmsUimGetPinStatusOutput *self,
    QmiDmsUimPinStatus *pin1_status_current_status,
    guint8 *pin1_status_verify_retries_left,
    guint8 *pin1_status_unblock_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_pin1_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PIN1 Status' was not found in the message");
        return FALSE;
    }

    if (pin1_status_current_status)
        *pin1_status_current_status = (QmiDmsUimPinStatus)(self->arg_pin1_status_current_status);
    if (pin1_status_verify_retries_left)
        *pin1_status_verify_retries_left = self->arg_pin1_status_verify_retries_left;
    if (pin1_status_unblock_retries_left)
        *pin1_status_unblock_retries_left = self->arg_pin1_status_unblock_retries_left;

    return TRUE;
}

GType
qmi_message_dms_uim_get_pin_status_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimGetPinStatusOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_get_pin_status_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_get_pin_status_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_get_pin_status_output_ref:
 * @self: a #QmiMessageDmsUimGetPinStatusOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimGetPinStatusOutput *
qmi_message_dms_uim_get_pin_status_output_ref (QmiMessageDmsUimGetPinStatusOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_get_pin_status_output_unref:
 * @self: a #QmiMessageDmsUimGetPinStatusOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_get_pin_status_output_unref (QmiMessageDmsUimGetPinStatusOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsUimGetPinStatusOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_get_pin_status_output_pin2_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PIN2 Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PIN2 Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_get_pin_status_output_pin2_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_PIN2_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_get_pin_status_output_pin2_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " current_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_PIN_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_pin_status_get_string ((QmiDmsUimPinStatus)tmp));
#elif defined  __QMI_DMS_UIM_PIN_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_pin_status_build_string_from_mask ((QmiDmsUimPinStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimPinStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " verify_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unblock_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PIN2 Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_uim_get_pin_status_output_pin1_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PIN1 Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PIN1 Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_get_pin_status_output_pin1_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_PIN1_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_get_pin_status_output_pin1_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " current_status = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_PIN_STATUS_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_pin_status_get_string ((QmiDmsUimPinStatus)tmp));
#elif defined  __QMI_DMS_UIM_PIN_STATUS_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_pin_status_build_string_from_mask ((QmiDmsUimPinStatus)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimPinStatus
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " verify_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unblock_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PIN1 Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_get_pin_status_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_get_pin_status_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_get_pin_status_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_PIN2_STATUS:
            tlv_type_str = "PIN2 Status";
            translated_value = qmi_message_dms_uim_get_pin_status_output_pin2_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_PIN1_STATUS:
            tlv_type_str = "PIN1 Status";
            translated_value = qmi_message_dms_uim_get_pin_status_output_pin1_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_get_pin_status_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Get PIN Status\" (0x002B)\n",
                            line_prefix);

    {
        struct message_uim_get_pin_status_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_get_pin_status_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimGetPinStatusOutput *
__qmi_message_dms_uim_get_pin_status_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimGetPinStatusOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS, NULL);

    self = g_slice_new0 (QmiMessageDmsUimGetPinStatusOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_get_pin_status_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_PIN2_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_get_pin_status_output_pin2_status_validate (buffer, buffer_len)) {
                self->arg_pin2_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_pin2_status_current_status = (QmiDmsUimPinStatus)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin2_status_verify_retries_left));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin2_status_unblock_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PIN2 Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS_OUTPUT_TLV_PIN1_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_get_pin_status_output_pin1_status_validate (buffer, buffer_len)) {
                self->arg_pin1_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_pin1_status_current_status = (QmiDmsUimPinStatus)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin1_status_verify_retries_left));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_pin1_status_unblock_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PIN1 Status' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Hardware Revision */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_hardware_revision_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_HARDWARE_REVISION);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetHardwareRevisionOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Revision */
    gboolean arg_revision_set;
    gchar *arg_revision;
};

#define QMI_MESSAGE_DMS_GET_HARDWARE_REVISION_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_HARDWARE_REVISION_OUTPUT_TLV_REVISION 0x01

/**
 * qmi_message_dms_get_hardware_revision_output_get_result:
 * @self: a QmiMessageDmsGetHardwareRevisionOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_hardware_revision_output_get_result (
    QmiMessageDmsGetHardwareRevisionOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_hardware_revision_output_get_revision:
 * @self: a #QmiMessageDmsGetHardwareRevisionOutput.
 * @revision: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Revision' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_hardware_revision_output_get_revision (
    QmiMessageDmsGetHardwareRevisionOutput *self,
    const gchar **revision,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_revision_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Revision' was not found in the message");
        return FALSE;
    }

    if (revision)
        *revision = self->arg_revision;

    return TRUE;
}

GType
qmi_message_dms_get_hardware_revision_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetHardwareRevisionOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_hardware_revision_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_hardware_revision_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_hardware_revision_output_ref:
 * @self: a #QmiMessageDmsGetHardwareRevisionOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetHardwareRevisionOutput *
qmi_message_dms_get_hardware_revision_output_ref (QmiMessageDmsGetHardwareRevisionOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_hardware_revision_output_unref:
 * @self: a #QmiMessageDmsGetHardwareRevisionOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_hardware_revision_output_unref (QmiMessageDmsGetHardwareRevisionOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_revision);
        g_slice_free (QmiMessageDmsGetHardwareRevisionOutput, self);
    }
}

static gboolean
qmi_message_dms_get_hardware_revision_output_revision_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Revision' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Revision' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_hardware_revision_output_revision_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_HARDWARE_REVISION_OUTPUT_TLV_REVISION,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_hardware_revision_output_revision_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Revision' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_hardware_revision_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_hardware_revision_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_hardware_revision_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_HARDWARE_REVISION_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_HARDWARE_REVISION_OUTPUT_TLV_REVISION:
            tlv_type_str = "Revision";
            translated_value = qmi_message_dms_get_hardware_revision_output_revision_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_hardware_revision_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Hardware Revision\" (0x002C)\n",
                            line_prefix);

    {
        struct message_get_hardware_revision_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_hardware_revision_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetHardwareRevisionOutput *
__qmi_message_dms_get_hardware_revision_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetHardwareRevisionOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_HARDWARE_REVISION, NULL);

    self = g_slice_new0 (QmiMessageDmsGetHardwareRevisionOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_HARDWARE_REVISION_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_hardware_revision_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_HARDWARE_REVISION_OUTPUT_TLV_REVISION,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_hardware_revision_output_revision_validate (buffer, buffer_len)) {
                self->arg_revision_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_revision));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Revision' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Revision TLV: Not found");
                qmi_message_dms_get_hardware_revision_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Operating Mode */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_operating_mode_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_OPERATING_MODE);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetOperatingModeOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Mode */
    gboolean arg_mode_set;
    guint8 arg_mode;

    /* Offline Reason */
    gboolean arg_offline_reason_set;
    guint16 arg_offline_reason;

    /* Hardware Restricted Mode */
    gboolean arg_hardware_restricted_mode_set;
    guint8 arg_hardware_restricted_mode;
};

#define QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_MODE 0x01
#define QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_OFFLINE_REASON 0x10
#define QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_HARDWARE_RESTRICTED_MODE 0x11

/**
 * qmi_message_dms_get_operating_mode_output_get_result:
 * @self: a QmiMessageDmsGetOperatingModeOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_operating_mode_output_get_result (
    QmiMessageDmsGetOperatingModeOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_operating_mode_output_get_mode:
 * @self: a #QmiMessageDmsGetOperatingModeOutput.
 * @mode: a placeholder for the output #QmiDmsOperatingMode, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Mode' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_operating_mode_output_get_mode (
    QmiMessageDmsGetOperatingModeOutput *self,
    QmiDmsOperatingMode *mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mode_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Mode' was not found in the message");
        return FALSE;
    }

    if (mode)
        *mode = (QmiDmsOperatingMode)(self->arg_mode);

    return TRUE;
}

/**
 * qmi_message_dms_get_operating_mode_output_get_offline_reason:
 * @self: a #QmiMessageDmsGetOperatingModeOutput.
 * @offline_reason: a placeholder for the output #QmiDmsOfflineReason, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Offline Reason' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_operating_mode_output_get_offline_reason (
    QmiMessageDmsGetOperatingModeOutput *self,
    QmiDmsOfflineReason *offline_reason,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_offline_reason_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Offline Reason' was not found in the message");
        return FALSE;
    }

    if (offline_reason)
        *offline_reason = (QmiDmsOfflineReason)(self->arg_offline_reason);

    return TRUE;
}

/**
 * qmi_message_dms_get_operating_mode_output_get_hardware_restricted_mode:
 * @self: a #QmiMessageDmsGetOperatingModeOutput.
 * @hardware_restricted_mode: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Hardware Restricted Mode' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_operating_mode_output_get_hardware_restricted_mode (
    QmiMessageDmsGetOperatingModeOutput *self,
    gboolean *hardware_restricted_mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_hardware_restricted_mode_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Hardware Restricted Mode' was not found in the message");
        return FALSE;
    }

    if (hardware_restricted_mode)
        *hardware_restricted_mode = (gboolean)(self->arg_hardware_restricted_mode);

    return TRUE;
}

GType
qmi_message_dms_get_operating_mode_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetOperatingModeOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_operating_mode_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_operating_mode_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_operating_mode_output_ref:
 * @self: a #QmiMessageDmsGetOperatingModeOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetOperatingModeOutput *
qmi_message_dms_get_operating_mode_output_ref (QmiMessageDmsGetOperatingModeOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_operating_mode_output_unref:
 * @self: a #QmiMessageDmsGetOperatingModeOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_operating_mode_output_unref (QmiMessageDmsGetOperatingModeOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsGetOperatingModeOutput, self);
    }
}

static gboolean
qmi_message_dms_get_operating_mode_output_mode_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Mode' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Mode' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_operating_mode_output_mode_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_MODE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_operating_mode_output_mode_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_OPERATING_MODE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_operating_mode_get_string ((QmiDmsOperatingMode)tmp));
#elif defined  __QMI_DMS_OPERATING_MODE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_operating_mode_build_string_from_mask ((QmiDmsOperatingMode)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsOperatingMode
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Mode' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_operating_mode_output_offline_reason_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Offline Reason' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Offline Reason' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_operating_mode_output_offline_reason_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_OFFLINE_REASON,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_operating_mode_output_offline_reason_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_DMS_OFFLINE_REASON_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_offline_reason_get_string ((QmiDmsOfflineReason)tmp));
#elif defined  __QMI_DMS_OFFLINE_REASON_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_offline_reason_build_string_from_mask ((QmiDmsOfflineReason)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsOfflineReason
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Offline Reason' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_operating_mode_output_hardware_restricted_mode_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Hardware Restricted Mode' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Hardware Restricted Mode' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_operating_mode_output_hardware_restricted_mode_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_HARDWARE_RESTRICTED_MODE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_operating_mode_output_hardware_restricted_mode_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Hardware Restricted Mode' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_operating_mode_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_operating_mode_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_operating_mode_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_MODE:
            tlv_type_str = "Mode";
            translated_value = qmi_message_dms_get_operating_mode_output_mode_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_OFFLINE_REASON:
            tlv_type_str = "Offline Reason";
            translated_value = qmi_message_dms_get_operating_mode_output_offline_reason_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_HARDWARE_RESTRICTED_MODE:
            tlv_type_str = "Hardware Restricted Mode";
            translated_value = qmi_message_dms_get_operating_mode_output_hardware_restricted_mode_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_operating_mode_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Operating Mode\" (0x002D)\n",
                            line_prefix);

    {
        struct message_get_operating_mode_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_operating_mode_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetOperatingModeOutput *
__qmi_message_dms_get_operating_mode_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetOperatingModeOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_OPERATING_MODE, NULL);

    self = g_slice_new0 (QmiMessageDmsGetOperatingModeOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_operating_mode_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_MODE,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_operating_mode_output_mode_validate (buffer, buffer_len)) {
                self->arg_mode_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_mode = (QmiDmsOperatingMode)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Mode' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Mode TLV: Not found");
                qmi_message_dms_get_operating_mode_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_mode == QMI_DMS_OPERATING_MODE_OFFLINE))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_OFFLINE_REASON,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_operating_mode_output_offline_reason_validate (buffer, buffer_len)) {
                self->arg_offline_reason_set = TRUE;

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_offline_reason = (QmiDmsOfflineReason)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Offline Reason' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_OPERATING_MODE_OUTPUT_TLV_HARDWARE_RESTRICTED_MODE,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_operating_mode_output_hardware_restricted_mode_validate (buffer, buffer_len)) {
                self->arg_hardware_restricted_mode_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_hardware_restricted_mode = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Hardware Restricted Mode' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Set Operating Mode */


/* --- Input -- */

struct _QmiMessageDmsSetOperatingModeInput {
    volatile gint ref_count;

    /* Mode */
    gboolean arg_mode_set;
    guint8 arg_mode;
};

#define QMI_MESSAGE_DMS_SET_OPERATING_MODE_INPUT_TLV_MODE 0x01

/**
 * qmi_message_dms_set_operating_mode_input_get_mode:
 * @self: a #QmiMessageDmsSetOperatingModeInput.
 * @mode: a placeholder for the output #QmiDmsOperatingMode, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Mode' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_operating_mode_input_get_mode (
    QmiMessageDmsSetOperatingModeInput *self,
    QmiDmsOperatingMode *mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mode_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Mode' was not found in the message");
        return FALSE;
    }

    if (mode)
        *mode = (QmiDmsOperatingMode)(self->arg_mode);

    return TRUE;
}

/**
 * qmi_message_dms_set_operating_mode_input_set_mode:
 * @self: a #QmiMessageDmsSetOperatingModeInput.
 * @mode: a #QmiDmsOperatingMode.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Mode' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_operating_mode_input_set_mode (
    QmiMessageDmsSetOperatingModeInput *self,
    QmiDmsOperatingMode mode,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_mode = (guint8)(mode);
    self->arg_mode_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_set_operating_mode_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetOperatingModeInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_operating_mode_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_operating_mode_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_operating_mode_input_ref:
 * @self: a #QmiMessageDmsSetOperatingModeInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetOperatingModeInput *
qmi_message_dms_set_operating_mode_input_ref (QmiMessageDmsSetOperatingModeInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_operating_mode_input_unref:
 * @self: a #QmiMessageDmsSetOperatingModeInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_operating_mode_input_unref (QmiMessageDmsSetOperatingModeInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetOperatingModeInput, self);
    }
}

/**
 * qmi_message_dms_set_operating_mode_input_new:
 *
 * Allocates a new #QmiMessageDmsSetOperatingModeInput.
 *
 * Returns: the newly created #QmiMessageDmsSetOperatingModeInput. The returned value should be freed with qmi_message_dms_set_operating_mode_input_unref().
 */
QmiMessageDmsSetOperatingModeInput *
qmi_message_dms_set_operating_mode_input_new (void)
{
    QmiMessageDmsSetOperatingModeInput *self;

    self = g_slice_new0 (QmiMessageDmsSetOperatingModeInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_set_operating_mode_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsSetOperatingModeInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_SET_OPERATING_MODE);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Set Operating Mode' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Mode' TLV */
    if (input->arg_mode_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_mode;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_OPERATING_MODE_INPUT_TLV_MODE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Mode TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Mode' in message 'Set Operating Mode'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsSetOperatingModeOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_SET_OPERATING_MODE_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_set_operating_mode_output_get_result:
 * @self: a QmiMessageDmsSetOperatingModeOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_set_operating_mode_output_get_result (
    QmiMessageDmsSetOperatingModeOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_set_operating_mode_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetOperatingModeOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_operating_mode_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_operating_mode_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_operating_mode_output_ref:
 * @self: a #QmiMessageDmsSetOperatingModeOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetOperatingModeOutput *
qmi_message_dms_set_operating_mode_output_ref (QmiMessageDmsSetOperatingModeOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_operating_mode_output_unref:
 * @self: a #QmiMessageDmsSetOperatingModeOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_operating_mode_output_unref (QmiMessageDmsSetOperatingModeOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetOperatingModeOutput, self);
    }
}

static gboolean
qmi_message_dms_set_operating_mode_input_mode_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Mode' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Mode' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_operating_mode_input_mode_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_OPERATING_MODE_INPUT_TLV_MODE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_operating_mode_input_mode_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_OPERATING_MODE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_operating_mode_get_string ((QmiDmsOperatingMode)tmp));
#elif defined  __QMI_DMS_OPERATING_MODE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_operating_mode_build_string_from_mask ((QmiDmsOperatingMode)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsOperatingMode
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Mode' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_operating_mode_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_operating_mode_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_operating_mode_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_OPERATING_MODE_INPUT_TLV_MODE:
            tlv_type_str = "Mode";
            translated_value = qmi_message_dms_set_operating_mode_input_mode_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_OPERATING_MODE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_operating_mode_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Operating Mode\" (0x002E)\n",
                            line_prefix);

    {
        struct message_set_operating_mode_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_operating_mode_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsSetOperatingModeOutput *
__qmi_message_dms_set_operating_mode_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsSetOperatingModeOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_SET_OPERATING_MODE, NULL);

    self = g_slice_new0 (QmiMessageDmsSetOperatingModeOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_SET_OPERATING_MODE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_set_operating_mode_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Time */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_time_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_TIME);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetTimeOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Device Time */
    gboolean arg_device_time_set;
    guint64 arg_device_time_time_count;
    guint16 arg_device_time_time_source;

    /* System Time */
    gboolean arg_system_time_set;
    guint64 arg_system_time;

    /* User Time */
    gboolean arg_user_time_set;
    guint64 arg_user_time;
};

#define QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_DEVICE_TIME 0x01
#define QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_SYSTEM_TIME 0x10
#define QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_USER_TIME 0x11

/**
 * qmi_message_dms_get_time_output_get_result:
 * @self: a QmiMessageDmsGetTimeOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_time_output_get_result (
    QmiMessageDmsGetTimeOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_time_output_get_device_time:
 * @self: a #QmiMessageDmsGetTimeOutput.
 * @device_time_time_count: a placeholder for the output #guint64, or %NULL if not required.
 * @device_time_time_source: a placeholder for the output #QmiDmsTimeSource, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Device Time' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_time_output_get_device_time (
    QmiMessageDmsGetTimeOutput *self,
    guint64 *device_time_time_count,
    QmiDmsTimeSource *device_time_time_source,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_device_time_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Device Time' was not found in the message");
        return FALSE;
    }

    if (device_time_time_count)
        *device_time_time_count = self->arg_device_time_time_count;
    if (device_time_time_source)
        *device_time_time_source = (QmiDmsTimeSource)(self->arg_device_time_time_source);

    return TRUE;
}

/**
 * qmi_message_dms_get_time_output_get_system_time:
 * @self: a #QmiMessageDmsGetTimeOutput.
 * @system_time: a placeholder for the output #guint64, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'System Time' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_time_output_get_system_time (
    QmiMessageDmsGetTimeOutput *self,
    guint64 *system_time,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_system_time_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'System Time' was not found in the message");
        return FALSE;
    }

    if (system_time)
        *system_time = self->arg_system_time;

    return TRUE;
}

/**
 * qmi_message_dms_get_time_output_get_user_time:
 * @self: a #QmiMessageDmsGetTimeOutput.
 * @user_time: a placeholder for the output #guint64, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'User Time' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_time_output_get_user_time (
    QmiMessageDmsGetTimeOutput *self,
    guint64 *user_time,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_user_time_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'User Time' was not found in the message");
        return FALSE;
    }

    if (user_time)
        *user_time = self->arg_user_time;

    return TRUE;
}

GType
qmi_message_dms_get_time_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetTimeOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_time_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_time_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_time_output_ref:
 * @self: a #QmiMessageDmsGetTimeOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetTimeOutput *
qmi_message_dms_get_time_output_ref (QmiMessageDmsGetTimeOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_time_output_unref:
 * @self: a #QmiMessageDmsGetTimeOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_time_output_unref (QmiMessageDmsGetTimeOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsGetTimeOutput, self);
    }
}

static gboolean
qmi_message_dms_get_time_output_device_time_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 6;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Device Time' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Device Time' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_time_output_device_time_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_DEVICE_TIME,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_time_output_device_time_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " time_count = '");

        {
            guint64 tmp;

            /* Read the 6-byte long variable from the buffer */
            qmi_utils_read_sized_guint_from_buffer (
                &buffer,
                &buffer_len,
                6,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " time_source = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_DMS_TIME_SOURCE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_time_source_get_string ((QmiDmsTimeSource)tmp));
#elif defined  __QMI_DMS_TIME_SOURCE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_time_source_build_string_from_mask ((QmiDmsTimeSource)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsTimeSource
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Device Time' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_time_output_system_time_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'System Time' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'System Time' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_time_output_system_time_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_SYSTEM_TIME,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_time_output_system_time_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'System Time' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_time_output_user_time_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'User Time' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'User Time' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_time_output_user_time_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_USER_TIME,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_time_output_user_time_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'User Time' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_time_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_time_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_time_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_DEVICE_TIME:
            tlv_type_str = "Device Time";
            translated_value = qmi_message_dms_get_time_output_device_time_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_SYSTEM_TIME:
            tlv_type_str = "System Time";
            translated_value = qmi_message_dms_get_time_output_system_time_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_USER_TIME:
            tlv_type_str = "User Time";
            translated_value = qmi_message_dms_get_time_output_user_time_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_time_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Time\" (0x002F)\n",
                            line_prefix);

    {
        struct message_get_time_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_time_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetTimeOutput *
__qmi_message_dms_get_time_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetTimeOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_TIME, NULL);

    self = g_slice_new0 (QmiMessageDmsGetTimeOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_time_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_DEVICE_TIME,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_time_output_device_time_validate (buffer, buffer_len)) {
                self->arg_device_time_set = TRUE;

                /* Read the 6-byte long variable from the buffer */
                qmi_utils_read_sized_guint_from_buffer (
                    &buffer,
                    &buffer_len,
                    6,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_device_time_time_count));
                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_device_time_time_source = (QmiDmsTimeSource)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Device Time' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Device Time TLV: Not found");
                qmi_message_dms_get_time_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_SYSTEM_TIME,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_time_output_system_time_validate (buffer, buffer_len)) {
                self->arg_system_time_set = TRUE;

                /* Read the guint64 variable from the buffer */
                qmi_utils_read_guint64_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_system_time));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'System Time' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_TIME_OUTPUT_TLV_USER_TIME,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_time_output_user_time_validate (buffer, buffer_len)) {
                self->arg_user_time_set = TRUE;

                /* Read the guint64 variable from the buffer */
                qmi_utils_read_guint64_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_user_time));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'User Time' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get PRL Version */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_prl_version_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_PRL_VERSION);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetPrlVersionOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Version */
    gboolean arg_version_set;
    guint16 arg_version;

    /* PRL Only Preference */
    gboolean arg_prl_only_preference_set;
    guint8 arg_prl_only_preference;
};

#define QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_VERSION 0x01
#define QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_PRL_ONLY_PREFERENCE 0x10

/**
 * qmi_message_dms_get_prl_version_output_get_result:
 * @self: a QmiMessageDmsGetPrlVersionOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_prl_version_output_get_result (
    QmiMessageDmsGetPrlVersionOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_prl_version_output_get_version:
 * @self: a #QmiMessageDmsGetPrlVersionOutput.
 * @version: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Version' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_prl_version_output_get_version (
    QmiMessageDmsGetPrlVersionOutput *self,
    guint16 *version,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_version_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Version' was not found in the message");
        return FALSE;
    }

    if (version)
        *version = self->arg_version;

    return TRUE;
}

/**
 * qmi_message_dms_get_prl_version_output_get_prl_only_preference:
 * @self: a #QmiMessageDmsGetPrlVersionOutput.
 * @prl_only_preference: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PRL Only Preference' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_prl_version_output_get_prl_only_preference (
    QmiMessageDmsGetPrlVersionOutput *self,
    gboolean *prl_only_preference,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_prl_only_preference_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PRL Only Preference' was not found in the message");
        return FALSE;
    }

    if (prl_only_preference)
        *prl_only_preference = (gboolean)(self->arg_prl_only_preference);

    return TRUE;
}

GType
qmi_message_dms_get_prl_version_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetPrlVersionOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_prl_version_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_prl_version_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_prl_version_output_ref:
 * @self: a #QmiMessageDmsGetPrlVersionOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetPrlVersionOutput *
qmi_message_dms_get_prl_version_output_ref (QmiMessageDmsGetPrlVersionOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_prl_version_output_unref:
 * @self: a #QmiMessageDmsGetPrlVersionOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_prl_version_output_unref (QmiMessageDmsGetPrlVersionOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsGetPrlVersionOutput, self);
    }
}

static gboolean
qmi_message_dms_get_prl_version_output_version_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Version' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Version' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_prl_version_output_version_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_VERSION,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_prl_version_output_version_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Version' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_prl_version_output_prl_only_preference_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PRL Only Preference' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PRL Only Preference' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_prl_version_output_prl_only_preference_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_PRL_ONLY_PREFERENCE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_prl_version_output_prl_only_preference_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PRL Only Preference' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_prl_version_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_prl_version_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_prl_version_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_VERSION:
            tlv_type_str = "Version";
            translated_value = qmi_message_dms_get_prl_version_output_version_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_PRL_ONLY_PREFERENCE:
            tlv_type_str = "PRL Only Preference";
            translated_value = qmi_message_dms_get_prl_version_output_prl_only_preference_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_prl_version_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get PRL Version\" (0x0030)\n",
                            line_prefix);

    {
        struct message_get_prl_version_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_prl_version_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetPrlVersionOutput *
__qmi_message_dms_get_prl_version_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetPrlVersionOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_PRL_VERSION, NULL);

    self = g_slice_new0 (QmiMessageDmsGetPrlVersionOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_prl_version_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_VERSION,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_prl_version_output_version_validate (buffer, buffer_len)) {
                self->arg_version_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_version));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Version' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Version TLV: Not found");
                qmi_message_dms_get_prl_version_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_PRL_VERSION_OUTPUT_TLV_PRL_ONLY_PREFERENCE,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_prl_version_output_prl_only_preference_validate (buffer, buffer_len)) {
                self->arg_prl_only_preference_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_prl_only_preference = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PRL Only Preference' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Activation State */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_activation_state_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_ACTIVATION_STATE);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetActivationStateOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Info */
    gboolean arg_info_set;
    guint16 arg_info;
};

#define QMI_MESSAGE_DMS_GET_ACTIVATION_STATE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_ACTIVATION_STATE_OUTPUT_TLV_INFO 0x01

/**
 * qmi_message_dms_get_activation_state_output_get_result:
 * @self: a QmiMessageDmsGetActivationStateOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_activation_state_output_get_result (
    QmiMessageDmsGetActivationStateOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_activation_state_output_get_info:
 * @self: a #QmiMessageDmsGetActivationStateOutput.
 * @info: a placeholder for the output #QmiDmsActivationState, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_activation_state_output_get_info (
    QmiMessageDmsGetActivationStateOutput *self,
    QmiDmsActivationState *info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (info)
        *info = (QmiDmsActivationState)(self->arg_info);

    return TRUE;
}

GType
qmi_message_dms_get_activation_state_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetActivationStateOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_activation_state_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_activation_state_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_activation_state_output_ref:
 * @self: a #QmiMessageDmsGetActivationStateOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetActivationStateOutput *
qmi_message_dms_get_activation_state_output_ref (QmiMessageDmsGetActivationStateOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_activation_state_output_unref:
 * @self: a #QmiMessageDmsGetActivationStateOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_activation_state_output_unref (QmiMessageDmsGetActivationStateOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsGetActivationStateOutput, self);
    }
}

static gboolean
qmi_message_dms_get_activation_state_output_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_activation_state_output_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_ACTIVATION_STATE_OUTPUT_TLV_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_activation_state_output_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_DMS_ACTIVATION_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_activation_state_get_string ((QmiDmsActivationState)tmp));
#elif defined  __QMI_DMS_ACTIVATION_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_activation_state_build_string_from_mask ((QmiDmsActivationState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsActivationState
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_activation_state_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_activation_state_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_activation_state_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_ACTIVATION_STATE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_ACTIVATION_STATE_OUTPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_dms_get_activation_state_output_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_activation_state_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Activation State\" (0x0031)\n",
                            line_prefix);

    {
        struct message_get_activation_state_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_activation_state_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetActivationStateOutput *
__qmi_message_dms_get_activation_state_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetActivationStateOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_ACTIVATION_STATE, NULL);

    self = g_slice_new0 (QmiMessageDmsGetActivationStateOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_ACTIVATION_STATE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_activation_state_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_ACTIVATION_STATE_OUTPUT_TLV_INFO,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_activation_state_output_info_validate (buffer, buffer_len)) {
                self->arg_info_set = TRUE;

                {
                    guint16 tmp;

                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_info = (QmiDmsActivationState)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Info' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Info TLV: Not found");
                qmi_message_dms_get_activation_state_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Activate Automatic */


/* --- Input -- */

struct _QmiMessageDmsActivateAutomaticInput {
    volatile gint ref_count;

    /* Activation Code */
    gboolean arg_activation_code_set;
    gchar *arg_activation_code;
};

#define QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC_INPUT_TLV_ACTIVATION_CODE 0x01

/**
 * qmi_message_dms_activate_automatic_input_get_activation_code:
 * @self: a #QmiMessageDmsActivateAutomaticInput.
 * @activation_code: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Activation Code' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_activate_automatic_input_get_activation_code (
    QmiMessageDmsActivateAutomaticInput *self,
    const gchar **activation_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_activation_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Activation Code' was not found in the message");
        return FALSE;
    }

    if (activation_code)
        *activation_code = self->arg_activation_code;

    return TRUE;
}

/**
 * qmi_message_dms_activate_automatic_input_set_activation_code:
 * @self: a #QmiMessageDmsActivateAutomaticInput.
 * @activation_code: a constant string.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Activation Code' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_activate_automatic_input_set_activation_code (
    QmiMessageDmsActivateAutomaticInput *self,
    const gchar *activation_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    g_free (self->arg_activation_code);
    self->arg_activation_code = g_strdup (activation_code ? activation_code : "");
    self->arg_activation_code_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_activate_automatic_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsActivateAutomaticInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_activate_automatic_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_activate_automatic_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_activate_automatic_input_ref:
 * @self: a #QmiMessageDmsActivateAutomaticInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsActivateAutomaticInput *
qmi_message_dms_activate_automatic_input_ref (QmiMessageDmsActivateAutomaticInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_activate_automatic_input_unref:
 * @self: a #QmiMessageDmsActivateAutomaticInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_activate_automatic_input_unref (QmiMessageDmsActivateAutomaticInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_activation_code);
        g_slice_free (QmiMessageDmsActivateAutomaticInput, self);
    }
}

/**
 * qmi_message_dms_activate_automatic_input_new:
 *
 * Allocates a new #QmiMessageDmsActivateAutomaticInput.
 *
 * Returns: the newly created #QmiMessageDmsActivateAutomaticInput. The returned value should be freed with qmi_message_dms_activate_automatic_input_unref().
 */
QmiMessageDmsActivateAutomaticInput *
qmi_message_dms_activate_automatic_input_new (void)
{
    QmiMessageDmsActivateAutomaticInput *self;

    self = g_slice_new0 (QmiMessageDmsActivateAutomaticInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_activate_automatic_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsActivateAutomaticInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Activate Automatic' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Activation Code' TLV */
    if (input->arg_activation_code_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_activation_code);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC_INPUT_TLV_ACTIVATION_CODE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Activation Code TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Activation Code' in message 'Activate Automatic'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsActivateAutomaticOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_activate_automatic_output_get_result:
 * @self: a QmiMessageDmsActivateAutomaticOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_activate_automatic_output_get_result (
    QmiMessageDmsActivateAutomaticOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_activate_automatic_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsActivateAutomaticOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_activate_automatic_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_activate_automatic_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_activate_automatic_output_ref:
 * @self: a #QmiMessageDmsActivateAutomaticOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsActivateAutomaticOutput *
qmi_message_dms_activate_automatic_output_ref (QmiMessageDmsActivateAutomaticOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_activate_automatic_output_unref:
 * @self: a #QmiMessageDmsActivateAutomaticOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_activate_automatic_output_unref (QmiMessageDmsActivateAutomaticOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsActivateAutomaticOutput, self);
    }
}

static gboolean
qmi_message_dms_activate_automatic_input_activation_code_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Activation Code' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Activation Code' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_activate_automatic_input_activation_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC_INPUT_TLV_ACTIVATION_CODE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_activate_automatic_input_activation_code_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Activation Code' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_activate_automatic_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_activate_automatic_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_activate_automatic_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC_INPUT_TLV_ACTIVATION_CODE:
            tlv_type_str = "Activation Code";
            translated_value = qmi_message_dms_activate_automatic_input_activation_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_activate_automatic_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Activate Automatic\" (0x0032)\n",
                            line_prefix);

    {
        struct message_activate_automatic_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_activate_automatic_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsActivateAutomaticOutput *
__qmi_message_dms_activate_automatic_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsActivateAutomaticOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC, NULL);

    self = g_slice_new0 (QmiMessageDmsActivateAutomaticOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_activate_automatic_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Activate Manual */


/* --- Input -- */

struct _QmiMessageDmsActivateManualInput {
    volatile gint ref_count;

    /* MN AAA key */
    gboolean arg_mn_aaa_key_set;
    gchar *arg_mn_aaa_key;

    /* MN HA key */
    gboolean arg_mn_ha_key_set;
    gchar *arg_mn_ha_key;

    /* Info */
    gboolean arg_info_set;
    gchar arg_info_service_programming_code[7];
    gchar arg_info_system_identification_number[3];
    gchar *arg_info_mobile_directory_number;
    gchar *arg_info_mobile_identification_number;
};

#define QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_MN_AAA_KEY 0x12
#define QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_MN_HA_KEY 0x11
#define QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_INFO 0x01

/**
 * qmi_message_dms_activate_manual_input_get_mn_aaa_key:
 * @self: a #QmiMessageDmsActivateManualInput.
 * @mn_aaa_key: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'MN AAA key' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_activate_manual_input_get_mn_aaa_key (
    QmiMessageDmsActivateManualInput *self,
    const gchar **mn_aaa_key,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mn_aaa_key_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MN AAA key' was not found in the message");
        return FALSE;
    }

    if (mn_aaa_key)
        *mn_aaa_key = self->arg_mn_aaa_key;

    return TRUE;
}

/**
 * qmi_message_dms_activate_manual_input_set_mn_aaa_key:
 * @self: a #QmiMessageDmsActivateManualInput.
 * @mn_aaa_key: a constant string with a maximum length of 16 characters.
 * @error: Return location for error or %NULL.
 *
 * Set the 'MN AAA key' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_activate_manual_input_set_mn_aaa_key (
    QmiMessageDmsActivateManualInput *self,
    const gchar *mn_aaa_key,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (mn_aaa_key && strlen (mn_aaa_key) > 16) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'mn_aaa_key' must be less than 16 characters long");
        return FALSE;
    }
    g_free (self->arg_mn_aaa_key);
    self->arg_mn_aaa_key = g_strdup (mn_aaa_key ? mn_aaa_key : "");
    self->arg_mn_aaa_key_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_activate_manual_input_get_mn_ha_key:
 * @self: a #QmiMessageDmsActivateManualInput.
 * @mn_ha_key: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'MN HA key' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_activate_manual_input_get_mn_ha_key (
    QmiMessageDmsActivateManualInput *self,
    const gchar **mn_ha_key,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_mn_ha_key_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'MN HA key' was not found in the message");
        return FALSE;
    }

    if (mn_ha_key)
        *mn_ha_key = self->arg_mn_ha_key;

    return TRUE;
}

/**
 * qmi_message_dms_activate_manual_input_set_mn_ha_key:
 * @self: a #QmiMessageDmsActivateManualInput.
 * @mn_ha_key: a constant string with a maximum length of 16 characters.
 * @error: Return location for error or %NULL.
 *
 * Set the 'MN HA key' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_activate_manual_input_set_mn_ha_key (
    QmiMessageDmsActivateManualInput *self,
    const gchar *mn_ha_key,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (mn_ha_key && strlen (mn_ha_key) > 16) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'mn_ha_key' must be less than 16 characters long");
        return FALSE;
    }
    g_free (self->arg_mn_ha_key);
    self->arg_mn_ha_key = g_strdup (mn_ha_key ? mn_ha_key : "");
    self->arg_mn_ha_key_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_activate_manual_input_get_info:
 * @self: a #QmiMessageDmsActivateManualInput.
 * @info_service_programming_code: a placeholder for the output constant string, or %NULL if not required.
 * @info_system_identification_number: a placeholder for the output constant string, or %NULL if not required.
 * @info_mobile_directory_number: a placeholder for the output constant string, or %NULL if not required.
 * @info_mobile_identification_number: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_activate_manual_input_get_info (
    QmiMessageDmsActivateManualInput *self,
    const gchar **info_service_programming_code,
    const gchar **info_system_identification_number,
    const gchar **info_mobile_directory_number,
    const gchar **info_mobile_identification_number,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (info_service_programming_code)
        *info_service_programming_code = self->arg_info_service_programming_code;
    if (info_system_identification_number)
        *info_system_identification_number = self->arg_info_system_identification_number;
    if (info_mobile_directory_number)
        *info_mobile_directory_number = self->arg_info_mobile_directory_number;
    if (info_mobile_identification_number)
        *info_mobile_identification_number = self->arg_info_mobile_identification_number;

    return TRUE;
}

/**
 * qmi_message_dms_activate_manual_input_set_info:
 * @self: a #QmiMessageDmsActivateManualInput.
 * @info_service_programming_code: a constant string of exactly 6 characters.
 * @info_system_identification_number: a constant string of exactly 2 characters.
 * @info_mobile_directory_number: a constant string with a maximum length of 15 characters.
 * @info_mobile_identification_number: a constant string with a maximum length of 15 characters.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Info' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_activate_manual_input_set_info (
    QmiMessageDmsActivateManualInput *self,
    const gchar *info_service_programming_code,
    const gchar *info_system_identification_number,
    const gchar *info_mobile_directory_number,
    const gchar *info_mobile_identification_number,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!info_service_programming_code || strlen (info_service_programming_code) != 6) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'info_service_programming_code' must be 6 characters long");
        return FALSE;
    }
    memcpy (self->arg_info_service_programming_code, info_service_programming_code, 6);
    self->arg_info_service_programming_code[6] = '\0';
    if (!info_system_identification_number || strlen (info_system_identification_number) != 2) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'info_system_identification_number' must be 2 characters long");
        return FALSE;
    }
    memcpy (self->arg_info_system_identification_number, info_system_identification_number, 2);
    self->arg_info_system_identification_number[2] = '\0';
    if (info_mobile_directory_number && strlen (info_mobile_directory_number) > 15) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'info_mobile_directory_number' must be less than 15 characters long");
        return FALSE;
    }
    g_free (self->arg_info_mobile_directory_number);
    self->arg_info_mobile_directory_number = g_strdup (info_mobile_directory_number ? info_mobile_directory_number : "");
    if (info_mobile_identification_number && strlen (info_mobile_identification_number) > 15) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'info_mobile_identification_number' must be less than 15 characters long");
        return FALSE;
    }
    g_free (self->arg_info_mobile_identification_number);
    self->arg_info_mobile_identification_number = g_strdup (info_mobile_identification_number ? info_mobile_identification_number : "");
    self->arg_info_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_activate_manual_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsActivateManualInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_activate_manual_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_activate_manual_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_activate_manual_input_ref:
 * @self: a #QmiMessageDmsActivateManualInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsActivateManualInput *
qmi_message_dms_activate_manual_input_ref (QmiMessageDmsActivateManualInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_activate_manual_input_unref:
 * @self: a #QmiMessageDmsActivateManualInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_activate_manual_input_unref (QmiMessageDmsActivateManualInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_mn_aaa_key);
        g_free (self->arg_mn_ha_key);
        g_free (self->arg_info_mobile_directory_number);
        g_free (self->arg_info_mobile_identification_number);
        g_slice_free (QmiMessageDmsActivateManualInput, self);
    }
}

/**
 * qmi_message_dms_activate_manual_input_new:
 *
 * Allocates a new #QmiMessageDmsActivateManualInput.
 *
 * Returns: the newly created #QmiMessageDmsActivateManualInput. The returned value should be freed with qmi_message_dms_activate_manual_input_unref().
 */
QmiMessageDmsActivateManualInput *
qmi_message_dms_activate_manual_input_new (void)
{
    QmiMessageDmsActivateManualInput *self;

    self = g_slice_new0 (QmiMessageDmsActivateManualInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_activate_manual_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsActivateManualInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_ACTIVATE_MANUAL);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Activate Manual' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'MN AAA key' TLV */
    if (input->arg_mn_aaa_key_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            0,
            input->arg_mn_aaa_key);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_MN_AAA_KEY,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the MN AAA key TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'MN HA key' TLV */
    if (input->arg_mn_ha_key_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            0,
            input->arg_mn_ha_key);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_MN_HA_KEY,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the MN HA key TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Info' TLV */
    if (input->arg_info_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the fixed-size string variable to the buffer */
        qmi_utils_write_fixed_size_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            6,
            input->arg_info_service_programming_code);
        /* Write the fixed-size string variable to the buffer */
        qmi_utils_write_fixed_size_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            2,
            input->arg_info_system_identification_number);
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_info_mobile_directory_number);
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_info_mobile_identification_number);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_INFO,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Info TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Info' in message 'Activate Manual'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsActivateManualOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_ACTIVATE_MANUAL_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_activate_manual_output_get_result:
 * @self: a QmiMessageDmsActivateManualOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_activate_manual_output_get_result (
    QmiMessageDmsActivateManualOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_activate_manual_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsActivateManualOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_activate_manual_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_activate_manual_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_activate_manual_output_ref:
 * @self: a #QmiMessageDmsActivateManualOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsActivateManualOutput *
qmi_message_dms_activate_manual_output_ref (QmiMessageDmsActivateManualOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_activate_manual_output_unref:
 * @self: a #QmiMessageDmsActivateManualOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_activate_manual_output_unref (QmiMessageDmsActivateManualOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsActivateManualOutput, self);
    }
}

static gboolean
qmi_message_dms_activate_manual_input_mn_aaa_key_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'MN AAA key' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'MN AAA key' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_activate_manual_input_mn_aaa_key_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_MN_AAA_KEY,
                                      &buffer_len);
    if (buffer && qmi_message_dms_activate_manual_input_mn_aaa_key_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                16,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'MN AAA key' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_activate_manual_input_mn_ha_key_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'MN HA key' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'MN HA key' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_activate_manual_input_mn_ha_key_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_MN_HA_KEY,
                                      &buffer_len);
    if (buffer && qmi_message_dms_activate_manual_input_mn_ha_key_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                16,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'MN HA key' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_activate_manual_input_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 6;
    expected_len += 2;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_activate_manual_input_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_dms_activate_manual_input_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " service_programming_code = '");

        {
            gchar tmp[7];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                6,
                &tmp[0]);
            tmp[6] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " system_identification_number = '");

        {
            gchar tmp[3];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                2,
                &tmp[0]);
            tmp[2] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mobile_directory_number = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                15,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " mobile_identification_number = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                15,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_activate_manual_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_activate_manual_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_activate_manual_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_MN_AAA_KEY:
            tlv_type_str = "MN AAA key";
            translated_value = qmi_message_dms_activate_manual_input_mn_aaa_key_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_MN_HA_KEY:
            tlv_type_str = "MN HA key";
            translated_value = qmi_message_dms_activate_manual_input_mn_ha_key_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_ACTIVATE_MANUAL_INPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_dms_activate_manual_input_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_ACTIVATE_MANUAL_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_activate_manual_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Activate Manual\" (0x0033)\n",
                            line_prefix);

    {
        struct message_activate_manual_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_activate_manual_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsActivateManualOutput *
__qmi_message_dms_activate_manual_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsActivateManualOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_ACTIVATE_MANUAL, NULL);

    self = g_slice_new0 (QmiMessageDmsActivateManualOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_ACTIVATE_MANUAL_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_activate_manual_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get User Lock State */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_user_lock_state_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_USER_LOCK_STATE);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetUserLockStateOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Enabled */
    gboolean arg_enabled_set;
    guint8 arg_enabled;
};

#define QMI_MESSAGE_DMS_GET_USER_LOCK_STATE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_USER_LOCK_STATE_OUTPUT_TLV_ENABLED 0x01

/**
 * qmi_message_dms_get_user_lock_state_output_get_result:
 * @self: a QmiMessageDmsGetUserLockStateOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_user_lock_state_output_get_result (
    QmiMessageDmsGetUserLockStateOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_user_lock_state_output_get_enabled:
 * @self: a #QmiMessageDmsGetUserLockStateOutput.
 * @enabled: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Enabled' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_user_lock_state_output_get_enabled (
    QmiMessageDmsGetUserLockStateOutput *self,
    gboolean *enabled,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_enabled_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Enabled' was not found in the message");
        return FALSE;
    }

    if (enabled)
        *enabled = (gboolean)(self->arg_enabled);

    return TRUE;
}

GType
qmi_message_dms_get_user_lock_state_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetUserLockStateOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_user_lock_state_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_user_lock_state_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_user_lock_state_output_ref:
 * @self: a #QmiMessageDmsGetUserLockStateOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetUserLockStateOutput *
qmi_message_dms_get_user_lock_state_output_ref (QmiMessageDmsGetUserLockStateOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_user_lock_state_output_unref:
 * @self: a #QmiMessageDmsGetUserLockStateOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_user_lock_state_output_unref (QmiMessageDmsGetUserLockStateOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsGetUserLockStateOutput, self);
    }
}

static gboolean
qmi_message_dms_get_user_lock_state_output_enabled_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Enabled' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Enabled' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_user_lock_state_output_enabled_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_USER_LOCK_STATE_OUTPUT_TLV_ENABLED,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_user_lock_state_output_enabled_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Enabled' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_user_lock_state_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_user_lock_state_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_user_lock_state_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_USER_LOCK_STATE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_USER_LOCK_STATE_OUTPUT_TLV_ENABLED:
            tlv_type_str = "Enabled";
            translated_value = qmi_message_dms_get_user_lock_state_output_enabled_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_user_lock_state_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get User Lock State\" (0x0034)\n",
                            line_prefix);

    {
        struct message_get_user_lock_state_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_user_lock_state_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetUserLockStateOutput *
__qmi_message_dms_get_user_lock_state_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetUserLockStateOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_USER_LOCK_STATE, NULL);

    self = g_slice_new0 (QmiMessageDmsGetUserLockStateOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_USER_LOCK_STATE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_user_lock_state_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_USER_LOCK_STATE_OUTPUT_TLV_ENABLED,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_user_lock_state_output_enabled_validate (buffer, buffer_len)) {
                self->arg_enabled_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_enabled = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Enabled' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Enabled TLV: Not found");
                qmi_message_dms_get_user_lock_state_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Set User Lock State */


/* --- Input -- */

struct _QmiMessageDmsSetUserLockStateInput {
    volatile gint ref_count;

    /* Info */
    gboolean arg_info_set;
    guint8 arg_info_enabled;
    gchar arg_info_lock_code[5];
};

#define QMI_MESSAGE_DMS_SET_USER_LOCK_STATE_INPUT_TLV_INFO 0x01

/**
 * qmi_message_dms_set_user_lock_state_input_get_info:
 * @self: a #QmiMessageDmsSetUserLockStateInput.
 * @info_enabled: a placeholder for the output #gboolean, or %NULL if not required.
 * @info_lock_code: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_user_lock_state_input_get_info (
    QmiMessageDmsSetUserLockStateInput *self,
    gboolean *info_enabled,
    const gchar **info_lock_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (info_enabled)
        *info_enabled = (gboolean)(self->arg_info_enabled);
    if (info_lock_code)
        *info_lock_code = self->arg_info_lock_code;

    return TRUE;
}

/**
 * qmi_message_dms_set_user_lock_state_input_set_info:
 * @self: a #QmiMessageDmsSetUserLockStateInput.
 * @info_enabled: a #gboolean.
 * @info_lock_code: a constant string of exactly 4 characters.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Info' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_user_lock_state_input_set_info (
    QmiMessageDmsSetUserLockStateInput *self,
    gboolean info_enabled,
    const gchar *info_lock_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_info_enabled = (guint8)(info_enabled);
    if (!info_lock_code || strlen (info_lock_code) != 4) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'info_lock_code' must be 4 characters long");
        return FALSE;
    }
    memcpy (self->arg_info_lock_code, info_lock_code, 4);
    self->arg_info_lock_code[4] = '\0';
    self->arg_info_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_set_user_lock_state_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetUserLockStateInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_user_lock_state_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_user_lock_state_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_user_lock_state_input_ref:
 * @self: a #QmiMessageDmsSetUserLockStateInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetUserLockStateInput *
qmi_message_dms_set_user_lock_state_input_ref (QmiMessageDmsSetUserLockStateInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_user_lock_state_input_unref:
 * @self: a #QmiMessageDmsSetUserLockStateInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_user_lock_state_input_unref (QmiMessageDmsSetUserLockStateInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetUserLockStateInput, self);
    }
}

/**
 * qmi_message_dms_set_user_lock_state_input_new:
 *
 * Allocates a new #QmiMessageDmsSetUserLockStateInput.
 *
 * Returns: the newly created #QmiMessageDmsSetUserLockStateInput. The returned value should be freed with qmi_message_dms_set_user_lock_state_input_unref().
 */
QmiMessageDmsSetUserLockStateInput *
qmi_message_dms_set_user_lock_state_input_new (void)
{
    QmiMessageDmsSetUserLockStateInput *self;

    self = g_slice_new0 (QmiMessageDmsSetUserLockStateInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_set_user_lock_state_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsSetUserLockStateInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_SET_USER_LOCK_STATE);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Set User Lock State' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Info' TLV */
    if (input->arg_info_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_info_enabled;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the fixed-size string variable to the buffer */
        qmi_utils_write_fixed_size_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            4,
            input->arg_info_lock_code);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_USER_LOCK_STATE_INPUT_TLV_INFO,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Info TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Info' in message 'Set User Lock State'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsSetUserLockStateOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_SET_USER_LOCK_STATE_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_set_user_lock_state_output_get_result:
 * @self: a QmiMessageDmsSetUserLockStateOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_set_user_lock_state_output_get_result (
    QmiMessageDmsSetUserLockStateOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_set_user_lock_state_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetUserLockStateOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_user_lock_state_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_user_lock_state_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_user_lock_state_output_ref:
 * @self: a #QmiMessageDmsSetUserLockStateOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetUserLockStateOutput *
qmi_message_dms_set_user_lock_state_output_ref (QmiMessageDmsSetUserLockStateOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_user_lock_state_output_unref:
 * @self: a #QmiMessageDmsSetUserLockStateOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_user_lock_state_output_unref (QmiMessageDmsSetUserLockStateOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetUserLockStateOutput, self);
    }
}

static gboolean
qmi_message_dms_set_user_lock_state_input_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_user_lock_state_input_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_USER_LOCK_STATE_INPUT_TLV_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_user_lock_state_input_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " enabled = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }
        g_string_append (printable, "'");
        g_string_append (printable, " lock_code = '");

        {
            gchar tmp[5];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                4,
                &tmp[0]);
            tmp[4] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_user_lock_state_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_user_lock_state_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_user_lock_state_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_USER_LOCK_STATE_INPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_dms_set_user_lock_state_input_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_USER_LOCK_STATE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_user_lock_state_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set User Lock State\" (0x0035)\n",
                            line_prefix);

    {
        struct message_set_user_lock_state_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_user_lock_state_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsSetUserLockStateOutput *
__qmi_message_dms_set_user_lock_state_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsSetUserLockStateOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_SET_USER_LOCK_STATE, NULL);

    self = g_slice_new0 (QmiMessageDmsSetUserLockStateOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_SET_USER_LOCK_STATE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_set_user_lock_state_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Set User Lock Code */


/* --- Input -- */

struct _QmiMessageDmsSetUserLockCodeInput {
    volatile gint ref_count;

    /* Info */
    gboolean arg_info_set;
    gchar arg_info_old_code[5];
    gchar arg_info_new_code[5];
};

#define QMI_MESSAGE_DMS_SET_USER_LOCK_CODE_INPUT_TLV_INFO 0x01

/**
 * qmi_message_dms_set_user_lock_code_input_get_info:
 * @self: a #QmiMessageDmsSetUserLockCodeInput.
 * @info_old_code: a placeholder for the output constant string, or %NULL if not required.
 * @info_new_code: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Info' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_user_lock_code_input_get_info (
    QmiMessageDmsSetUserLockCodeInput *self,
    const gchar **info_old_code,
    const gchar **info_new_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_info_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Info' was not found in the message");
        return FALSE;
    }

    if (info_old_code)
        *info_old_code = self->arg_info_old_code;
    if (info_new_code)
        *info_new_code = self->arg_info_new_code;

    return TRUE;
}

/**
 * qmi_message_dms_set_user_lock_code_input_set_info:
 * @self: a #QmiMessageDmsSetUserLockCodeInput.
 * @info_old_code: a constant string of exactly 4 characters.
 * @info_new_code: a constant string of exactly 4 characters.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Info' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_user_lock_code_input_set_info (
    QmiMessageDmsSetUserLockCodeInput *self,
    const gchar *info_old_code,
    const gchar *info_new_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!info_old_code || strlen (info_old_code) != 4) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'info_old_code' must be 4 characters long");
        return FALSE;
    }
    memcpy (self->arg_info_old_code, info_old_code, 4);
    self->arg_info_old_code[4] = '\0';
    if (!info_new_code || strlen (info_new_code) != 4) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'info_new_code' must be 4 characters long");
        return FALSE;
    }
    memcpy (self->arg_info_new_code, info_new_code, 4);
    self->arg_info_new_code[4] = '\0';
    self->arg_info_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_set_user_lock_code_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetUserLockCodeInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_user_lock_code_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_user_lock_code_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_user_lock_code_input_ref:
 * @self: a #QmiMessageDmsSetUserLockCodeInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetUserLockCodeInput *
qmi_message_dms_set_user_lock_code_input_ref (QmiMessageDmsSetUserLockCodeInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_user_lock_code_input_unref:
 * @self: a #QmiMessageDmsSetUserLockCodeInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_user_lock_code_input_unref (QmiMessageDmsSetUserLockCodeInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetUserLockCodeInput, self);
    }
}

/**
 * qmi_message_dms_set_user_lock_code_input_new:
 *
 * Allocates a new #QmiMessageDmsSetUserLockCodeInput.
 *
 * Returns: the newly created #QmiMessageDmsSetUserLockCodeInput. The returned value should be freed with qmi_message_dms_set_user_lock_code_input_unref().
 */
QmiMessageDmsSetUserLockCodeInput *
qmi_message_dms_set_user_lock_code_input_new (void)
{
    QmiMessageDmsSetUserLockCodeInput *self;

    self = g_slice_new0 (QmiMessageDmsSetUserLockCodeInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_set_user_lock_code_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsSetUserLockCodeInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_SET_USER_LOCK_CODE);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Set User Lock Code' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Info' TLV */
    if (input->arg_info_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the fixed-size string variable to the buffer */
        qmi_utils_write_fixed_size_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            4,
            input->arg_info_old_code);
        /* Write the fixed-size string variable to the buffer */
        qmi_utils_write_fixed_size_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            4,
            input->arg_info_new_code);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_USER_LOCK_CODE_INPUT_TLV_INFO,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Info TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Info' in message 'Set User Lock Code'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsSetUserLockCodeOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_SET_USER_LOCK_CODE_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_set_user_lock_code_output_get_result:
 * @self: a QmiMessageDmsSetUserLockCodeOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_set_user_lock_code_output_get_result (
    QmiMessageDmsSetUserLockCodeOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_set_user_lock_code_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetUserLockCodeOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_user_lock_code_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_user_lock_code_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_user_lock_code_output_ref:
 * @self: a #QmiMessageDmsSetUserLockCodeOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetUserLockCodeOutput *
qmi_message_dms_set_user_lock_code_output_ref (QmiMessageDmsSetUserLockCodeOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_user_lock_code_output_unref:
 * @self: a #QmiMessageDmsSetUserLockCodeOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_user_lock_code_output_unref (QmiMessageDmsSetUserLockCodeOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetUserLockCodeOutput, self);
    }
}

static gboolean
qmi_message_dms_set_user_lock_code_input_info_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;
    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Info' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Info' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_user_lock_code_input_info_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_USER_LOCK_CODE_INPUT_TLV_INFO,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_user_lock_code_input_info_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " old_code = '");

        {
            gchar tmp[5];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                4,
                &tmp[0]);
            tmp[4] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " new_code = '");

        {
            gchar tmp[5];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                4,
                &tmp[0]);
            tmp[4] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Info' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_user_lock_code_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_user_lock_code_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_user_lock_code_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_USER_LOCK_CODE_INPUT_TLV_INFO:
            tlv_type_str = "Info";
            translated_value = qmi_message_dms_set_user_lock_code_input_info_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_USER_LOCK_CODE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_user_lock_code_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set User Lock Code\" (0x0036)\n",
                            line_prefix);

    {
        struct message_set_user_lock_code_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_user_lock_code_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsSetUserLockCodeOutput *
__qmi_message_dms_set_user_lock_code_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsSetUserLockCodeOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_SET_USER_LOCK_CODE, NULL);

    self = g_slice_new0 (QmiMessageDmsSetUserLockCodeOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_SET_USER_LOCK_CODE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_set_user_lock_code_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Read User Data */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_read_user_data_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_READ_USER_DATA);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsReadUserDataOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* User Data */
    gboolean arg_user_data_set;
    GArray *arg_user_data;
};

#define QMI_MESSAGE_DMS_READ_USER_DATA_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_READ_USER_DATA_OUTPUT_TLV_USER_DATA 0x01

/**
 * qmi_message_dms_read_user_data_output_get_result:
 * @self: a QmiMessageDmsReadUserDataOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_read_user_data_output_get_result (
    QmiMessageDmsReadUserDataOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_read_user_data_output_get_user_data:
 * @self: a #QmiMessageDmsReadUserDataOutput.
 * @user_data: a placeholder for the output #GArray of #guint8 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'User Data' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_read_user_data_output_get_user_data (
    QmiMessageDmsReadUserDataOutput *self,
    GArray **user_data,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_user_data_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'User Data' was not found in the message");
        return FALSE;
    }

    if (user_data)
        *user_data = self->arg_user_data;

    return TRUE;
}

GType
qmi_message_dms_read_user_data_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsReadUserDataOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_read_user_data_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_read_user_data_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_read_user_data_output_ref:
 * @self: a #QmiMessageDmsReadUserDataOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsReadUserDataOutput *
qmi_message_dms_read_user_data_output_ref (QmiMessageDmsReadUserDataOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_read_user_data_output_unref:
 * @self: a #QmiMessageDmsReadUserDataOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_read_user_data_output_unref (QmiMessageDmsReadUserDataOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_user_data)
            g_array_unref (self->arg_user_data);
        g_slice_free (QmiMessageDmsReadUserDataOutput, self);
    }
}

static gboolean
qmi_message_dms_read_user_data_output_user_data_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint user_data_i;
        guint16 user_data_n_items;
        const guint8 *user_data_aux_buffer = &buffer[expected_len];
        guint16 user_data_aux_buffer_len = buffer_len - expected_len;

        expected_len += 2;

        /* Read the guint16 variable from the buffer */
        qmi_utils_read_guint16_from_buffer (
            &user_data_aux_buffer,
            &user_data_aux_buffer_len,
            QMI_ENDIAN_LITTLE,
            &(user_data_n_items));
        for (user_data_i = 0; user_data_i < user_data_n_items; user_data_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'User Data' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'User Data' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_read_user_data_output_user_data_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_READ_USER_DATA_OUTPUT_TLV_USER_DATA,
                                      &buffer_len);
    if (buffer && qmi_message_dms_read_user_data_output_user_data_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint user_data_i;
            guint16 user_data_n_items;

            /* Read number of items in the array */
            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(user_data_n_items));

            g_string_append (printable, "{");

            for (user_data_i = 0; user_data_i < user_data_n_items; user_data_i++) {
                g_string_append_printf (printable, " [%u] = '", user_data_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%u", (guint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'User Data' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_read_user_data_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_read_user_data_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_read_user_data_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_READ_USER_DATA_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_READ_USER_DATA_OUTPUT_TLV_USER_DATA:
            tlv_type_str = "User Data";
            translated_value = qmi_message_dms_read_user_data_output_user_data_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_read_user_data_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Read User Data\" (0x0037)\n",
                            line_prefix);

    {
        struct message_read_user_data_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_read_user_data_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsReadUserDataOutput *
__qmi_message_dms_read_user_data_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsReadUserDataOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_READ_USER_DATA, NULL);

    self = g_slice_new0 (QmiMessageDmsReadUserDataOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_READ_USER_DATA_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_read_user_data_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_READ_USER_DATA_OUTPUT_TLV_USER_DATA,
                                              &buffer_len);
            if (buffer && qmi_message_dms_read_user_data_output_user_data_validate (buffer, buffer_len)) {
                self->arg_user_data_set = TRUE;

                {
                    guint user_data_i;
                    guint16 user_data_n_items;

                    /* Read number of items in the array */
                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &(user_data_n_items));

                    self->arg_user_data = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (guint8),
                        (guint)user_data_n_items);

                    for (user_data_i = 0; user_data_i < user_data_n_items; user_data_i++) {
                        guint8 user_data_aux;

                        /* Read the guint8 variable from the buffer */
                        qmi_utils_read_guint8_from_buffer (
                            &buffer,
                            &buffer_len,
                            &(user_data_aux));
                        g_array_insert_val (self->arg_user_data, user_data_i, user_data_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'User Data' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the User Data TLV: Not found");
                qmi_message_dms_read_user_data_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Write User Data */


/* --- Input -- */

struct _QmiMessageDmsWriteUserDataInput {
    volatile gint ref_count;

    /* User Data */
    gboolean arg_user_data_set;
    GArray *arg_user_data;
};

#define QMI_MESSAGE_DMS_WRITE_USER_DATA_INPUT_TLV_USER_DATA 0x01

/**
 * qmi_message_dms_write_user_data_input_get_user_data:
 * @self: a #QmiMessageDmsWriteUserDataInput.
 * @user_data: a placeholder for the output #GArray of #guint8 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'User Data' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_write_user_data_input_get_user_data (
    QmiMessageDmsWriteUserDataInput *self,
    GArray **user_data,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_user_data_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'User Data' was not found in the message");
        return FALSE;
    }

    if (user_data)
        *user_data = self->arg_user_data;

    return TRUE;
}

/**
 * qmi_message_dms_write_user_data_input_set_user_data:
 * @self: a #QmiMessageDmsWriteUserDataInput.
 * @user_data: a #GArray of #guint8 elements. A new reference to @user_data will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'User Data' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_write_user_data_input_set_user_data (
    QmiMessageDmsWriteUserDataInput *self,
    GArray *user_data,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_user_data)
        g_array_unref (self->arg_user_data);
    self->arg_user_data = g_array_ref (user_data);
    self->arg_user_data_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_write_user_data_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsWriteUserDataInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_write_user_data_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_write_user_data_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_write_user_data_input_ref:
 * @self: a #QmiMessageDmsWriteUserDataInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsWriteUserDataInput *
qmi_message_dms_write_user_data_input_ref (QmiMessageDmsWriteUserDataInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_write_user_data_input_unref:
 * @self: a #QmiMessageDmsWriteUserDataInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_write_user_data_input_unref (QmiMessageDmsWriteUserDataInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_user_data)
            g_array_unref (self->arg_user_data);
        g_slice_free (QmiMessageDmsWriteUserDataInput, self);
    }
}

/**
 * qmi_message_dms_write_user_data_input_new:
 *
 * Allocates a new #QmiMessageDmsWriteUserDataInput.
 *
 * Returns: the newly created #QmiMessageDmsWriteUserDataInput. The returned value should be freed with qmi_message_dms_write_user_data_input_unref().
 */
QmiMessageDmsWriteUserDataInput *
qmi_message_dms_write_user_data_input_new (void)
{
    QmiMessageDmsWriteUserDataInput *self;

    self = g_slice_new0 (QmiMessageDmsWriteUserDataInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_write_user_data_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsWriteUserDataInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_WRITE_USER_DATA);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Write User Data' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'User Data' TLV */
    if (input->arg_user_data_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint user_data_i;
            guint16 user_data_n_items;

            /* Write the number of items in the array first */
            user_data_n_items = (guint16) input->arg_user_data->len;
            /* Write the guint16 variable to the buffer */
            qmi_utils_write_guint16_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(user_data_n_items));

            for (user_data_i = 0; user_data_i < input->arg_user_data->len; user_data_i++) {
                /* Write the guint8 variable to the buffer */
                qmi_utils_write_guint8_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    &(g_array_index (input->arg_user_data, guint8,user_data_i)));
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_WRITE_USER_DATA_INPUT_TLV_USER_DATA,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the User Data TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'User Data' in message 'Write User Data'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsWriteUserDataOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_WRITE_USER_DATA_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_write_user_data_output_get_result:
 * @self: a QmiMessageDmsWriteUserDataOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_write_user_data_output_get_result (
    QmiMessageDmsWriteUserDataOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_write_user_data_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsWriteUserDataOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_write_user_data_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_write_user_data_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_write_user_data_output_ref:
 * @self: a #QmiMessageDmsWriteUserDataOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsWriteUserDataOutput *
qmi_message_dms_write_user_data_output_ref (QmiMessageDmsWriteUserDataOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_write_user_data_output_unref:
 * @self: a #QmiMessageDmsWriteUserDataOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_write_user_data_output_unref (QmiMessageDmsWriteUserDataOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsWriteUserDataOutput, self);
    }
}

static gboolean
qmi_message_dms_write_user_data_input_user_data_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint user_data_i;
        guint16 user_data_n_items;
        const guint8 *user_data_aux_buffer = &buffer[expected_len];
        guint16 user_data_aux_buffer_len = buffer_len - expected_len;

        expected_len += 2;

        /* Read the guint16 variable from the buffer */
        qmi_utils_read_guint16_from_buffer (
            &user_data_aux_buffer,
            &user_data_aux_buffer_len,
            QMI_ENDIAN_LITTLE,
            &(user_data_n_items));
        for (user_data_i = 0; user_data_i < user_data_n_items; user_data_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'User Data' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'User Data' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_write_user_data_input_user_data_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_WRITE_USER_DATA_INPUT_TLV_USER_DATA,
                                      &buffer_len);
    if (buffer && qmi_message_dms_write_user_data_input_user_data_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint user_data_i;
            guint16 user_data_n_items;

            /* Read number of items in the array */
            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(user_data_n_items));

            g_string_append (printable, "{");

            for (user_data_i = 0; user_data_i < user_data_n_items; user_data_i++) {
                g_string_append_printf (printable, " [%u] = '", user_data_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%u", (guint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'User Data' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_write_user_data_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_write_user_data_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_write_user_data_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_WRITE_USER_DATA_INPUT_TLV_USER_DATA:
            tlv_type_str = "User Data";
            translated_value = qmi_message_dms_write_user_data_input_user_data_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_WRITE_USER_DATA_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_write_user_data_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Write User Data\" (0x0038)\n",
                            line_prefix);

    {
        struct message_write_user_data_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_write_user_data_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsWriteUserDataOutput *
__qmi_message_dms_write_user_data_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsWriteUserDataOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_WRITE_USER_DATA, NULL);

    self = g_slice_new0 (QmiMessageDmsWriteUserDataOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_WRITE_USER_DATA_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_write_user_data_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Read ERI File */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_read_eri_file_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_READ_ERI_FILE);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsReadEriFileOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* ERI File */
    gboolean arg_eri_file_set;
    GArray *arg_eri_file;
};

#define QMI_MESSAGE_DMS_READ_ERI_FILE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_READ_ERI_FILE_OUTPUT_TLV_ERI_FILE 0x01

/**
 * qmi_message_dms_read_eri_file_output_get_result:
 * @self: a QmiMessageDmsReadEriFileOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_read_eri_file_output_get_result (
    QmiMessageDmsReadEriFileOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_read_eri_file_output_get_eri_file:
 * @self: a #QmiMessageDmsReadEriFileOutput.
 * @eri_file: a placeholder for the output #GArray of #guint8 elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'ERI File' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_read_eri_file_output_get_eri_file (
    QmiMessageDmsReadEriFileOutput *self,
    GArray **eri_file,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_eri_file_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ERI File' was not found in the message");
        return FALSE;
    }

    if (eri_file)
        *eri_file = self->arg_eri_file;

    return TRUE;
}

GType
qmi_message_dms_read_eri_file_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsReadEriFileOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_read_eri_file_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_read_eri_file_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_read_eri_file_output_ref:
 * @self: a #QmiMessageDmsReadEriFileOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsReadEriFileOutput *
qmi_message_dms_read_eri_file_output_ref (QmiMessageDmsReadEriFileOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_read_eri_file_output_unref:
 * @self: a #QmiMessageDmsReadEriFileOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_read_eri_file_output_unref (QmiMessageDmsReadEriFileOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_eri_file)
            g_array_unref (self->arg_eri_file);
        g_slice_free (QmiMessageDmsReadEriFileOutput, self);
    }
}

static gboolean
qmi_message_dms_read_eri_file_output_eri_file_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint eri_file_i;
        guint16 eri_file_n_items;
        const guint8 *eri_file_aux_buffer = &buffer[expected_len];
        guint16 eri_file_aux_buffer_len = buffer_len - expected_len;

        expected_len += 2;

        /* Read the guint16 variable from the buffer */
        qmi_utils_read_guint16_from_buffer (
            &eri_file_aux_buffer,
            &eri_file_aux_buffer_len,
            QMI_ENDIAN_LITTLE,
            &(eri_file_n_items));
        for (eri_file_i = 0; eri_file_i < eri_file_n_items; eri_file_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'ERI File' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'ERI File' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_read_eri_file_output_eri_file_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_READ_ERI_FILE_OUTPUT_TLV_ERI_FILE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_read_eri_file_output_eri_file_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint eri_file_i;
            guint16 eri_file_n_items;

            /* Read number of items in the array */
            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &(eri_file_n_items));

            g_string_append (printable, "{");

            for (eri_file_i = 0; eri_file_i < eri_file_n_items; eri_file_i++) {
                g_string_append_printf (printable, " [%u] = '", eri_file_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%u", (guint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'ERI File' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_read_eri_file_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_read_eri_file_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_read_eri_file_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_READ_ERI_FILE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_READ_ERI_FILE_OUTPUT_TLV_ERI_FILE:
            tlv_type_str = "ERI File";
            translated_value = qmi_message_dms_read_eri_file_output_eri_file_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_read_eri_file_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Read ERI File\" (0x0039)\n",
                            line_prefix);

    {
        struct message_read_eri_file_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_read_eri_file_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsReadEriFileOutput *
__qmi_message_dms_read_eri_file_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsReadEriFileOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_READ_ERI_FILE, NULL);

    self = g_slice_new0 (QmiMessageDmsReadEriFileOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_READ_ERI_FILE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_read_eri_file_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_READ_ERI_FILE_OUTPUT_TLV_ERI_FILE,
                                              &buffer_len);
            if (buffer && qmi_message_dms_read_eri_file_output_eri_file_validate (buffer, buffer_len)) {
                self->arg_eri_file_set = TRUE;

                {
                    guint eri_file_i;
                    guint16 eri_file_n_items;

                    /* Read number of items in the array */
                    /* Read the guint16 variable from the buffer */
                    qmi_utils_read_guint16_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &(eri_file_n_items));

                    self->arg_eri_file = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (guint8),
                        (guint)eri_file_n_items);

                    for (eri_file_i = 0; eri_file_i < eri_file_n_items; eri_file_i++) {
                        guint8 eri_file_aux;

                        /* Read the guint8 variable from the buffer */
                        qmi_utils_read_guint8_from_buffer (
                            &buffer,
                            &buffer_len,
                            &(eri_file_aux));
                        g_array_insert_val (self->arg_eri_file, eri_file_i, eri_file_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'ERI File' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the ERI File TLV: Not found");
                qmi_message_dms_read_eri_file_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Restore Factory Defaults */


/* --- Input -- */

struct _QmiMessageDmsRestoreFactoryDefaultsInput {
    volatile gint ref_count;

    /* Service Programming Code */
    gboolean arg_service_programming_code_set;
    gchar arg_service_programming_code[7];
};

#define QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS_INPUT_TLV_SERVICE_PROGRAMMING_CODE 0x01

/**
 * qmi_message_dms_restore_factory_defaults_input_get_service_programming_code:
 * @self: a #QmiMessageDmsRestoreFactoryDefaultsInput.
 * @service_programming_code: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Service Programming Code' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_restore_factory_defaults_input_get_service_programming_code (
    QmiMessageDmsRestoreFactoryDefaultsInput *self,
    const gchar **service_programming_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_service_programming_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Service Programming Code' was not found in the message");
        return FALSE;
    }

    if (service_programming_code)
        *service_programming_code = self->arg_service_programming_code;

    return TRUE;
}

/**
 * qmi_message_dms_restore_factory_defaults_input_set_service_programming_code:
 * @self: a #QmiMessageDmsRestoreFactoryDefaultsInput.
 * @service_programming_code: a constant string of exactly 6 characters.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Service Programming Code' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_restore_factory_defaults_input_set_service_programming_code (
    QmiMessageDmsRestoreFactoryDefaultsInput *self,
    const gchar *service_programming_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!service_programming_code || strlen (service_programming_code) != 6) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'service_programming_code' must be 6 characters long");
        return FALSE;
    }
    memcpy (self->arg_service_programming_code, service_programming_code, 6);
    self->arg_service_programming_code[6] = '\0';
    self->arg_service_programming_code_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_restore_factory_defaults_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsRestoreFactoryDefaultsInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_restore_factory_defaults_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_restore_factory_defaults_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_restore_factory_defaults_input_ref:
 * @self: a #QmiMessageDmsRestoreFactoryDefaultsInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsRestoreFactoryDefaultsInput *
qmi_message_dms_restore_factory_defaults_input_ref (QmiMessageDmsRestoreFactoryDefaultsInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_restore_factory_defaults_input_unref:
 * @self: a #QmiMessageDmsRestoreFactoryDefaultsInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_restore_factory_defaults_input_unref (QmiMessageDmsRestoreFactoryDefaultsInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsRestoreFactoryDefaultsInput, self);
    }
}

/**
 * qmi_message_dms_restore_factory_defaults_input_new:
 *
 * Allocates a new #QmiMessageDmsRestoreFactoryDefaultsInput.
 *
 * Returns: the newly created #QmiMessageDmsRestoreFactoryDefaultsInput. The returned value should be freed with qmi_message_dms_restore_factory_defaults_input_unref().
 */
QmiMessageDmsRestoreFactoryDefaultsInput *
qmi_message_dms_restore_factory_defaults_input_new (void)
{
    QmiMessageDmsRestoreFactoryDefaultsInput *self;

    self = g_slice_new0 (QmiMessageDmsRestoreFactoryDefaultsInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_restore_factory_defaults_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsRestoreFactoryDefaultsInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Restore Factory Defaults' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Service Programming Code' TLV */
    if (input->arg_service_programming_code_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the fixed-size string variable to the buffer */
        qmi_utils_write_fixed_size_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            6,
            input->arg_service_programming_code);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS_INPUT_TLV_SERVICE_PROGRAMMING_CODE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Service Programming Code TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Service Programming Code' in message 'Restore Factory Defaults'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsRestoreFactoryDefaultsOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_restore_factory_defaults_output_get_result:
 * @self: a QmiMessageDmsRestoreFactoryDefaultsOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_restore_factory_defaults_output_get_result (
    QmiMessageDmsRestoreFactoryDefaultsOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_restore_factory_defaults_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsRestoreFactoryDefaultsOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_restore_factory_defaults_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_restore_factory_defaults_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_restore_factory_defaults_output_ref:
 * @self: a #QmiMessageDmsRestoreFactoryDefaultsOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsRestoreFactoryDefaultsOutput *
qmi_message_dms_restore_factory_defaults_output_ref (QmiMessageDmsRestoreFactoryDefaultsOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_restore_factory_defaults_output_unref:
 * @self: a #QmiMessageDmsRestoreFactoryDefaultsOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_restore_factory_defaults_output_unref (QmiMessageDmsRestoreFactoryDefaultsOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsRestoreFactoryDefaultsOutput, self);
    }
}

static gboolean
qmi_message_dms_restore_factory_defaults_input_service_programming_code_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 6;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Service Programming Code' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Service Programming Code' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_restore_factory_defaults_input_service_programming_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS_INPUT_TLV_SERVICE_PROGRAMMING_CODE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_restore_factory_defaults_input_service_programming_code_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar tmp[7];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                6,
                &tmp[0]);
            tmp[6] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Service Programming Code' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_restore_factory_defaults_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_restore_factory_defaults_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_restore_factory_defaults_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS_INPUT_TLV_SERVICE_PROGRAMMING_CODE:
            tlv_type_str = "Service Programming Code";
            translated_value = qmi_message_dms_restore_factory_defaults_input_service_programming_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_restore_factory_defaults_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Restore Factory Defaults\" (0x003A)\n",
                            line_prefix);

    {
        struct message_restore_factory_defaults_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_restore_factory_defaults_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsRestoreFactoryDefaultsOutput *
__qmi_message_dms_restore_factory_defaults_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsRestoreFactoryDefaultsOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS, NULL);

    self = g_slice_new0 (QmiMessageDmsRestoreFactoryDefaultsOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_restore_factory_defaults_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Validate Service Programming Code */


/* --- Input -- */

struct _QmiMessageDmsValidateServiceProgrammingCodeInput {
    volatile gint ref_count;

    /* Service Programming Code */
    gboolean arg_service_programming_code_set;
    gchar arg_service_programming_code[7];
};

#define QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE_INPUT_TLV_SERVICE_PROGRAMMING_CODE 0x01

/**
 * qmi_message_dms_validate_service_programming_code_input_get_service_programming_code:
 * @self: a #QmiMessageDmsValidateServiceProgrammingCodeInput.
 * @service_programming_code: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Service Programming Code' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_validate_service_programming_code_input_get_service_programming_code (
    QmiMessageDmsValidateServiceProgrammingCodeInput *self,
    const gchar **service_programming_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_service_programming_code_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Service Programming Code' was not found in the message");
        return FALSE;
    }

    if (service_programming_code)
        *service_programming_code = self->arg_service_programming_code;

    return TRUE;
}

/**
 * qmi_message_dms_validate_service_programming_code_input_set_service_programming_code:
 * @self: a #QmiMessageDmsValidateServiceProgrammingCodeInput.
 * @service_programming_code: a constant string of exactly 6 characters.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Service Programming Code' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_validate_service_programming_code_input_set_service_programming_code (
    QmiMessageDmsValidateServiceProgrammingCodeInput *self,
    const gchar *service_programming_code,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!service_programming_code || strlen (service_programming_code) != 6) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'service_programming_code' must be 6 characters long");
        return FALSE;
    }
    memcpy (self->arg_service_programming_code, service_programming_code, 6);
    self->arg_service_programming_code[6] = '\0';
    self->arg_service_programming_code_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_validate_service_programming_code_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsValidateServiceProgrammingCodeInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_validate_service_programming_code_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_validate_service_programming_code_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_validate_service_programming_code_input_ref:
 * @self: a #QmiMessageDmsValidateServiceProgrammingCodeInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsValidateServiceProgrammingCodeInput *
qmi_message_dms_validate_service_programming_code_input_ref (QmiMessageDmsValidateServiceProgrammingCodeInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_validate_service_programming_code_input_unref:
 * @self: a #QmiMessageDmsValidateServiceProgrammingCodeInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_validate_service_programming_code_input_unref (QmiMessageDmsValidateServiceProgrammingCodeInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsValidateServiceProgrammingCodeInput, self);
    }
}

/**
 * qmi_message_dms_validate_service_programming_code_input_new:
 *
 * Allocates a new #QmiMessageDmsValidateServiceProgrammingCodeInput.
 *
 * Returns: the newly created #QmiMessageDmsValidateServiceProgrammingCodeInput. The returned value should be freed with qmi_message_dms_validate_service_programming_code_input_unref().
 */
QmiMessageDmsValidateServiceProgrammingCodeInput *
qmi_message_dms_validate_service_programming_code_input_new (void)
{
    QmiMessageDmsValidateServiceProgrammingCodeInput *self;

    self = g_slice_new0 (QmiMessageDmsValidateServiceProgrammingCodeInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_validate_service_programming_code_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsValidateServiceProgrammingCodeInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Validate Service Programming Code' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Service Programming Code' TLV */
    if (input->arg_service_programming_code_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the fixed-size string variable to the buffer */
        qmi_utils_write_fixed_size_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            6,
            input->arg_service_programming_code);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE_INPUT_TLV_SERVICE_PROGRAMMING_CODE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Service Programming Code TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Service Programming Code' in message 'Validate Service Programming Code'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsValidateServiceProgrammingCodeOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_validate_service_programming_code_output_get_result:
 * @self: a QmiMessageDmsValidateServiceProgrammingCodeOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_validate_service_programming_code_output_get_result (
    QmiMessageDmsValidateServiceProgrammingCodeOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_validate_service_programming_code_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsValidateServiceProgrammingCodeOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_validate_service_programming_code_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_validate_service_programming_code_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_validate_service_programming_code_output_ref:
 * @self: a #QmiMessageDmsValidateServiceProgrammingCodeOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsValidateServiceProgrammingCodeOutput *
qmi_message_dms_validate_service_programming_code_output_ref (QmiMessageDmsValidateServiceProgrammingCodeOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_validate_service_programming_code_output_unref:
 * @self: a #QmiMessageDmsValidateServiceProgrammingCodeOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_validate_service_programming_code_output_unref (QmiMessageDmsValidateServiceProgrammingCodeOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsValidateServiceProgrammingCodeOutput, self);
    }
}

static gboolean
qmi_message_dms_validate_service_programming_code_input_service_programming_code_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 6;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Service Programming Code' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Service Programming Code' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_validate_service_programming_code_input_service_programming_code_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE_INPUT_TLV_SERVICE_PROGRAMMING_CODE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_validate_service_programming_code_input_service_programming_code_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar tmp[7];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                6,
                &tmp[0]);
            tmp[6] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Service Programming Code' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_validate_service_programming_code_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_validate_service_programming_code_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_validate_service_programming_code_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE_INPUT_TLV_SERVICE_PROGRAMMING_CODE:
            tlv_type_str = "Service Programming Code";
            translated_value = qmi_message_dms_validate_service_programming_code_input_service_programming_code_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_validate_service_programming_code_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Validate Service Programming Code\" (0x003B)\n",
                            line_prefix);

    {
        struct message_validate_service_programming_code_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_validate_service_programming_code_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsValidateServiceProgrammingCodeOutput *
__qmi_message_dms_validate_service_programming_code_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsValidateServiceProgrammingCodeOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE, NULL);

    self = g_slice_new0 (QmiMessageDmsValidateServiceProgrammingCodeOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_validate_service_programming_code_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Get ICCID */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_uim_get_iccid_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_GET_ICCID);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimGetIccidOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* ICCID */
    gboolean arg_iccid_set;
    gchar *arg_iccid;
};

#define QMI_MESSAGE_DMS_UIM_GET_ICCID_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_GET_ICCID_OUTPUT_TLV_ICCID 0x01

/**
 * qmi_message_dms_uim_get_iccid_output_get_result:
 * @self: a QmiMessageDmsUimGetIccidOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_get_iccid_output_get_result (
    QmiMessageDmsUimGetIccidOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_get_iccid_output_get_iccid:
 * @self: a #QmiMessageDmsUimGetIccidOutput.
 * @iccid: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'ICCID' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_get_iccid_output_get_iccid (
    QmiMessageDmsUimGetIccidOutput *self,
    const gchar **iccid,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_iccid_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'ICCID' was not found in the message");
        return FALSE;
    }

    if (iccid)
        *iccid = self->arg_iccid;

    return TRUE;
}

GType
qmi_message_dms_uim_get_iccid_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimGetIccidOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_get_iccid_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_get_iccid_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_get_iccid_output_ref:
 * @self: a #QmiMessageDmsUimGetIccidOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimGetIccidOutput *
qmi_message_dms_uim_get_iccid_output_ref (QmiMessageDmsUimGetIccidOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_get_iccid_output_unref:
 * @self: a #QmiMessageDmsUimGetIccidOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_get_iccid_output_unref (QmiMessageDmsUimGetIccidOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_iccid);
        g_slice_free (QmiMessageDmsUimGetIccidOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_get_iccid_output_iccid_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'ICCID' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'ICCID' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_get_iccid_output_iccid_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_GET_ICCID_OUTPUT_TLV_ICCID,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_get_iccid_output_iccid_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'ICCID' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_get_iccid_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_get_iccid_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_get_iccid_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_GET_ICCID_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_GET_ICCID_OUTPUT_TLV_ICCID:
            tlv_type_str = "ICCID";
            translated_value = qmi_message_dms_uim_get_iccid_output_iccid_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_get_iccid_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Get ICCID\" (0x003C)\n",
                            line_prefix);

    {
        struct message_uim_get_iccid_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_get_iccid_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimGetIccidOutput *
__qmi_message_dms_uim_get_iccid_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimGetIccidOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_GET_ICCID, NULL);

    self = g_slice_new0 (QmiMessageDmsUimGetIccidOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_ICCID_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_get_iccid_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_ICCID_OUTPUT_TLV_ICCID,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_get_iccid_output_iccid_validate (buffer, buffer_len)) {
                self->arg_iccid_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_iccid));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'ICCID' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the ICCID TLV: Not found");
                qmi_message_dms_uim_get_iccid_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Get CK Status */


/* --- Input -- */

struct _QmiMessageDmsUimGetCkStatusInput {
    volatile gint ref_count;

    /* Facility */
    gboolean arg_facility_set;
    guint8 arg_facility;
};

#define QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_INPUT_TLV_FACILITY 0x01

/**
 * qmi_message_dms_uim_get_ck_status_input_get_facility:
 * @self: a #QmiMessageDmsUimGetCkStatusInput.
 * @facility: a placeholder for the output #QmiDmsUimFacility, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Facility' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_get_ck_status_input_get_facility (
    QmiMessageDmsUimGetCkStatusInput *self,
    QmiDmsUimFacility *facility,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_facility_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Facility' was not found in the message");
        return FALSE;
    }

    if (facility)
        *facility = (QmiDmsUimFacility)(self->arg_facility);

    return TRUE;
}

/**
 * qmi_message_dms_uim_get_ck_status_input_set_facility:
 * @self: a #QmiMessageDmsUimGetCkStatusInput.
 * @facility: a #QmiDmsUimFacility.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Facility' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_get_ck_status_input_set_facility (
    QmiMessageDmsUimGetCkStatusInput *self,
    QmiDmsUimFacility facility,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_facility = (guint8)(facility);
    self->arg_facility_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_uim_get_ck_status_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimGetCkStatusInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_get_ck_status_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_get_ck_status_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_get_ck_status_input_ref:
 * @self: a #QmiMessageDmsUimGetCkStatusInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimGetCkStatusInput *
qmi_message_dms_uim_get_ck_status_input_ref (QmiMessageDmsUimGetCkStatusInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_get_ck_status_input_unref:
 * @self: a #QmiMessageDmsUimGetCkStatusInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_get_ck_status_input_unref (QmiMessageDmsUimGetCkStatusInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsUimGetCkStatusInput, self);
    }
}

/**
 * qmi_message_dms_uim_get_ck_status_input_new:
 *
 * Allocates a new #QmiMessageDmsUimGetCkStatusInput.
 *
 * Returns: the newly created #QmiMessageDmsUimGetCkStatusInput. The returned value should be freed with qmi_message_dms_uim_get_ck_status_input_unref().
 */
QmiMessageDmsUimGetCkStatusInput *
qmi_message_dms_uim_get_ck_status_input_new (void)
{
    QmiMessageDmsUimGetCkStatusInput *self;

    self = g_slice_new0 (QmiMessageDmsUimGetCkStatusInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_uim_get_ck_status_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsUimGetCkStatusInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_GET_CK_STATUS);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'UIM Get CK Status' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Facility' TLV */
    if (input->arg_facility_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_facility;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_INPUT_TLV_FACILITY,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Facility TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Facility' in message 'UIM Get CK Status'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimGetCkStatusOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* CK Status */
    gboolean arg_ck_status_set;
    guint8 arg_ck_status_facility_state;
    guint8 arg_ck_status_verify_retries_left;
    guint8 arg_ck_status_unblock_retries_left;

    /* Operation Blocking Facility */
    gboolean arg_operation_blocking_facility_set;
    guint8 arg_operation_blocking_facility;
};

#define QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_CK_STATUS 0x01
#define QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_OPERATION_BLOCKING_FACILITY 0x10

/**
 * qmi_message_dms_uim_get_ck_status_output_get_result:
 * @self: a QmiMessageDmsUimGetCkStatusOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_get_ck_status_output_get_result (
    QmiMessageDmsUimGetCkStatusOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_get_ck_status_output_get_ck_status:
 * @self: a #QmiMessageDmsUimGetCkStatusOutput.
 * @ck_status_facility_state: a placeholder for the output #QmiDmsUimFacilityState, or %NULL if not required.
 * @ck_status_verify_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @ck_status_unblock_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'CK Status' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_get_ck_status_output_get_ck_status (
    QmiMessageDmsUimGetCkStatusOutput *self,
    QmiDmsUimFacilityState *ck_status_facility_state,
    guint8 *ck_status_verify_retries_left,
    guint8 *ck_status_unblock_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_ck_status_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'CK Status' was not found in the message");
        return FALSE;
    }

    if (ck_status_facility_state)
        *ck_status_facility_state = (QmiDmsUimFacilityState)(self->arg_ck_status_facility_state);
    if (ck_status_verify_retries_left)
        *ck_status_verify_retries_left = self->arg_ck_status_verify_retries_left;
    if (ck_status_unblock_retries_left)
        *ck_status_unblock_retries_left = self->arg_ck_status_unblock_retries_left;

    return TRUE;
}

/**
 * qmi_message_dms_uim_get_ck_status_output_get_operation_blocking_facility:
 * @self: a #QmiMessageDmsUimGetCkStatusOutput.
 * @operation_blocking_facility: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Operation Blocking Facility' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_get_ck_status_output_get_operation_blocking_facility (
    QmiMessageDmsUimGetCkStatusOutput *self,
    gboolean *operation_blocking_facility,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_operation_blocking_facility_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Operation Blocking Facility' was not found in the message");
        return FALSE;
    }

    if (operation_blocking_facility)
        *operation_blocking_facility = (gboolean)(self->arg_operation_blocking_facility);

    return TRUE;
}

GType
qmi_message_dms_uim_get_ck_status_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimGetCkStatusOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_get_ck_status_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_get_ck_status_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_get_ck_status_output_ref:
 * @self: a #QmiMessageDmsUimGetCkStatusOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimGetCkStatusOutput *
qmi_message_dms_uim_get_ck_status_output_ref (QmiMessageDmsUimGetCkStatusOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_get_ck_status_output_unref:
 * @self: a #QmiMessageDmsUimGetCkStatusOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_get_ck_status_output_unref (QmiMessageDmsUimGetCkStatusOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsUimGetCkStatusOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_get_ck_status_input_facility_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Facility' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Facility' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_get_ck_status_input_facility_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_INPUT_TLV_FACILITY,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_get_ck_status_input_facility_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_FACILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_facility_get_string ((QmiDmsUimFacility)tmp));
#elif defined  __QMI_DMS_UIM_FACILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_facility_build_string_from_mask ((QmiDmsUimFacility)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimFacility
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Facility' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_uim_get_ck_status_output_ck_status_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'CK Status' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'CK Status' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_get_ck_status_output_ck_status_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_CK_STATUS,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_get_ck_status_output_ck_status_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " facility_state = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_FACILITY_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_facility_state_get_string ((QmiDmsUimFacilityState)tmp));
#elif defined  __QMI_DMS_UIM_FACILITY_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_facility_state_build_string_from_mask ((QmiDmsUimFacilityState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimFacilityState
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " verify_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unblock_retries_left = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'CK Status' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_uim_get_ck_status_output_operation_blocking_facility_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Operation Blocking Facility' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Operation Blocking Facility' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_get_ck_status_output_operation_blocking_facility_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_OPERATION_BLOCKING_FACILITY,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_get_ck_status_output_operation_blocking_facility_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Operation Blocking Facility' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_get_ck_status_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_get_ck_status_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_get_ck_status_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_INPUT_TLV_FACILITY:
            tlv_type_str = "Facility";
            translated_value = qmi_message_dms_uim_get_ck_status_input_facility_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_CK_STATUS:
            tlv_type_str = "CK Status";
            translated_value = qmi_message_dms_uim_get_ck_status_output_ck_status_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_OPERATION_BLOCKING_FACILITY:
            tlv_type_str = "Operation Blocking Facility";
            translated_value = qmi_message_dms_uim_get_ck_status_output_operation_blocking_facility_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_get_ck_status_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Get CK Status\" (0x0040)\n",
                            line_prefix);

    {
        struct message_uim_get_ck_status_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_get_ck_status_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimGetCkStatusOutput *
__qmi_message_dms_uim_get_ck_status_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimGetCkStatusOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_GET_CK_STATUS, NULL);

    self = g_slice_new0 (QmiMessageDmsUimGetCkStatusOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_get_ck_status_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_CK_STATUS,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_get_ck_status_output_ck_status_validate (buffer, buffer_len)) {
                self->arg_ck_status_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_ck_status_facility_state = (QmiDmsUimFacilityState)tmp;
                }
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_ck_status_verify_retries_left));
                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_ck_status_unblock_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'CK Status' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the CK Status TLV: Not found");
                qmi_message_dms_uim_get_ck_status_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_CK_STATUS_OUTPUT_TLV_OPERATION_BLOCKING_FACILITY,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_get_ck_status_output_operation_blocking_facility_validate (buffer, buffer_len)) {
                self->arg_operation_blocking_facility_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_operation_blocking_facility = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Operation Blocking Facility' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Set CK Protection */


/* --- Input -- */

struct _QmiMessageDmsUimSetCkProtectionInput {
    volatile gint ref_count;

    /* Facility */
    gboolean arg_facility_set;
    guint8 arg_facility_facility;
    guint8 arg_facility_facility_state;
    gchar *arg_facility_facility_depersonalization_control_key;
};

#define QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_INPUT_TLV_FACILITY 0x01

/**
 * qmi_message_dms_uim_set_ck_protection_input_get_facility:
 * @self: a #QmiMessageDmsUimSetCkProtectionInput.
 * @facility_facility: a placeholder for the output #QmiDmsUimFacility, or %NULL if not required.
 * @facility_facility_state: a placeholder for the output #QmiDmsUimFacilityState, or %NULL if not required.
 * @facility_facility_depersonalization_control_key: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Facility' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_set_ck_protection_input_get_facility (
    QmiMessageDmsUimSetCkProtectionInput *self,
    QmiDmsUimFacility *facility_facility,
    QmiDmsUimFacilityState *facility_facility_state,
    const gchar **facility_facility_depersonalization_control_key,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_facility_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Facility' was not found in the message");
        return FALSE;
    }

    if (facility_facility)
        *facility_facility = (QmiDmsUimFacility)(self->arg_facility_facility);
    if (facility_facility_state)
        *facility_facility_state = (QmiDmsUimFacilityState)(self->arg_facility_facility_state);
    if (facility_facility_depersonalization_control_key)
        *facility_facility_depersonalization_control_key = self->arg_facility_facility_depersonalization_control_key;

    return TRUE;
}

/**
 * qmi_message_dms_uim_set_ck_protection_input_set_facility:
 * @self: a #QmiMessageDmsUimSetCkProtectionInput.
 * @facility_facility: a #QmiDmsUimFacility.
 * @facility_facility_state: a #QmiDmsUimFacilityState.
 * @facility_facility_depersonalization_control_key: a constant string.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Facility' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_set_ck_protection_input_set_facility (
    QmiMessageDmsUimSetCkProtectionInput *self,
    QmiDmsUimFacility facility_facility,
    QmiDmsUimFacilityState facility_facility_state,
    const gchar *facility_facility_depersonalization_control_key,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_facility_facility = (guint8)(facility_facility);
    self->arg_facility_facility_state = (guint8)(facility_facility_state);
    g_free (self->arg_facility_facility_depersonalization_control_key);
    self->arg_facility_facility_depersonalization_control_key = g_strdup (facility_facility_depersonalization_control_key ? facility_facility_depersonalization_control_key : "");
    self->arg_facility_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_uim_set_ck_protection_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimSetCkProtectionInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_set_ck_protection_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_set_ck_protection_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_set_ck_protection_input_ref:
 * @self: a #QmiMessageDmsUimSetCkProtectionInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimSetCkProtectionInput *
qmi_message_dms_uim_set_ck_protection_input_ref (QmiMessageDmsUimSetCkProtectionInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_set_ck_protection_input_unref:
 * @self: a #QmiMessageDmsUimSetCkProtectionInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_set_ck_protection_input_unref (QmiMessageDmsUimSetCkProtectionInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_facility_facility_depersonalization_control_key);
        g_slice_free (QmiMessageDmsUimSetCkProtectionInput, self);
    }
}

/**
 * qmi_message_dms_uim_set_ck_protection_input_new:
 *
 * Allocates a new #QmiMessageDmsUimSetCkProtectionInput.
 *
 * Returns: the newly created #QmiMessageDmsUimSetCkProtectionInput. The returned value should be freed with qmi_message_dms_uim_set_ck_protection_input_unref().
 */
QmiMessageDmsUimSetCkProtectionInput *
qmi_message_dms_uim_set_ck_protection_input_new (void)
{
    QmiMessageDmsUimSetCkProtectionInput *self;

    self = g_slice_new0 (QmiMessageDmsUimSetCkProtectionInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_uim_set_ck_protection_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsUimSetCkProtectionInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'UIM Set CK Protection' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Facility' TLV */
    if (input->arg_facility_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_facility_facility;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        {
            guint8 tmp;

            tmp = (guint8)input->arg_facility_facility_state;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_facility_facility_depersonalization_control_key);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_INPUT_TLV_FACILITY,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Facility TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Facility' in message 'UIM Set CK Protection'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimSetCkProtectionOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Verify Retries Left */
    gboolean arg_verify_retries_left_set;
    guint8 arg_verify_retries_left;
};

#define QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_OUTPUT_TLV_VERIFY_RETRIES_LEFT 0x10

/**
 * qmi_message_dms_uim_set_ck_protection_output_get_result:
 * @self: a QmiMessageDmsUimSetCkProtectionOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_set_ck_protection_output_get_result (
    QmiMessageDmsUimSetCkProtectionOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_set_ck_protection_output_get_verify_retries_left:
 * @self: a #QmiMessageDmsUimSetCkProtectionOutput.
 * @verify_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Verify Retries Left' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_set_ck_protection_output_get_verify_retries_left (
    QmiMessageDmsUimSetCkProtectionOutput *self,
    guint8 *verify_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_verify_retries_left_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Verify Retries Left' was not found in the message");
        return FALSE;
    }

    if (verify_retries_left)
        *verify_retries_left = self->arg_verify_retries_left;

    return TRUE;
}

GType
qmi_message_dms_uim_set_ck_protection_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimSetCkProtectionOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_set_ck_protection_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_set_ck_protection_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_set_ck_protection_output_ref:
 * @self: a #QmiMessageDmsUimSetCkProtectionOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimSetCkProtectionOutput *
qmi_message_dms_uim_set_ck_protection_output_ref (QmiMessageDmsUimSetCkProtectionOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_set_ck_protection_output_unref:
 * @self: a #QmiMessageDmsUimSetCkProtectionOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_set_ck_protection_output_unref (QmiMessageDmsUimSetCkProtectionOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsUimSetCkProtectionOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_set_ck_protection_input_facility_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    expected_len += 1;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Facility' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Facility' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_set_ck_protection_input_facility_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_INPUT_TLV_FACILITY,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_set_ck_protection_input_facility_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " facility = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_FACILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_facility_get_string ((QmiDmsUimFacility)tmp));
#elif defined  __QMI_DMS_UIM_FACILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_facility_build_string_from_mask ((QmiDmsUimFacility)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimFacility
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " facility_state = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_FACILITY_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_facility_state_get_string ((QmiDmsUimFacilityState)tmp));
#elif defined  __QMI_DMS_UIM_FACILITY_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_facility_state_build_string_from_mask ((QmiDmsUimFacilityState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimFacilityState
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " facility_depersonalization_control_key = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Facility' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_uim_set_ck_protection_output_verify_retries_left_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Verify Retries Left' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Verify Retries Left' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_set_ck_protection_output_verify_retries_left_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_OUTPUT_TLV_VERIFY_RETRIES_LEFT,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_set_ck_protection_output_verify_retries_left_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Verify Retries Left' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_set_ck_protection_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_set_ck_protection_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_set_ck_protection_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_INPUT_TLV_FACILITY:
            tlv_type_str = "Facility";
            translated_value = qmi_message_dms_uim_set_ck_protection_input_facility_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_OUTPUT_TLV_VERIFY_RETRIES_LEFT:
            tlv_type_str = "Verify Retries Left";
            translated_value = qmi_message_dms_uim_set_ck_protection_output_verify_retries_left_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_set_ck_protection_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Set CK Protection\" (0x0041)\n",
                            line_prefix);

    {
        struct message_uim_set_ck_protection_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_set_ck_protection_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimSetCkProtectionOutput *
__qmi_message_dms_uim_set_ck_protection_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimSetCkProtectionOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION, NULL);

    self = g_slice_new0 (QmiMessageDmsUimSetCkProtectionOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_set_ck_protection_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION_OUTPUT_TLV_VERIFY_RETRIES_LEFT,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_set_ck_protection_output_verify_retries_left_validate (buffer, buffer_len)) {
                self->arg_verify_retries_left_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_verify_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Verify Retries Left' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Unblock CK */


/* --- Input -- */

struct _QmiMessageDmsUimUnblockCkInput {
    volatile gint ref_count;

    /* Facility */
    gboolean arg_facility_set;
    guint8 arg_facility_facility;
    gchar *arg_facility_facility_control_key;
};

#define QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_INPUT_TLV_FACILITY 0x01

/**
 * qmi_message_dms_uim_unblock_ck_input_get_facility:
 * @self: a #QmiMessageDmsUimUnblockCkInput.
 * @facility_facility: a placeholder for the output #QmiDmsUimFacility, or %NULL if not required.
 * @facility_facility_control_key: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Facility' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_unblock_ck_input_get_facility (
    QmiMessageDmsUimUnblockCkInput *self,
    QmiDmsUimFacility *facility_facility,
    const gchar **facility_facility_control_key,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_facility_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Facility' was not found in the message");
        return FALSE;
    }

    if (facility_facility)
        *facility_facility = (QmiDmsUimFacility)(self->arg_facility_facility);
    if (facility_facility_control_key)
        *facility_facility_control_key = self->arg_facility_facility_control_key;

    return TRUE;
}

/**
 * qmi_message_dms_uim_unblock_ck_input_set_facility:
 * @self: a #QmiMessageDmsUimUnblockCkInput.
 * @facility_facility: a #QmiDmsUimFacility.
 * @facility_facility_control_key: a constant string.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Facility' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_unblock_ck_input_set_facility (
    QmiMessageDmsUimUnblockCkInput *self,
    QmiDmsUimFacility facility_facility,
    const gchar *facility_facility_control_key,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_facility_facility = (guint8)(facility_facility);
    g_free (self->arg_facility_facility_control_key);
    self->arg_facility_facility_control_key = g_strdup (facility_facility_control_key ? facility_facility_control_key : "");
    self->arg_facility_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_uim_unblock_ck_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimUnblockCkInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_unblock_ck_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_unblock_ck_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_unblock_ck_input_ref:
 * @self: a #QmiMessageDmsUimUnblockCkInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimUnblockCkInput *
qmi_message_dms_uim_unblock_ck_input_ref (QmiMessageDmsUimUnblockCkInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_unblock_ck_input_unref:
 * @self: a #QmiMessageDmsUimUnblockCkInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_unblock_ck_input_unref (QmiMessageDmsUimUnblockCkInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_facility_facility_control_key);
        g_slice_free (QmiMessageDmsUimUnblockCkInput, self);
    }
}

/**
 * qmi_message_dms_uim_unblock_ck_input_new:
 *
 * Allocates a new #QmiMessageDmsUimUnblockCkInput.
 *
 * Returns: the newly created #QmiMessageDmsUimUnblockCkInput. The returned value should be freed with qmi_message_dms_uim_unblock_ck_input_unref().
 */
QmiMessageDmsUimUnblockCkInput *
qmi_message_dms_uim_unblock_ck_input_new (void)
{
    QmiMessageDmsUimUnblockCkInput *self;

    self = g_slice_new0 (QmiMessageDmsUimUnblockCkInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_uim_unblock_ck_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsUimUnblockCkInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_UNBLOCK_CK);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'UIM Unblock CK' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Facility' TLV */
    if (input->arg_facility_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_facility_facility;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_facility_facility_control_key);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_INPUT_TLV_FACILITY,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Facility TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Facility' in message 'UIM Unblock CK'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimUnblockCkOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Unblock Retries Left */
    gboolean arg_unblock_retries_left_set;
    guint8 arg_unblock_retries_left;
};

#define QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_OUTPUT_TLV_UNBLOCK_RETRIES_LEFT 0x10

/**
 * qmi_message_dms_uim_unblock_ck_output_get_result:
 * @self: a QmiMessageDmsUimUnblockCkOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_unblock_ck_output_get_result (
    QmiMessageDmsUimUnblockCkOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_unblock_ck_output_get_unblock_retries_left:
 * @self: a #QmiMessageDmsUimUnblockCkOutput.
 * @unblock_retries_left: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Unblock Retries Left' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_unblock_ck_output_get_unblock_retries_left (
    QmiMessageDmsUimUnblockCkOutput *self,
    guint8 *unblock_retries_left,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_unblock_retries_left_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Unblock Retries Left' was not found in the message");
        return FALSE;
    }

    if (unblock_retries_left)
        *unblock_retries_left = self->arg_unblock_retries_left;

    return TRUE;
}

GType
qmi_message_dms_uim_unblock_ck_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimUnblockCkOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_unblock_ck_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_unblock_ck_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_unblock_ck_output_ref:
 * @self: a #QmiMessageDmsUimUnblockCkOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimUnblockCkOutput *
qmi_message_dms_uim_unblock_ck_output_ref (QmiMessageDmsUimUnblockCkOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_unblock_ck_output_unref:
 * @self: a #QmiMessageDmsUimUnblockCkOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_unblock_ck_output_unref (QmiMessageDmsUimUnblockCkOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsUimUnblockCkOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_unblock_ck_input_facility_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Facility' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Facility' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_unblock_ck_input_facility_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_INPUT_TLV_FACILITY,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_unblock_ck_input_facility_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " facility = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_FACILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_facility_get_string ((QmiDmsUimFacility)tmp));
#elif defined  __QMI_DMS_UIM_FACILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_facility_build_string_from_mask ((QmiDmsUimFacility)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimFacility
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " facility_control_key = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Facility' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_uim_unblock_ck_output_unblock_retries_left_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Unblock Retries Left' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Unblock Retries Left' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_unblock_ck_output_unblock_retries_left_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_OUTPUT_TLV_UNBLOCK_RETRIES_LEFT,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_unblock_ck_output_unblock_retries_left_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Unblock Retries Left' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_unblock_ck_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_unblock_ck_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_unblock_ck_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_INPUT_TLV_FACILITY:
            tlv_type_str = "Facility";
            translated_value = qmi_message_dms_uim_unblock_ck_input_facility_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_OUTPUT_TLV_UNBLOCK_RETRIES_LEFT:
            tlv_type_str = "Unblock Retries Left";
            translated_value = qmi_message_dms_uim_unblock_ck_output_unblock_retries_left_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_unblock_ck_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Unblock CK\" (0x0042)\n",
                            line_prefix);

    {
        struct message_uim_unblock_ck_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_unblock_ck_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimUnblockCkOutput *
__qmi_message_dms_uim_unblock_ck_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimUnblockCkOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_UNBLOCK_CK, NULL);

    self = g_slice_new0 (QmiMessageDmsUimUnblockCkOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_unblock_ck_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_UNBLOCK_CK_OUTPUT_TLV_UNBLOCK_RETRIES_LEFT,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_unblock_ck_output_unblock_retries_left_validate (buffer, buffer_len)) {
                self->arg_unblock_retries_left_set = TRUE;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &buffer,
                    &buffer_len,
                    &(self->arg_unblock_retries_left));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Unblock Retries Left' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Get IMSI */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_uim_get_imsi_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_GET_IMSI);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimGetImsiOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* IMSI */
    gboolean arg_imsi_set;
    gchar *arg_imsi;
};

#define QMI_MESSAGE_DMS_UIM_GET_IMSI_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_GET_IMSI_OUTPUT_TLV_IMSI 0x01

/**
 * qmi_message_dms_uim_get_imsi_output_get_result:
 * @self: a QmiMessageDmsUimGetImsiOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_get_imsi_output_get_result (
    QmiMessageDmsUimGetImsiOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_get_imsi_output_get_imsi:
 * @self: a #QmiMessageDmsUimGetImsiOutput.
 * @imsi: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'IMSI' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_get_imsi_output_get_imsi (
    QmiMessageDmsUimGetImsiOutput *self,
    const gchar **imsi,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_imsi_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'IMSI' was not found in the message");
        return FALSE;
    }

    if (imsi)
        *imsi = self->arg_imsi;

    return TRUE;
}

GType
qmi_message_dms_uim_get_imsi_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimGetImsiOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_get_imsi_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_get_imsi_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_get_imsi_output_ref:
 * @self: a #QmiMessageDmsUimGetImsiOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimGetImsiOutput *
qmi_message_dms_uim_get_imsi_output_ref (QmiMessageDmsUimGetImsiOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_get_imsi_output_unref:
 * @self: a #QmiMessageDmsUimGetImsiOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_get_imsi_output_unref (QmiMessageDmsUimGetImsiOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_imsi);
        g_slice_free (QmiMessageDmsUimGetImsiOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_get_imsi_output_imsi_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'IMSI' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'IMSI' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_get_imsi_output_imsi_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_GET_IMSI_OUTPUT_TLV_IMSI,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_get_imsi_output_imsi_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'IMSI' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_get_imsi_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_get_imsi_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_get_imsi_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_GET_IMSI_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_GET_IMSI_OUTPUT_TLV_IMSI:
            tlv_type_str = "IMSI";
            translated_value = qmi_message_dms_uim_get_imsi_output_imsi_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_get_imsi_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Get IMSI\" (0x0043)\n",
                            line_prefix);

    {
        struct message_uim_get_imsi_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_get_imsi_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimGetImsiOutput *
__qmi_message_dms_uim_get_imsi_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimGetImsiOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_GET_IMSI, NULL);

    self = g_slice_new0 (QmiMessageDmsUimGetImsiOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_IMSI_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_get_imsi_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_IMSI_OUTPUT_TLV_IMSI,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_get_imsi_output_imsi_validate (buffer, buffer_len)) {
                self->arg_imsi_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_imsi));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'IMSI' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the IMSI TLV: Not found");
                qmi_message_dms_uim_get_imsi_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS UIM Get State */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_uim_get_state_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_UIM_GET_STATE);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsUimGetStateOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* State */
    gboolean arg_state_set;
    guint8 arg_state;
};

#define QMI_MESSAGE_DMS_UIM_GET_STATE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_UIM_GET_STATE_OUTPUT_TLV_STATE 0x01

/**
 * qmi_message_dms_uim_get_state_output_get_result:
 * @self: a QmiMessageDmsUimGetStateOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_uim_get_state_output_get_result (
    QmiMessageDmsUimGetStateOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_uim_get_state_output_get_state:
 * @self: a #QmiMessageDmsUimGetStateOutput.
 * @state: a placeholder for the output #QmiDmsUimState, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'State' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_uim_get_state_output_get_state (
    QmiMessageDmsUimGetStateOutput *self,
    QmiDmsUimState *state,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_state_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'State' was not found in the message");
        return FALSE;
    }

    if (state)
        *state = (QmiDmsUimState)(self->arg_state);

    return TRUE;
}

GType
qmi_message_dms_uim_get_state_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsUimGetStateOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_uim_get_state_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_uim_get_state_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_uim_get_state_output_ref:
 * @self: a #QmiMessageDmsUimGetStateOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsUimGetStateOutput *
qmi_message_dms_uim_get_state_output_ref (QmiMessageDmsUimGetStateOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_uim_get_state_output_unref:
 * @self: a #QmiMessageDmsUimGetStateOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_uim_get_state_output_unref (QmiMessageDmsUimGetStateOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsUimGetStateOutput, self);
    }
}

static gboolean
qmi_message_dms_uim_get_state_output_state_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'State' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'State' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_uim_get_state_output_state_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_UIM_GET_STATE_OUTPUT_TLV_STATE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_uim_get_state_output_state_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_UIM_STATE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_uim_state_get_string ((QmiDmsUimState)tmp));
#elif defined  __QMI_DMS_UIM_STATE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_uim_state_build_string_from_mask ((QmiDmsUimState)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsUimState
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'State' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_uim_get_state_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_uim_get_state_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_uim_get_state_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_UIM_GET_STATE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_UIM_GET_STATE_OUTPUT_TLV_STATE:
            tlv_type_str = "State";
            translated_value = qmi_message_dms_uim_get_state_output_state_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_uim_get_state_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"UIM Get State\" (0x0044)\n",
                            line_prefix);

    {
        struct message_uim_get_state_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_uim_get_state_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsUimGetStateOutput *
__qmi_message_dms_uim_get_state_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsUimGetStateOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_UIM_GET_STATE, NULL);

    self = g_slice_new0 (QmiMessageDmsUimGetStateOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_STATE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_uim_get_state_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_UIM_GET_STATE_OUTPUT_TLV_STATE,
                                              &buffer_len);
            if (buffer && qmi_message_dms_uim_get_state_output_state_validate (buffer, buffer_len)) {
                self->arg_state_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_state = (QmiDmsUimState)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'State' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the State TLV: Not found");
                qmi_message_dms_uim_get_state_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Band Capabilities */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_band_capabilities_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetBandCapabilitiesOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Band Capability */
    gboolean arg_band_capability_set;
    guint64 arg_band_capability;

    /* LTE Band Capability */
    gboolean arg_lte_band_capability_set;
    guint64 arg_lte_band_capability;
};

#define QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_BAND_CAPABILITY 0x01
#define QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_LTE_BAND_CAPABILITY 0x10

/**
 * qmi_message_dms_get_band_capabilities_output_get_result:
 * @self: a QmiMessageDmsGetBandCapabilitiesOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_band_capabilities_output_get_result (
    QmiMessageDmsGetBandCapabilitiesOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_band_capabilities_output_get_band_capability:
 * @self: a #QmiMessageDmsGetBandCapabilitiesOutput.
 * @band_capability: a placeholder for the output #QmiDmsBandCapability, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Band Capability' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_band_capabilities_output_get_band_capability (
    QmiMessageDmsGetBandCapabilitiesOutput *self,
    QmiDmsBandCapability *band_capability,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_band_capability_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Band Capability' was not found in the message");
        return FALSE;
    }

    if (band_capability)
        *band_capability = (QmiDmsBandCapability)(self->arg_band_capability);

    return TRUE;
}

/**
 * qmi_message_dms_get_band_capabilities_output_get_lte_band_capability:
 * @self: a #QmiMessageDmsGetBandCapabilitiesOutput.
 * @lte_band_capability: a placeholder for the output #QmiDmsLteBandCapability, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'LTE Band Capability' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_band_capabilities_output_get_lte_band_capability (
    QmiMessageDmsGetBandCapabilitiesOutput *self,
    QmiDmsLteBandCapability *lte_band_capability,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_lte_band_capability_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'LTE Band Capability' was not found in the message");
        return FALSE;
    }

    if (lte_band_capability)
        *lte_band_capability = (QmiDmsLteBandCapability)(self->arg_lte_band_capability);

    return TRUE;
}

GType
qmi_message_dms_get_band_capabilities_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetBandCapabilitiesOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_band_capabilities_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_band_capabilities_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_band_capabilities_output_ref:
 * @self: a #QmiMessageDmsGetBandCapabilitiesOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetBandCapabilitiesOutput *
qmi_message_dms_get_band_capabilities_output_ref (QmiMessageDmsGetBandCapabilitiesOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_band_capabilities_output_unref:
 * @self: a #QmiMessageDmsGetBandCapabilitiesOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_band_capabilities_output_unref (QmiMessageDmsGetBandCapabilitiesOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsGetBandCapabilitiesOutput, self);
    }
}

static gboolean
qmi_message_dms_get_band_capabilities_output_band_capability_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Band Capability' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Band Capability' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_band_capabilities_output_band_capability_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_BAND_CAPABILITY,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_band_capabilities_output_band_capability_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_DMS_BAND_CAPABILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_band_capability_get_string ((QmiDmsBandCapability)tmp));
#elif defined  __QMI_DMS_BAND_CAPABILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_band_capability_build_string_from_mask ((QmiDmsBandCapability)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsBandCapability
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Band Capability' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_band_capabilities_output_lte_band_capability_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'LTE Band Capability' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'LTE Band Capability' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_band_capabilities_output_lte_band_capability_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_LTE_BAND_CAPABILITY,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_band_capabilities_output_lte_band_capability_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_DMS_LTE_BAND_CAPABILITY_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_lte_band_capability_get_string ((QmiDmsLteBandCapability)tmp));
#elif defined  __QMI_DMS_LTE_BAND_CAPABILITY_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_lte_band_capability_build_string_from_mask ((QmiDmsLteBandCapability)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsLteBandCapability
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'LTE Band Capability' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_band_capabilities_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_band_capabilities_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_band_capabilities_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_BAND_CAPABILITY:
            tlv_type_str = "Band Capability";
            translated_value = qmi_message_dms_get_band_capabilities_output_band_capability_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_LTE_BAND_CAPABILITY:
            tlv_type_str = "LTE Band Capability";
            translated_value = qmi_message_dms_get_band_capabilities_output_lte_band_capability_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_band_capabilities_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Band Capabilities\" (0x0045)\n",
                            line_prefix);

    {
        struct message_get_band_capabilities_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_band_capabilities_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetBandCapabilitiesOutput *
__qmi_message_dms_get_band_capabilities_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetBandCapabilitiesOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES, NULL);

    self = g_slice_new0 (QmiMessageDmsGetBandCapabilitiesOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_band_capabilities_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_BAND_CAPABILITY,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_band_capabilities_output_band_capability_validate (buffer, buffer_len)) {
                self->arg_band_capability_set = TRUE;

                {
                    guint64 tmp;

                    /* Read the guint64 variable from the buffer */
                    qmi_utils_read_guint64_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_band_capability = (QmiDmsBandCapability)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Band Capability' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Band Capability TLV: Not found");
                qmi_message_dms_get_band_capabilities_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES_OUTPUT_TLV_LTE_BAND_CAPABILITY,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_band_capabilities_output_lte_band_capability_validate (buffer, buffer_len)) {
                self->arg_lte_band_capability_set = TRUE;

                {
                    guint64 tmp;

                    /* Read the guint64 variable from the buffer */
                    qmi_utils_read_guint64_from_buffer (
                        &buffer,
                        &buffer_len,
                        QMI_ENDIAN_LITTLE,
                        &tmp);
                    self->arg_lte_band_capability = (QmiDmsLteBandCapability)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'LTE Band Capability' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Factory SKU */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_factory_sku_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_FACTORY_SKU);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetFactorySkuOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* SKU */
    gboolean arg_sku_set;
    gchar *arg_sku;
};

#define QMI_MESSAGE_DMS_GET_FACTORY_SKU_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_FACTORY_SKU_OUTPUT_TLV_SKU 0x01

/**
 * qmi_message_dms_get_factory_sku_output_get_result:
 * @self: a QmiMessageDmsGetFactorySkuOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_factory_sku_output_get_result (
    QmiMessageDmsGetFactorySkuOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_factory_sku_output_get_sku:
 * @self: a #QmiMessageDmsGetFactorySkuOutput.
 * @sku: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'SKU' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_factory_sku_output_get_sku (
    QmiMessageDmsGetFactorySkuOutput *self,
    const gchar **sku,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_sku_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'SKU' was not found in the message");
        return FALSE;
    }

    if (sku)
        *sku = self->arg_sku;

    return TRUE;
}

GType
qmi_message_dms_get_factory_sku_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetFactorySkuOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_factory_sku_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_factory_sku_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_factory_sku_output_ref:
 * @self: a #QmiMessageDmsGetFactorySkuOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetFactorySkuOutput *
qmi_message_dms_get_factory_sku_output_ref (QmiMessageDmsGetFactorySkuOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_factory_sku_output_unref:
 * @self: a #QmiMessageDmsGetFactorySkuOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_factory_sku_output_unref (QmiMessageDmsGetFactorySkuOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_sku);
        g_slice_free (QmiMessageDmsGetFactorySkuOutput, self);
    }
}

static gboolean
qmi_message_dms_get_factory_sku_output_sku_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'SKU' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'SKU' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_factory_sku_output_sku_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_FACTORY_SKU_OUTPUT_TLV_SKU,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_factory_sku_output_sku_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'SKU' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_factory_sku_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_factory_sku_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_factory_sku_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_FACTORY_SKU_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_FACTORY_SKU_OUTPUT_TLV_SKU:
            tlv_type_str = "SKU";
            translated_value = qmi_message_dms_get_factory_sku_output_sku_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_factory_sku_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Factory SKU\" (0x0046)\n",
                            line_prefix);

    {
        struct message_get_factory_sku_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_factory_sku_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetFactorySkuOutput *
__qmi_message_dms_get_factory_sku_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetFactorySkuOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_FACTORY_SKU, NULL);

    self = g_slice_new0 (QmiMessageDmsGetFactorySkuOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_FACTORY_SKU_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_factory_sku_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_FACTORY_SKU_OUTPUT_TLV_SKU,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_factory_sku_output_sku_validate (buffer, buffer_len)) {
                self->arg_sku_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_sku));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'SKU' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the SKU TLV: Not found");
                qmi_message_dms_get_factory_sku_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Firmware Preference */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_firmware_preference_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE);

    return self;
}

/* --- Output -- */

static void
list_qmimessagedmsgetfirmwarepreferenceoutputlistimage_clear (QmiMessageDmsGetFirmwarePreferenceOutputListImage *p)
{
    if ((*p).unique_id)
        g_array_unref ((*p).unique_id);
    g_free ((*p).build_id);
}

struct _QmiMessageDmsGetFirmwarePreferenceOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* List */
    gboolean arg_list_set;
    GArray *arg_list;
};

#define QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE_OUTPUT_TLV_LIST 0x01

/**
 * qmi_message_dms_get_firmware_preference_output_get_result:
 * @self: a QmiMessageDmsGetFirmwarePreferenceOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_firmware_preference_output_get_result (
    QmiMessageDmsGetFirmwarePreferenceOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_firmware_preference_output_get_list:
 * @self: a #QmiMessageDmsGetFirmwarePreferenceOutput.
 * @list: a placeholder for the output #GArray of #QmiMessageDmsGetFirmwarePreferenceOutputListImage elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_firmware_preference_output_get_list (
    QmiMessageDmsGetFirmwarePreferenceOutput *self,
    GArray **list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'List' was not found in the message");
        return FALSE;
    }

    if (list)
        *list = self->arg_list;

    return TRUE;
}

GType
qmi_message_dms_get_firmware_preference_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetFirmwarePreferenceOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_firmware_preference_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_firmware_preference_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_firmware_preference_output_ref:
 * @self: a #QmiMessageDmsGetFirmwarePreferenceOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetFirmwarePreferenceOutput *
qmi_message_dms_get_firmware_preference_output_ref (QmiMessageDmsGetFirmwarePreferenceOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_firmware_preference_output_unref:
 * @self: a #QmiMessageDmsGetFirmwarePreferenceOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_firmware_preference_output_unref (QmiMessageDmsGetFirmwarePreferenceOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_list)
            g_array_unref (self->arg_list);
        g_slice_free (QmiMessageDmsGetFirmwarePreferenceOutput, self);
    }
}

static gboolean
qmi_message_dms_get_firmware_preference_output_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint list_i;
        guint8 list_n_items;
        const guint8 *list_aux_buffer = &buffer[expected_len];
        guint16 list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &list_aux_buffer,
            &list_aux_buffer_len,
            &(list_n_items));
        for (list_i = 0; list_i < list_n_items; list_i++) {

            expected_len += 1;
            {
                guint unique_id_i;
                guint16 unique_id_n_items = 16;

                for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {

                    expected_len += 1;
                }
            }
            {
                guint8 size8;
                const guint8 *aux_buffer = &buffer[expected_len];
                guint16 aux_buffer_len = buffer_len - expected_len;

                qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
                expected_len += (1 + size8);
            }
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_firmware_preference_output_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE_OUTPUT_TLV_LIST,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_firmware_preference_output_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint list_i;
            guint8 list_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(list_n_items));

            g_string_append (printable, "{");

            for (list_i = 0; list_i < list_n_items; list_i++) {
                g_string_append_printf (printable, " [%u] = '", list_i);
                g_string_append (printable, "[");
                g_string_append (printable, " type = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_dms_firmware_image_type_get_string ((QmiDmsFirmwareImageType)tmp));
#elif defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_dms_firmware_image_type_build_string_from_mask ((QmiDmsFirmwareImageType)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiDmsFirmwareImageType
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " unique_id = '");
                {
                    guint unique_id_i;
                    guint16 unique_id_n_items = 16;


                    g_string_append (printable, "{");

                    for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {
                        g_string_append_printf (printable, " [%u] = '", unique_id_i);

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);

                            g_string_append_printf (printable, "%u", (guint)tmp);
                        }
                        g_string_append (printable, " '");
                    }

                    g_string_append (printable, "}");
                }                g_string_append (printable, "'");
                g_string_append (printable, " build_id = '");

                {
                    gchar *tmp;

                    /* Read the string variable from the buffer */
                    qmi_utils_read_string_from_buffer (
                        &buffer,
                        &buffer_len,
                        8,
                        0,
                        &tmp);

                    g_string_append_printf (printable, "%s", tmp);
                    g_free (tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_firmware_preference_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_firmware_preference_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_firmware_preference_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE_OUTPUT_TLV_LIST:
            tlv_type_str = "List";
            translated_value = qmi_message_dms_get_firmware_preference_output_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_firmware_preference_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Firmware Preference\" (0x0047)\n",
                            line_prefix);

    {
        struct message_get_firmware_preference_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_firmware_preference_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetFirmwarePreferenceOutput *
__qmi_message_dms_get_firmware_preference_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetFirmwarePreferenceOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE, NULL);

    self = g_slice_new0 (QmiMessageDmsGetFirmwarePreferenceOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_firmware_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE_OUTPUT_TLV_LIST,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_firmware_preference_output_list_validate (buffer, buffer_len)) {
                self->arg_list_set = TRUE;

                {
                    guint list_i;
                    guint8 list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(list_n_items));

                    self->arg_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageDmsGetFirmwarePreferenceOutputListImage),
                        (guint)list_n_items);

                    g_array_set_clear_func (self->arg_list,
                                            (GDestroyNotify)list_qmimessagedmsgetfirmwarepreferenceoutputlistimage_clear);

                    for (list_i = 0; list_i < list_n_items; list_i++) {
                        QmiMessageDmsGetFirmwarePreferenceOutputListImage list_aux;

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            list_aux.type = (QmiDmsFirmwareImageType)tmp;
                        }
                        {
                            guint unique_id_i;
                            guint16 unique_id_n_items = 16;


                            list_aux.unique_id = g_array_sized_new (
                                FALSE,
                                FALSE,
                                sizeof (guint8),
                                (guint)unique_id_n_items);

                            for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {
                                guint8 unique_id_aux;

                                /* Read the guint8 variable from the buffer */
                                qmi_utils_read_guint8_from_buffer (
                                    &buffer,
                                    &buffer_len,
                                    &(unique_id_aux));
                                g_array_insert_val (list_aux.unique_id, unique_id_i, unique_id_aux);
                            }
                        }
                        /* Read the string variable from the buffer */
                        qmi_utils_read_string_from_buffer (
                            &buffer,
                            &buffer_len,
                            8,
                            0,
                            &(list_aux.build_id));
                        g_array_insert_val (self->arg_list, list_i, list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'List' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the List TLV: Not found");
                qmi_message_dms_get_firmware_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Set Firmware Preference */


/* --- Input -- */

struct _QmiMessageDmsSetFirmwarePreferenceInput {
    volatile gint ref_count;

    /* Modem Storage Index */
    gboolean arg_modem_storage_index_set;
    guint8 arg_modem_storage_index;

    /* Download Override */
    gboolean arg_download_override_set;
    guint8 arg_download_override;

    /* List */
    gboolean arg_list_set;
    GArray *arg_list;
};

#define QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_MODEM_STORAGE_INDEX 0x11
#define QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_DOWNLOAD_OVERRIDE 0x10
#define QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_LIST 0x01

/**
 * qmi_message_dms_set_firmware_preference_input_get_modem_storage_index:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceInput.
 * @modem_storage_index: a placeholder for the output #guint8, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Modem Storage Index' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_firmware_preference_input_get_modem_storage_index (
    QmiMessageDmsSetFirmwarePreferenceInput *self,
    guint8 *modem_storage_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_modem_storage_index_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Modem Storage Index' was not found in the message");
        return FALSE;
    }

    if (modem_storage_index)
        *modem_storage_index = self->arg_modem_storage_index;

    return TRUE;
}

/**
 * qmi_message_dms_set_firmware_preference_input_set_modem_storage_index:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceInput.
 * @modem_storage_index: a #guint8.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Modem Storage Index' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_firmware_preference_input_set_modem_storage_index (
    QmiMessageDmsSetFirmwarePreferenceInput *self,
    guint8 modem_storage_index,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_modem_storage_index = modem_storage_index;
    self->arg_modem_storage_index_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_firmware_preference_input_get_download_override:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceInput.
 * @download_override: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Download Override' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_firmware_preference_input_get_download_override (
    QmiMessageDmsSetFirmwarePreferenceInput *self,
    gboolean *download_override,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_download_override_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Download Override' was not found in the message");
        return FALSE;
    }

    if (download_override)
        *download_override = (gboolean)(self->arg_download_override);

    return TRUE;
}

/**
 * qmi_message_dms_set_firmware_preference_input_set_download_override:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceInput.
 * @download_override: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Download Override' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_firmware_preference_input_set_download_override (
    QmiMessageDmsSetFirmwarePreferenceInput *self,
    gboolean download_override,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_download_override = (guint8)(download_override);
    self->arg_download_override_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_firmware_preference_input_get_list:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceInput.
 * @list: a placeholder for the output #GArray of #QmiMessageDmsSetFirmwarePreferenceInputListImage elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_firmware_preference_input_get_list (
    QmiMessageDmsSetFirmwarePreferenceInput *self,
    GArray **list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'List' was not found in the message");
        return FALSE;
    }

    if (list)
        *list = self->arg_list;

    return TRUE;
}

/**
 * qmi_message_dms_set_firmware_preference_input_set_list:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceInput.
 * @list: a #GArray of #QmiMessageDmsSetFirmwarePreferenceInputListImage elements. A new reference to @list will be taken.
 * @error: Return location for error or %NULL.
 *
 * Set the 'List' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_firmware_preference_input_set_list (
    QmiMessageDmsSetFirmwarePreferenceInput *self,
    GArray *list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (self->arg_list)
        g_array_unref (self->arg_list);
    self->arg_list = g_array_ref (list);
    self->arg_list_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_set_firmware_preference_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetFirmwarePreferenceInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_firmware_preference_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_firmware_preference_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_firmware_preference_input_ref:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetFirmwarePreferenceInput *
qmi_message_dms_set_firmware_preference_input_ref (QmiMessageDmsSetFirmwarePreferenceInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_firmware_preference_input_unref:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_firmware_preference_input_unref (QmiMessageDmsSetFirmwarePreferenceInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_list)
            g_array_unref (self->arg_list);
        g_slice_free (QmiMessageDmsSetFirmwarePreferenceInput, self);
    }
}

/**
 * qmi_message_dms_set_firmware_preference_input_new:
 *
 * Allocates a new #QmiMessageDmsSetFirmwarePreferenceInput.
 *
 * Returns: the newly created #QmiMessageDmsSetFirmwarePreferenceInput. The returned value should be freed with qmi_message_dms_set_firmware_preference_input_unref().
 */
QmiMessageDmsSetFirmwarePreferenceInput *
qmi_message_dms_set_firmware_preference_input_new (void)
{
    QmiMessageDmsSetFirmwarePreferenceInput *self;

    self = g_slice_new0 (QmiMessageDmsSetFirmwarePreferenceInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_set_firmware_preference_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsSetFirmwarePreferenceInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Set Firmware Preference' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Modem Storage Index' TLV */
    if (input->arg_modem_storage_index_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the guint8 variable to the buffer */
        qmi_utils_write_guint8_to_buffer (
            &buffer_aux,
            &buffer_len,
            &(input->arg_modem_storage_index));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_MODEM_STORAGE_INDEX,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Modem Storage Index TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'Download Override' TLV */
    if (input->arg_download_override_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_download_override;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_DOWNLOAD_OVERRIDE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Download Override TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    }

    /* Try to add the 'List' TLV */
    if (input->arg_list_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint list_i;
            guint8 list_n_items;

            /* Write the number of items in the array first */
            list_n_items = (guint8) input->arg_list->len;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &(list_n_items));

            for (list_i = 0; list_i < input->arg_list->len; list_i++) {
                {
                    guint8 tmp;

                    tmp = (guint8)g_array_index (input->arg_list, QmiMessageDmsSetFirmwarePreferenceInputListImage,list_i).type;
                    /* Write the guint8 variable to the buffer */
                    qmi_utils_write_guint8_to_buffer (
                        &buffer_aux,
                        &buffer_len,
                        &tmp);
                }
                {
                    guint unique_id_i;

                    for (unique_id_i = 0; unique_id_i < g_array_index (input->arg_list, QmiMessageDmsSetFirmwarePreferenceInputListImage,list_i).unique_id->len; unique_id_i++) {
                        /* Write the guint8 variable to the buffer */
                        qmi_utils_write_guint8_to_buffer (
                            &buffer_aux,
                            &buffer_len,
                            &(g_array_index (g_array_index (input->arg_list, QmiMessageDmsSetFirmwarePreferenceInputListImage,list_i).unique_id, guint8,unique_id_i)));
                    }
                }
                /* Write the string variable to the buffer */
                qmi_utils_write_string_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    8,
                    g_array_index (input->arg_list, QmiMessageDmsSetFirmwarePreferenceInputListImage,list_i).build_id);
            }
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_LIST,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the List TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'List' in message 'Set Firmware Preference'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsSetFirmwarePreferenceOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Image Download List */
    gboolean arg_image_download_list_set;
    GArray *arg_image_download_list;
};

#define QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_OUTPUT_TLV_IMAGE_DOWNLOAD_LIST 0x01

/**
 * qmi_message_dms_set_firmware_preference_output_get_result:
 * @self: a QmiMessageDmsSetFirmwarePreferenceOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_set_firmware_preference_output_get_result (
    QmiMessageDmsSetFirmwarePreferenceOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_set_firmware_preference_output_get_image_download_list:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceOutput.
 * @image_download_list: a placeholder for the output #GArray of #QmiDmsFirmwareImageType elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Image Download List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_firmware_preference_output_get_image_download_list (
    QmiMessageDmsSetFirmwarePreferenceOutput *self,
    GArray **image_download_list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_image_download_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Image Download List' was not found in the message");
        return FALSE;
    }

    if (image_download_list)
        *image_download_list = self->arg_image_download_list;

    return TRUE;
}

GType
qmi_message_dms_set_firmware_preference_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetFirmwarePreferenceOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_firmware_preference_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_firmware_preference_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_firmware_preference_output_ref:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetFirmwarePreferenceOutput *
qmi_message_dms_set_firmware_preference_output_ref (QmiMessageDmsSetFirmwarePreferenceOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_firmware_preference_output_unref:
 * @self: a #QmiMessageDmsSetFirmwarePreferenceOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_firmware_preference_output_unref (QmiMessageDmsSetFirmwarePreferenceOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_image_download_list)
            g_array_unref (self->arg_image_download_list);
        g_slice_free (QmiMessageDmsSetFirmwarePreferenceOutput, self);
    }
}

static gboolean
qmi_message_dms_set_firmware_preference_input_modem_storage_index_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Modem Storage Index' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Modem Storage Index' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_firmware_preference_input_modem_storage_index_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_MODEM_STORAGE_INDEX,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_firmware_preference_input_modem_storage_index_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%u", (guint)tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Modem Storage Index' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_firmware_preference_input_download_override_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Download Override' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Download Override' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_firmware_preference_input_download_override_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_DOWNLOAD_OVERRIDE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_firmware_preference_input_download_override_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Download Override' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_firmware_preference_input_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint list_i;
        guint8 list_n_items;
        const guint8 *list_aux_buffer = &buffer[expected_len];
        guint16 list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &list_aux_buffer,
            &list_aux_buffer_len,
            &(list_n_items));
        for (list_i = 0; list_i < list_n_items; list_i++) {

            expected_len += 1;
            {
                guint unique_id_i;
                guint16 unique_id_n_items = 16;

                for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {

                    expected_len += 1;
                }
            }
            {
                guint8 size8;
                const guint8 *aux_buffer = &buffer[expected_len];
                guint16 aux_buffer_len = buffer_len - expected_len;

                qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
                expected_len += (1 + size8);
            }
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_firmware_preference_input_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_LIST,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_firmware_preference_input_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint list_i;
            guint8 list_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(list_n_items));

            g_string_append (printable, "{");

            for (list_i = 0; list_i < list_n_items; list_i++) {
                g_string_append_printf (printable, " [%u] = '", list_i);
                g_string_append (printable, "[");
                g_string_append (printable, " type = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_dms_firmware_image_type_get_string ((QmiDmsFirmwareImageType)tmp));
#elif defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_dms_firmware_image_type_build_string_from_mask ((QmiDmsFirmwareImageType)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiDmsFirmwareImageType
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " unique_id = '");
                {
                    guint unique_id_i;
                    guint16 unique_id_n_items = 16;


                    g_string_append (printable, "{");

                    for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {
                        g_string_append_printf (printable, " [%u] = '", unique_id_i);

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);

                            g_string_append_printf (printable, "%u", (guint)tmp);
                        }
                        g_string_append (printable, " '");
                    }

                    g_string_append (printable, "}");
                }                g_string_append (printable, "'");
                g_string_append (printable, " build_id = '");

                {
                    gchar *tmp;

                    /* Read the string variable from the buffer */
                    qmi_utils_read_string_from_buffer (
                        &buffer,
                        &buffer_len,
                        8,
                        0,
                        &tmp);

                    g_string_append_printf (printable, "%s", tmp);
                    g_free (tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_firmware_preference_output_image_download_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint image_download_list_i;
        guint8 image_download_list_n_items;
        const guint8 *image_download_list_aux_buffer = &buffer[expected_len];
        guint16 image_download_list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &image_download_list_aux_buffer,
            &image_download_list_aux_buffer_len,
            &(image_download_list_n_items));
        for (image_download_list_i = 0; image_download_list_i < image_download_list_n_items; image_download_list_i++) {

            expected_len += 1;
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Image Download List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Image Download List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_firmware_preference_output_image_download_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_OUTPUT_TLV_IMAGE_DOWNLOAD_LIST,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_firmware_preference_output_image_download_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint image_download_list_i;
            guint8 image_download_list_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(image_download_list_n_items));

            g_string_append (printable, "{");

            for (image_download_list_i = 0; image_download_list_i < image_download_list_n_items; image_download_list_i++) {
                g_string_append_printf (printable, " [%u] = '", image_download_list_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_dms_firmware_image_type_get_string ((QmiDmsFirmwareImageType)tmp));
#elif defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_dms_firmware_image_type_build_string_from_mask ((QmiDmsFirmwareImageType)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiDmsFirmwareImageType
#endif
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Image Download List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_firmware_preference_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_firmware_preference_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_firmware_preference_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_MODEM_STORAGE_INDEX:
            tlv_type_str = "Modem Storage Index";
            translated_value = qmi_message_dms_set_firmware_preference_input_modem_storage_index_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_DOWNLOAD_OVERRIDE:
            tlv_type_str = "Download Override";
            translated_value = qmi_message_dms_set_firmware_preference_input_download_override_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_INPUT_TLV_LIST:
            tlv_type_str = "List";
            translated_value = qmi_message_dms_set_firmware_preference_input_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_OUTPUT_TLV_IMAGE_DOWNLOAD_LIST:
            tlv_type_str = "Image Download List";
            translated_value = qmi_message_dms_set_firmware_preference_output_image_download_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_firmware_preference_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Firmware Preference\" (0x0048)\n",
                            line_prefix);

    {
        struct message_set_firmware_preference_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_firmware_preference_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsSetFirmwarePreferenceOutput *
__qmi_message_dms_set_firmware_preference_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsSetFirmwarePreferenceOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE, NULL);

    self = g_slice_new0 (QmiMessageDmsSetFirmwarePreferenceOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_set_firmware_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE_OUTPUT_TLV_IMAGE_DOWNLOAD_LIST,
                                              &buffer_len);
            if (buffer && qmi_message_dms_set_firmware_preference_output_image_download_list_validate (buffer, buffer_len)) {
                self->arg_image_download_list_set = TRUE;

                {
                    guint image_download_list_i;
                    guint8 image_download_list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(image_download_list_n_items));

                    self->arg_image_download_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiDmsFirmwareImageType),
                        (guint)image_download_list_n_items);

                    for (image_download_list_i = 0; image_download_list_i < image_download_list_n_items; image_download_list_i++) {
                        QmiDmsFirmwareImageType image_download_list_aux;

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            image_download_list_aux = (QmiDmsFirmwareImageType)tmp;
                        }
                        g_array_insert_val (self->arg_image_download_list, image_download_list_i, image_download_list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Image Download List' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Image Download List TLV: Not found");
                qmi_message_dms_set_firmware_preference_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS List Stored Images */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_list_stored_images_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_LIST_STORED_IMAGES);

    return self;
}

/* --- Output -- */

static void
sublist_qmimessagedmsliststoredimagesoutputlistimagesublistsublistelement_clear (QmiMessageDmsListStoredImagesOutputListImageSublistSublistElement *p)
{
    if ((*p).unique_id)
        g_array_unref ((*p).unique_id);
    g_free ((*p).build_id);
}

static void
list_qmimessagedmsliststoredimagesoutputlistimage_clear (QmiMessageDmsListStoredImagesOutputListImage *p)
{
    if ((*p).sublist)
        g_array_unref ((*p).sublist);
}

struct _QmiMessageDmsListStoredImagesOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* List */
    gboolean arg_list_set;
    GArray *arg_list;
};

#define QMI_MESSAGE_DMS_LIST_STORED_IMAGES_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_LIST_STORED_IMAGES_OUTPUT_TLV_LIST 0x01

/**
 * qmi_message_dms_list_stored_images_output_get_result:
 * @self: a QmiMessageDmsListStoredImagesOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_list_stored_images_output_get_result (
    QmiMessageDmsListStoredImagesOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_list_stored_images_output_get_list:
 * @self: a #QmiMessageDmsListStoredImagesOutput.
 * @list: a placeholder for the output #GArray of #QmiMessageDmsListStoredImagesOutputListImage elements, or %NULL if not required. Do not free it, it is owned by @self.
 * @error: Return location for error or %NULL.
 *
 * Get the 'List' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_list_stored_images_output_get_list (
    QmiMessageDmsListStoredImagesOutput *self,
    GArray **list,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_list_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'List' was not found in the message");
        return FALSE;
    }

    if (list)
        *list = self->arg_list;

    return TRUE;
}

GType
qmi_message_dms_list_stored_images_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsListStoredImagesOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_list_stored_images_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_list_stored_images_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_list_stored_images_output_ref:
 * @self: a #QmiMessageDmsListStoredImagesOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsListStoredImagesOutput *
qmi_message_dms_list_stored_images_output_ref (QmiMessageDmsListStoredImagesOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_list_stored_images_output_unref:
 * @self: a #QmiMessageDmsListStoredImagesOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_list_stored_images_output_unref (QmiMessageDmsListStoredImagesOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_list)
            g_array_unref (self->arg_list);
        g_slice_free (QmiMessageDmsListStoredImagesOutput, self);
    }
}

static gboolean
qmi_message_dms_list_stored_images_output_list_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    {
        guint list_i;
        guint8 list_n_items;
        const guint8 *list_aux_buffer = &buffer[expected_len];
        guint16 list_aux_buffer_len = buffer_len - expected_len;

        expected_len += 1;

        /* Read the guint8 variable from the buffer */
        qmi_utils_read_guint8_from_buffer (
            &list_aux_buffer,
            &list_aux_buffer_len,
            &(list_n_items));
        for (list_i = 0; list_i < list_n_items; list_i++) {

            expected_len += 1;
            expected_len += 1;
            expected_len += 1;
            {
                guint sublist_i;
                guint8 sublist_n_items;
                const guint8 *sublist_aux_buffer = &buffer[expected_len];
                guint16 sublist_aux_buffer_len = buffer_len - expected_len;

                expected_len += 1;

                /* Read the guint8 variable from the buffer */
                qmi_utils_read_guint8_from_buffer (
                    &sublist_aux_buffer,
                    &sublist_aux_buffer_len,
                    &(sublist_n_items));
                for (sublist_i = 0; sublist_i < sublist_n_items; sublist_i++) {

                    expected_len += 1;
                    expected_len += 1;
                    {
                        guint unique_id_i;
                        guint16 unique_id_n_items = 16;

                        for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {

                            expected_len += 1;
                        }
                    }
                    {
                        guint8 size8;
                        const guint8 *aux_buffer = &buffer[expected_len];
                        guint16 aux_buffer_len = buffer_len - expected_len;

                        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
                        expected_len += (1 + size8);
                    }
                }
            }
        }
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'List' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'List' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_list_stored_images_output_list_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_LIST_STORED_IMAGES_OUTPUT_TLV_LIST,
                                      &buffer_len);
    if (buffer && qmi_message_dms_list_stored_images_output_list_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        {
            guint list_i;
            guint8 list_n_items;

            /* Read number of items in the array */
            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &(list_n_items));

            g_string_append (printable, "{");

            for (list_i = 0; list_i < list_n_items; list_i++) {
                g_string_append_printf (printable, " [%u] = '", list_i);
                g_string_append (printable, "[");
                g_string_append (printable, " type = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

#if defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_ENUM__
                    g_string_append_printf (printable, "%s", qmi_dms_firmware_image_type_get_string ((QmiDmsFirmwareImageType)tmp));
#elif defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_FLAGS__
                    {
                        gchar *flags_str;

                        flags_str = qmi_dms_firmware_image_type_build_string_from_mask ((QmiDmsFirmwareImageType)tmp);
                        g_string_append_printf (printable, "%s", flags_str);
                        g_free (flags_str);
                    }
#else
# error unexpected public format: QmiDmsFirmwareImageType
#endif
                }
                g_string_append (printable, "'");
                g_string_append (printable, " maximum_images = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%u", (guint)tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " index_of_running_image = '");

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%u", (guint)tmp);
                }
                g_string_append (printable, "'");
                g_string_append (printable, " sublist = '");
                {
                    guint sublist_i;
                    guint8 sublist_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(sublist_n_items));

                    g_string_append (printable, "{");

                    for (sublist_i = 0; sublist_i < sublist_n_items; sublist_i++) {
                        g_string_append_printf (printable, " [%u] = '", sublist_i);
                        g_string_append (printable, "[");
                        g_string_append (printable, " storage_index = '");

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);

                            g_string_append_printf (printable, "%u", (guint)tmp);
                        }
                        g_string_append (printable, "'");
                        g_string_append (printable, " failure_count = '");

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);

                            g_string_append_printf (printable, "%u", (guint)tmp);
                        }
                        g_string_append (printable, "'");
                        g_string_append (printable, " unique_id = '");
                        {
                            guint unique_id_i;
                            guint16 unique_id_n_items = 16;


                            g_string_append (printable, "{");

                            for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {
                                g_string_append_printf (printable, " [%u] = '", unique_id_i);

                                {
                                    guint8 tmp;

                                    /* Read the guint8 variable from the buffer */
                                    qmi_utils_read_guint8_from_buffer (
                                        &buffer,
                                        &buffer_len,
                                        &tmp);

                                    g_string_append_printf (printable, "%u", (guint)tmp);
                                }
                                g_string_append (printable, " '");
                            }

                            g_string_append (printable, "}");
                        }                        g_string_append (printable, "'");
                        g_string_append (printable, " build_id = '");

                        {
                            gchar *tmp;

                            /* Read the string variable from the buffer */
                            qmi_utils_read_string_from_buffer (
                                &buffer,
                                &buffer_len,
                                8,
                                0,
                                &tmp);

                            g_string_append_printf (printable, "%s", tmp);
                            g_free (tmp);
                        }
                        g_string_append (printable, "'");
                        g_string_append (printable, " ]");
                        g_string_append (printable, " '");
                    }

                    g_string_append (printable, "}");
                }                g_string_append (printable, "'");
                g_string_append (printable, " ]");
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }
        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'List' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_list_stored_images_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_list_stored_images_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_list_stored_images_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_LIST_STORED_IMAGES_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_LIST_STORED_IMAGES_OUTPUT_TLV_LIST:
            tlv_type_str = "List";
            translated_value = qmi_message_dms_list_stored_images_output_list_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_list_stored_images_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"List Stored Images\" (0x0049)\n",
                            line_prefix);

    {
        struct message_list_stored_images_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_list_stored_images_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsListStoredImagesOutput *
__qmi_message_dms_list_stored_images_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsListStoredImagesOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_LIST_STORED_IMAGES, NULL);

    self = g_slice_new0 (QmiMessageDmsListStoredImagesOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_LIST_STORED_IMAGES_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_list_stored_images_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_LIST_STORED_IMAGES_OUTPUT_TLV_LIST,
                                              &buffer_len);
            if (buffer && qmi_message_dms_list_stored_images_output_list_validate (buffer, buffer_len)) {
                self->arg_list_set = TRUE;

                {
                    guint list_i;
                    guint8 list_n_items;

                    /* Read number of items in the array */
                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &(list_n_items));

                    self->arg_list = g_array_sized_new (
                        FALSE,
                        FALSE,
                        sizeof (QmiMessageDmsListStoredImagesOutputListImage),
                        (guint)list_n_items);

                    g_array_set_clear_func (self->arg_list,
                                            (GDestroyNotify)list_qmimessagedmsliststoredimagesoutputlistimage_clear);

                    for (list_i = 0; list_i < list_n_items; list_i++) {
                        QmiMessageDmsListStoredImagesOutputListImage list_aux;

                        {
                            guint8 tmp;

                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &tmp);
                            list_aux.type = (QmiDmsFirmwareImageType)tmp;
                        }
                        /* Read the guint8 variable from the buffer */
                        qmi_utils_read_guint8_from_buffer (
                            &buffer,
                            &buffer_len,
                            &(list_aux.maximum_images));
                        /* Read the guint8 variable from the buffer */
                        qmi_utils_read_guint8_from_buffer (
                            &buffer,
                            &buffer_len,
                            &(list_aux.index_of_running_image));
                        {
                            guint sublist_i;
                            guint8 sublist_n_items;

                            /* Read number of items in the array */
                            /* Read the guint8 variable from the buffer */
                            qmi_utils_read_guint8_from_buffer (
                                &buffer,
                                &buffer_len,
                                &(sublist_n_items));

                            list_aux.sublist = g_array_sized_new (
                                FALSE,
                                FALSE,
                                sizeof (QmiMessageDmsListStoredImagesOutputListImageSublistSublistElement),
                                (guint)sublist_n_items);

                            g_array_set_clear_func (list_aux.sublist,
                                                    (GDestroyNotify)sublist_qmimessagedmsliststoredimagesoutputlistimagesublistsublistelement_clear);

                            for (sublist_i = 0; sublist_i < sublist_n_items; sublist_i++) {
                                QmiMessageDmsListStoredImagesOutputListImageSublistSublistElement sublist_aux;

                                /* Read the guint8 variable from the buffer */
                                qmi_utils_read_guint8_from_buffer (
                                    &buffer,
                                    &buffer_len,
                                    &(sublist_aux.storage_index));
                                /* Read the guint8 variable from the buffer */
                                qmi_utils_read_guint8_from_buffer (
                                    &buffer,
                                    &buffer_len,
                                    &(sublist_aux.failure_count));
                                {
                                    guint unique_id_i;
                                    guint16 unique_id_n_items = 16;


                                    sublist_aux.unique_id = g_array_sized_new (
                                        FALSE,
                                        FALSE,
                                        sizeof (guint8),
                                        (guint)unique_id_n_items);

                                    for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {
                                        guint8 unique_id_aux;

                                        /* Read the guint8 variable from the buffer */
                                        qmi_utils_read_guint8_from_buffer (
                                            &buffer,
                                            &buffer_len,
                                            &(unique_id_aux));
                                        g_array_insert_val (sublist_aux.unique_id, unique_id_i, unique_id_aux);
                                    }
                                }
                                /* Read the string variable from the buffer */
                                qmi_utils_read_string_from_buffer (
                                    &buffer,
                                    &buffer_len,
                                    8,
                                    0,
                                    &(sublist_aux.build_id));
                                g_array_insert_val (list_aux.sublist, sublist_i, sublist_aux);
                            }
                        }
                        g_array_insert_val (self->arg_list, list_i, list_aux);
                    }
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'List' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the List TLV: Not found");
                qmi_message_dms_list_stored_images_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Delete Stored Image */


/* --- Input -- */

struct _QmiMessageDmsDeleteStoredImageInput {
    volatile gint ref_count;

    /* Image */
    gboolean arg_image_set;
    QmiMessageDmsDeleteStoredImageInputImage arg_image;
};

#define QMI_MESSAGE_DMS_DELETE_STORED_IMAGE_INPUT_TLV_IMAGE 0x01

/**
 * qmi_message_dms_delete_stored_image_input_get_image:
 * @self: a #QmiMessageDmsDeleteStoredImageInput.
 * @image: a placeholder for the output constant #QmiMessageDmsDeleteStoredImageInputImage, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Image' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_delete_stored_image_input_get_image (
    QmiMessageDmsDeleteStoredImageInput *self,
    QmiMessageDmsDeleteStoredImageInputImage *image,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_image_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Image' was not found in the message");
        return FALSE;
    }

    if (image)
        *image = self->arg_image;

    return TRUE;
}

/**
 * qmi_message_dms_delete_stored_image_input_set_image:
 * @self: a #QmiMessageDmsDeleteStoredImageInput.
 * @image: the address of the #QmiMessageDmsDeleteStoredImageInputImage to set.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Image' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_delete_stored_image_input_set_image (
    QmiMessageDmsDeleteStoredImageInput *self,
    const QmiMessageDmsDeleteStoredImageInputImage *image,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_image.type = (guint8)(image->type);
    if (self->arg_image.unique_id)
        g_array_unref (self->arg_image.unique_id);
    self->arg_image.unique_id = g_array_ref (image->unique_id);
    g_free (self->arg_image.build_id);
    self->arg_image.build_id = g_strdup (image->build_id ? image->build_id : "");
    self->arg_image_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_delete_stored_image_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsDeleteStoredImageInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_delete_stored_image_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_delete_stored_image_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_delete_stored_image_input_ref:
 * @self: a #QmiMessageDmsDeleteStoredImageInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsDeleteStoredImageInput *
qmi_message_dms_delete_stored_image_input_ref (QmiMessageDmsDeleteStoredImageInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_delete_stored_image_input_unref:
 * @self: a #QmiMessageDmsDeleteStoredImageInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_delete_stored_image_input_unref (QmiMessageDmsDeleteStoredImageInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_image.unique_id)
            g_array_unref (self->arg_image.unique_id);
        g_free (self->arg_image.build_id);
        g_slice_free (QmiMessageDmsDeleteStoredImageInput, self);
    }
}

/**
 * qmi_message_dms_delete_stored_image_input_new:
 *
 * Allocates a new #QmiMessageDmsDeleteStoredImageInput.
 *
 * Returns: the newly created #QmiMessageDmsDeleteStoredImageInput. The returned value should be freed with qmi_message_dms_delete_stored_image_input_unref().
 */
QmiMessageDmsDeleteStoredImageInput *
qmi_message_dms_delete_stored_image_input_new (void)
{
    QmiMessageDmsDeleteStoredImageInput *self;

    self = g_slice_new0 (QmiMessageDmsDeleteStoredImageInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_delete_stored_image_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsDeleteStoredImageInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_DELETE_STORED_IMAGE);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Delete Stored Image' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Image' TLV */
    if (input->arg_image_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_image.type;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        {
            guint unique_id_i;

            for (unique_id_i = 0; unique_id_i < input->arg_image.unique_id->len; unique_id_i++) {
                /* Write the guint8 variable to the buffer */
                qmi_utils_write_guint8_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    &(g_array_index (input->arg_image.unique_id, guint8,unique_id_i)));
            }
        }
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_image.build_id);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_DELETE_STORED_IMAGE_INPUT_TLV_IMAGE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Image TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Image' in message 'Delete Stored Image'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsDeleteStoredImageOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_DELETE_STORED_IMAGE_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_delete_stored_image_output_get_result:
 * @self: a QmiMessageDmsDeleteStoredImageOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_delete_stored_image_output_get_result (
    QmiMessageDmsDeleteStoredImageOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_delete_stored_image_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsDeleteStoredImageOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_delete_stored_image_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_delete_stored_image_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_delete_stored_image_output_ref:
 * @self: a #QmiMessageDmsDeleteStoredImageOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsDeleteStoredImageOutput *
qmi_message_dms_delete_stored_image_output_ref (QmiMessageDmsDeleteStoredImageOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_delete_stored_image_output_unref:
 * @self: a #QmiMessageDmsDeleteStoredImageOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_delete_stored_image_output_unref (QmiMessageDmsDeleteStoredImageOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsDeleteStoredImageOutput, self);
    }
}

static gboolean
qmi_message_dms_delete_stored_image_input_image_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    {
        guint unique_id_i;
        guint16 unique_id_n_items = 16;

        for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {

            expected_len += 1;
        }
    }
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Image' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Image' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_delete_stored_image_input_image_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_DELETE_STORED_IMAGE_INPUT_TLV_IMAGE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_delete_stored_image_input_image_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " type = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_firmware_image_type_get_string ((QmiDmsFirmwareImageType)tmp));
#elif defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_firmware_image_type_build_string_from_mask ((QmiDmsFirmwareImageType)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsFirmwareImageType
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unique_id = '");
        {
            guint unique_id_i;
            guint16 unique_id_n_items = 16;


            g_string_append (printable, "{");

            for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {
                g_string_append_printf (printable, " [%u] = '", unique_id_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%u", (guint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }        g_string_append (printable, "'");
        g_string_append (printable, " build_id = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Image' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_delete_stored_image_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_delete_stored_image_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_delete_stored_image_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_DELETE_STORED_IMAGE_INPUT_TLV_IMAGE:
            tlv_type_str = "Image";
            translated_value = qmi_message_dms_delete_stored_image_input_image_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_DELETE_STORED_IMAGE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_delete_stored_image_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Delete Stored Image\" (0x004A)\n",
                            line_prefix);

    {
        struct message_delete_stored_image_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_delete_stored_image_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsDeleteStoredImageOutput *
__qmi_message_dms_delete_stored_image_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsDeleteStoredImageOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_DELETE_STORED_IMAGE, NULL);

    self = g_slice_new0 (QmiMessageDmsDeleteStoredImageOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_DELETE_STORED_IMAGE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_delete_stored_image_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Set Time */


/* --- Input -- */

struct _QmiMessageDmsSetTimeInput {
    volatile gint ref_count;

    /* Time Reference Type */
    gboolean arg_time_reference_type_set;
    guint32 arg_time_reference_type;

    /* Time Value */
    gboolean arg_time_value_set;
    guint64 arg_time_value;
};

#define QMI_MESSAGE_DMS_SET_TIME_INPUT_TLV_TIME_REFERENCE_TYPE 0x10
#define QMI_MESSAGE_DMS_SET_TIME_INPUT_TLV_TIME_VALUE 0x01

/**
 * qmi_message_dms_set_time_input_get_time_reference_type:
 * @self: a #QmiMessageDmsSetTimeInput.
 * @time_reference_type: a placeholder for the output #QmiDmsTimeReferenceType, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Time Reference Type' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_time_input_get_time_reference_type (
    QmiMessageDmsSetTimeInput *self,
    QmiDmsTimeReferenceType *time_reference_type,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_time_reference_type_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Time Reference Type' was not found in the message");
        return FALSE;
    }

    if (time_reference_type)
        *time_reference_type = (QmiDmsTimeReferenceType)(self->arg_time_reference_type);

    return TRUE;
}

/**
 * qmi_message_dms_set_time_input_set_time_reference_type:
 * @self: a #QmiMessageDmsSetTimeInput.
 * @time_reference_type: a #QmiDmsTimeReferenceType.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Time Reference Type' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_time_input_set_time_reference_type (
    QmiMessageDmsSetTimeInput *self,
    QmiDmsTimeReferenceType time_reference_type,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_time_reference_type = (guint32)(time_reference_type);
    self->arg_time_reference_type_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_time_input_get_time_value:
 * @self: a #QmiMessageDmsSetTimeInput.
 * @time_value: a placeholder for the output #guint64, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Time Value' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_time_input_get_time_value (
    QmiMessageDmsSetTimeInput *self,
    guint64 *time_value,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_time_value_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Time Value' was not found in the message");
        return FALSE;
    }

    if (time_value)
        *time_value = self->arg_time_value;

    return TRUE;
}

/**
 * qmi_message_dms_set_time_input_set_time_value:
 * @self: a #QmiMessageDmsSetTimeInput.
 * @time_value: a #guint64.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Time Value' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_time_input_set_time_value (
    QmiMessageDmsSetTimeInput *self,
    guint64 time_value,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_time_value = time_value;
    self->arg_time_value_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_set_time_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetTimeInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_time_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_time_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_time_input_ref:
 * @self: a #QmiMessageDmsSetTimeInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetTimeInput *
qmi_message_dms_set_time_input_ref (QmiMessageDmsSetTimeInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_time_input_unref:
 * @self: a #QmiMessageDmsSetTimeInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_time_input_unref (QmiMessageDmsSetTimeInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetTimeInput, self);
    }
}

/**
 * qmi_message_dms_set_time_input_new:
 *
 * Allocates a new #QmiMessageDmsSetTimeInput.
 *
 * Returns: the newly created #QmiMessageDmsSetTimeInput. The returned value should be freed with qmi_message_dms_set_time_input_unref().
 */
QmiMessageDmsSetTimeInput *
qmi_message_dms_set_time_input_new (void)
{
    QmiMessageDmsSetTimeInput *self;

    self = g_slice_new0 (QmiMessageDmsSetTimeInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_set_time_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsSetTimeInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_SET_TIME);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Set Time' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Time Reference Type' TLV */
    if (input->arg_time_reference_type_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint32 tmp;

            tmp = (guint32)input->arg_time_reference_type;
            /* Write the guint32 variable to the buffer */
            qmi_utils_write_guint32_to_buffer (
                &buffer_aux,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_TIME_INPUT_TLV_TIME_REFERENCE_TYPE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Time Reference Type TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Time Reference Type' in message 'Set Time'");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Time Value' TLV */
    if (input->arg_time_value_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the guint64 variable to the buffer */
        qmi_utils_write_guint64_to_buffer (
            &buffer_aux,
            &buffer_len,
            QMI_ENDIAN_LITTLE,
            &(input->arg_time_value));

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_TIME_INPUT_TLV_TIME_VALUE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Time Value TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Time Value' in message 'Set Time'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsSetTimeOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_SET_TIME_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_set_time_output_get_result:
 * @self: a QmiMessageDmsSetTimeOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_set_time_output_get_result (
    QmiMessageDmsSetTimeOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_set_time_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetTimeOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_time_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_time_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_time_output_ref:
 * @self: a #QmiMessageDmsSetTimeOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetTimeOutput *
qmi_message_dms_set_time_output_ref (QmiMessageDmsSetTimeOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_time_output_unref:
 * @self: a #QmiMessageDmsSetTimeOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_time_output_unref (QmiMessageDmsSetTimeOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetTimeOutput, self);
    }
}

static gboolean
qmi_message_dms_set_time_input_time_reference_type_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Time Reference Type' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Time Reference Type' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_time_input_time_reference_type_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_TIME_INPUT_TLV_TIME_REFERENCE_TYPE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_time_input_time_reference_type_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

#if defined  __QMI_DMS_TIME_REFERENCE_TYPE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_time_reference_type_get_string ((QmiDmsTimeReferenceType)tmp));
#elif defined  __QMI_DMS_TIME_REFERENCE_TYPE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_time_reference_type_build_string_from_mask ((QmiDmsTimeReferenceType)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsTimeReferenceType
#endif
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Time Reference Type' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_time_input_time_value_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 8;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Time Value' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Time Value' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_time_input_time_value_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_TIME_INPUT_TLV_TIME_VALUE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_time_input_time_value_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint64 tmp;

            /* Read the guint64 variable from the buffer */
            qmi_utils_read_guint64_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT64_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Time Value' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_time_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_time_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_time_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_TIME_INPUT_TLV_TIME_REFERENCE_TYPE:
            tlv_type_str = "Time Reference Type";
            translated_value = qmi_message_dms_set_time_input_time_reference_type_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_TIME_INPUT_TLV_TIME_VALUE:
            tlv_type_str = "Time Value";
            translated_value = qmi_message_dms_set_time_input_time_value_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_TIME_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_time_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Time\" (0x004B)\n",
                            line_prefix);

    {
        struct message_set_time_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_time_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsSetTimeOutput *
__qmi_message_dms_set_time_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsSetTimeOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_SET_TIME, NULL);

    self = g_slice_new0 (QmiMessageDmsSetTimeOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_SET_TIME_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_set_time_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Stored Image Info */


/* --- Input -- */

struct _QmiMessageDmsGetStoredImageInfoInput {
    volatile gint ref_count;

    /* Image */
    gboolean arg_image_set;
    QmiMessageDmsGetStoredImageInfoInputImage arg_image;
};

#define QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_INPUT_TLV_IMAGE 0x01

/**
 * qmi_message_dms_get_stored_image_info_input_get_image:
 * @self: a #QmiMessageDmsGetStoredImageInfoInput.
 * @image: a placeholder for the output constant #QmiMessageDmsGetStoredImageInfoInputImage, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Image' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_stored_image_info_input_get_image (
    QmiMessageDmsGetStoredImageInfoInput *self,
    QmiMessageDmsGetStoredImageInfoInputImage *image,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_image_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Image' was not found in the message");
        return FALSE;
    }

    if (image)
        *image = self->arg_image;

    return TRUE;
}

/**
 * qmi_message_dms_get_stored_image_info_input_set_image:
 * @self: a #QmiMessageDmsGetStoredImageInfoInput.
 * @image: the address of the #QmiMessageDmsGetStoredImageInfoInputImage to set.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Image' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_stored_image_info_input_set_image (
    QmiMessageDmsGetStoredImageInfoInput *self,
    const QmiMessageDmsGetStoredImageInfoInputImage *image,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_image.type = (guint8)(image->type);
    if (self->arg_image.unique_id)
        g_array_unref (self->arg_image.unique_id);
    self->arg_image.unique_id = g_array_ref (image->unique_id);
    g_free (self->arg_image.build_id);
    self->arg_image.build_id = g_strdup (image->build_id ? image->build_id : "");
    self->arg_image_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_get_stored_image_info_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetStoredImageInfoInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_stored_image_info_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_stored_image_info_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_stored_image_info_input_ref:
 * @self: a #QmiMessageDmsGetStoredImageInfoInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetStoredImageInfoInput *
qmi_message_dms_get_stored_image_info_input_ref (QmiMessageDmsGetStoredImageInfoInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_stored_image_info_input_unref:
 * @self: a #QmiMessageDmsGetStoredImageInfoInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_stored_image_info_input_unref (QmiMessageDmsGetStoredImageInfoInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        if (self->arg_image.unique_id)
            g_array_unref (self->arg_image.unique_id);
        g_free (self->arg_image.build_id);
        g_slice_free (QmiMessageDmsGetStoredImageInfoInput, self);
    }
}

/**
 * qmi_message_dms_get_stored_image_info_input_new:
 *
 * Allocates a new #QmiMessageDmsGetStoredImageInfoInput.
 *
 * Returns: the newly created #QmiMessageDmsGetStoredImageInfoInput. The returned value should be freed with qmi_message_dms_get_stored_image_info_input_unref().
 */
QmiMessageDmsGetStoredImageInfoInput *
qmi_message_dms_get_stored_image_info_input_new (void)
{
    QmiMessageDmsGetStoredImageInfoInput *self;

    self = g_slice_new0 (QmiMessageDmsGetStoredImageInfoInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_get_stored_image_info_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsGetStoredImageInfoInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Get Stored Image Info' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Image' TLV */
    if (input->arg_image_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_image.type;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }
        {
            guint unique_id_i;

            for (unique_id_i = 0; unique_id_i < input->arg_image.unique_id->len; unique_id_i++) {
                /* Write the guint8 variable to the buffer */
                qmi_utils_write_guint8_to_buffer (
                    &buffer_aux,
                    &buffer_len,
                    &(g_array_index (input->arg_image.unique_id, guint8,unique_id_i)));
            }
        }
        /* Write the string variable to the buffer */
        qmi_utils_write_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            8,
            input->arg_image.build_id);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_INPUT_TLV_IMAGE,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Image TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Image' in message 'Get Stored Image Info'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetStoredImageInfoOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Boot Version */
    gboolean arg_boot_version_set;
    guint16 arg_boot_version_major_version;
    guint16 arg_boot_version_minor_version;

    /* PRI Version */
    gboolean arg_pri_version_set;
    guint32 arg_pri_version_pri_version;
    gchar arg_pri_version_pri_info[33];

    /* OEM Lock ID */
    gboolean arg_oem_lock_id_set;
    guint32 arg_oem_lock_id;
};

#define QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_BOOT_VERSION 0x10
#define QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_PRI_VERSION 0x11
#define QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_OEM_LOCK_ID 0x12

/**
 * qmi_message_dms_get_stored_image_info_output_get_result:
 * @self: a QmiMessageDmsGetStoredImageInfoOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_stored_image_info_output_get_result (
    QmiMessageDmsGetStoredImageInfoOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_stored_image_info_output_get_boot_version:
 * @self: a #QmiMessageDmsGetStoredImageInfoOutput.
 * @boot_version_major_version: a placeholder for the output #guint16, or %NULL if not required.
 * @boot_version_minor_version: a placeholder for the output #guint16, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Boot Version' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_stored_image_info_output_get_boot_version (
    QmiMessageDmsGetStoredImageInfoOutput *self,
    guint16 *boot_version_major_version,
    guint16 *boot_version_minor_version,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_boot_version_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Boot Version' was not found in the message");
        return FALSE;
    }

    if (boot_version_major_version)
        *boot_version_major_version = self->arg_boot_version_major_version;
    if (boot_version_minor_version)
        *boot_version_minor_version = self->arg_boot_version_minor_version;

    return TRUE;
}

/**
 * qmi_message_dms_get_stored_image_info_output_get_pri_version:
 * @self: a #QmiMessageDmsGetStoredImageInfoOutput.
 * @pri_version_pri_version: a placeholder for the output #guint32, or %NULL if not required.
 * @pri_version_pri_info: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'PRI Version' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_stored_image_info_output_get_pri_version (
    QmiMessageDmsGetStoredImageInfoOutput *self,
    guint32 *pri_version_pri_version,
    const gchar **pri_version_pri_info,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_pri_version_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'PRI Version' was not found in the message");
        return FALSE;
    }

    if (pri_version_pri_version)
        *pri_version_pri_version = self->arg_pri_version_pri_version;
    if (pri_version_pri_info)
        *pri_version_pri_info = self->arg_pri_version_pri_info;

    return TRUE;
}

/**
 * qmi_message_dms_get_stored_image_info_output_get_oem_lock_id:
 * @self: a #QmiMessageDmsGetStoredImageInfoOutput.
 * @oem_lock_id: a placeholder for the output #guint32, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'OEM Lock ID' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_stored_image_info_output_get_oem_lock_id (
    QmiMessageDmsGetStoredImageInfoOutput *self,
    guint32 *oem_lock_id,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_oem_lock_id_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'OEM Lock ID' was not found in the message");
        return FALSE;
    }

    if (oem_lock_id)
        *oem_lock_id = self->arg_oem_lock_id;

    return TRUE;
}

GType
qmi_message_dms_get_stored_image_info_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetStoredImageInfoOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_stored_image_info_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_stored_image_info_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_stored_image_info_output_ref:
 * @self: a #QmiMessageDmsGetStoredImageInfoOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetStoredImageInfoOutput *
qmi_message_dms_get_stored_image_info_output_ref (QmiMessageDmsGetStoredImageInfoOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_stored_image_info_output_unref:
 * @self: a #QmiMessageDmsGetStoredImageInfoOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_stored_image_info_output_unref (QmiMessageDmsGetStoredImageInfoOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsGetStoredImageInfoOutput, self);
    }
}

static gboolean
qmi_message_dms_get_stored_image_info_input_image_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;
    {
        guint unique_id_i;
        guint16 unique_id_n_items = 16;

        for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {

            expected_len += 1;
        }
    }
    {
        guint8 size8;
        const guint8 *aux_buffer = &buffer[expected_len];
        guint16 aux_buffer_len = buffer_len - expected_len;

        qmi_utils_read_guint8_from_buffer (&aux_buffer, &aux_buffer_len, &size8);
        expected_len += (1 + size8);
    }

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Image' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Image' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_stored_image_info_input_image_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_INPUT_TLV_IMAGE,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_stored_image_info_input_image_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " type = '");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

#if defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_ENUM__
            g_string_append_printf (printable, "%s", qmi_dms_firmware_image_type_get_string ((QmiDmsFirmwareImageType)tmp));
#elif defined  __QMI_DMS_FIRMWARE_IMAGE_TYPE_IS_FLAGS__
            {
                gchar *flags_str;

                flags_str = qmi_dms_firmware_image_type_build_string_from_mask ((QmiDmsFirmwareImageType)tmp);
                g_string_append_printf (printable, "%s", flags_str);
                g_free (flags_str);
            }
#else
# error unexpected public format: QmiDmsFirmwareImageType
#endif
        }
        g_string_append (printable, "'");
        g_string_append (printable, " unique_id = '");
        {
            guint unique_id_i;
            guint16 unique_id_n_items = 16;


            g_string_append (printable, "{");

            for (unique_id_i = 0; unique_id_i < unique_id_n_items; unique_id_i++) {
                g_string_append_printf (printable, " [%u] = '", unique_id_i);

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);

                    g_string_append_printf (printable, "%u", (guint)tmp);
                }
                g_string_append (printable, " '");
            }

            g_string_append (printable, "}");
        }        g_string_append (printable, "'");
        g_string_append (printable, " build_id = '");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                8,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Image' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_stored_image_info_output_boot_version_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 2;
    expected_len += 2;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Boot Version' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Boot Version' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_stored_image_info_output_boot_version_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_BOOT_VERSION,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_stored_image_info_output_boot_version_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " major_version = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " minor_version = '");

        {
            guint16 tmp;

            /* Read the guint16 variable from the buffer */
            qmi_utils_read_guint16_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT16_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Boot Version' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_stored_image_info_output_pri_version_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;
    expected_len += 32;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'PRI Version' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'PRI Version' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_stored_image_info_output_pri_version_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_PRI_VERSION,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_stored_image_info_output_pri_version_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");
        g_string_append (printable, "[");
        g_string_append (printable, " pri_version = '");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " pri_info = '");

        {
            gchar tmp[33];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                32,
                &tmp[0]);
            tmp[32] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }
        g_string_append (printable, "'");
        g_string_append (printable, " ]");

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'PRI Version' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_get_stored_image_info_output_oem_lock_id_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 4;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'OEM Lock ID' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'OEM Lock ID' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_stored_image_info_output_oem_lock_id_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_OEM_LOCK_ID,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_stored_image_info_output_oem_lock_id_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint32 tmp;

            /* Read the guint32 variable from the buffer */
            qmi_utils_read_guint32_from_buffer (
                &buffer,
                &buffer_len,
                QMI_ENDIAN_LITTLE,
                &tmp);

            g_string_append_printf (printable, "%" G_GUINT32_FORMAT "", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'OEM Lock ID' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_stored_image_info_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_stored_image_info_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_stored_image_info_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_INPUT_TLV_IMAGE:
            tlv_type_str = "Image";
            translated_value = qmi_message_dms_get_stored_image_info_input_image_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_BOOT_VERSION:
            tlv_type_str = "Boot Version";
            translated_value = qmi_message_dms_get_stored_image_info_output_boot_version_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_PRI_VERSION:
            tlv_type_str = "PRI Version";
            translated_value = qmi_message_dms_get_stored_image_info_output_pri_version_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_OEM_LOCK_ID:
            tlv_type_str = "OEM Lock ID";
            translated_value = qmi_message_dms_get_stored_image_info_output_oem_lock_id_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_stored_image_info_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Stored Image Info\" (0x004C)\n",
                            line_prefix);

    {
        struct message_get_stored_image_info_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_stored_image_info_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetStoredImageInfoOutput *
__qmi_message_dms_get_stored_image_info_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetStoredImageInfoOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO, NULL);

    self = g_slice_new0 (QmiMessageDmsGetStoredImageInfoOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_stored_image_info_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_BOOT_VERSION,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_stored_image_info_output_boot_version_validate (buffer, buffer_len)) {
                self->arg_boot_version_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_boot_version_major_version));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_boot_version_minor_version));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Boot Version' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_PRI_VERSION,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_stored_image_info_output_pri_version_validate (buffer, buffer_len)) {
                self->arg_pri_version_set = TRUE;

                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_pri_version_pri_version));
                /* Read the fixed-size string variable from the buffer */
                qmi_utils_read_fixed_size_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    32,
                    &self->arg_pri_version_pri_info[0]);
                self->arg_pri_version_pri_info[32] = '\0';

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'PRI Version' TLV", buffer_len);
                }
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO_OUTPUT_TLV_OEM_LOCK_ID,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_stored_image_info_output_oem_lock_id_validate (buffer, buffer_len)) {
                self->arg_oem_lock_id_set = TRUE;

                /* Read the guint32 variable from the buffer */
                qmi_utils_read_guint32_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_oem_lock_id));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'OEM Lock ID' TLV", buffer_len);
                }
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Alt Net Config */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_alt_net_config_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetAltNetConfigOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Config */
    gboolean arg_config_set;
    guint8 arg_config;
};

#define QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG_OUTPUT_TLV_CONFIG 0x01

/**
 * qmi_message_dms_get_alt_net_config_output_get_result:
 * @self: a QmiMessageDmsGetAltNetConfigOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_alt_net_config_output_get_result (
    QmiMessageDmsGetAltNetConfigOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_alt_net_config_output_get_config:
 * @self: a #QmiMessageDmsGetAltNetConfigOutput.
 * @config: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Config' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_alt_net_config_output_get_config (
    QmiMessageDmsGetAltNetConfigOutput *self,
    gboolean *config,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_config_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Config' was not found in the message");
        return FALSE;
    }

    if (config)
        *config = (gboolean)(self->arg_config);

    return TRUE;
}

GType
qmi_message_dms_get_alt_net_config_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetAltNetConfigOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_alt_net_config_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_alt_net_config_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_alt_net_config_output_ref:
 * @self: a #QmiMessageDmsGetAltNetConfigOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetAltNetConfigOutput *
qmi_message_dms_get_alt_net_config_output_ref (QmiMessageDmsGetAltNetConfigOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_alt_net_config_output_unref:
 * @self: a #QmiMessageDmsGetAltNetConfigOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_alt_net_config_output_unref (QmiMessageDmsGetAltNetConfigOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsGetAltNetConfigOutput, self);
    }
}

static gboolean
qmi_message_dms_get_alt_net_config_output_config_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Config' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Config' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_alt_net_config_output_config_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG_OUTPUT_TLV_CONFIG,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_alt_net_config_output_config_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Config' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_alt_net_config_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_alt_net_config_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_alt_net_config_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG_OUTPUT_TLV_CONFIG:
            tlv_type_str = "Config";
            translated_value = qmi_message_dms_get_alt_net_config_output_config_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_alt_net_config_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Alt Net Config\" (0x004D)\n",
                            line_prefix);

    {
        struct message_get_alt_net_config_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_alt_net_config_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetAltNetConfigOutput *
__qmi_message_dms_get_alt_net_config_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetAltNetConfigOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG, NULL);

    self = g_slice_new0 (QmiMessageDmsGetAltNetConfigOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_alt_net_config_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG_OUTPUT_TLV_CONFIG,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_alt_net_config_output_config_validate (buffer, buffer_len)) {
                self->arg_config_set = TRUE;

                {
                    guint8 tmp;

                    /* Read the guint8 variable from the buffer */
                    qmi_utils_read_guint8_from_buffer (
                        &buffer,
                        &buffer_len,
                        &tmp);
                    self->arg_config = (gboolean)tmp;
                }

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Config' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Config TLV: Not found");
                qmi_message_dms_get_alt_net_config_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Set Alt Net Config */


/* --- Input -- */

struct _QmiMessageDmsSetAltNetConfigInput {
    volatile gint ref_count;

    /* Config */
    gboolean arg_config_set;
    guint8 arg_config;
};

#define QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG_INPUT_TLV_CONFIG 0x01

/**
 * qmi_message_dms_set_alt_net_config_input_get_config:
 * @self: a #QmiMessageDmsSetAltNetConfigInput.
 * @config: a placeholder for the output #gboolean, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Config' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_alt_net_config_input_get_config (
    QmiMessageDmsSetAltNetConfigInput *self,
    gboolean *config,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_config_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Config' was not found in the message");
        return FALSE;
    }

    if (config)
        *config = (gboolean)(self->arg_config);

    return TRUE;
}

/**
 * qmi_message_dms_set_alt_net_config_input_set_config:
 * @self: a #QmiMessageDmsSetAltNetConfigInput.
 * @config: a #gboolean.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Config' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_alt_net_config_input_set_config (
    QmiMessageDmsSetAltNetConfigInput *self,
    gboolean config,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    self->arg_config = (guint8)(config);
    self->arg_config_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_set_alt_net_config_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetAltNetConfigInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_alt_net_config_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_alt_net_config_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_alt_net_config_input_ref:
 * @self: a #QmiMessageDmsSetAltNetConfigInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetAltNetConfigInput *
qmi_message_dms_set_alt_net_config_input_ref (QmiMessageDmsSetAltNetConfigInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_alt_net_config_input_unref:
 * @self: a #QmiMessageDmsSetAltNetConfigInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_alt_net_config_input_unref (QmiMessageDmsSetAltNetConfigInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetAltNetConfigInput, self);
    }
}

/**
 * qmi_message_dms_set_alt_net_config_input_new:
 *
 * Allocates a new #QmiMessageDmsSetAltNetConfigInput.
 *
 * Returns: the newly created #QmiMessageDmsSetAltNetConfigInput. The returned value should be freed with qmi_message_dms_set_alt_net_config_input_unref().
 */
QmiMessageDmsSetAltNetConfigInput *
qmi_message_dms_set_alt_net_config_input_new (void)
{
    QmiMessageDmsSetAltNetConfigInput *self;

    self = g_slice_new0 (QmiMessageDmsSetAltNetConfigInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_set_alt_net_config_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsSetAltNetConfigInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Set Alt Net Config' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Config' TLV */
    if (input->arg_config_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        {
            guint8 tmp;

            tmp = (guint8)input->arg_config;
            /* Write the guint8 variable to the buffer */
            qmi_utils_write_guint8_to_buffer (
                &buffer_aux,
                &buffer_len,
                &tmp);
        }

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG_INPUT_TLV_CONFIG,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Config TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Config' in message 'Set Alt Net Config'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsSetAltNetConfigOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_set_alt_net_config_output_get_result:
 * @self: a QmiMessageDmsSetAltNetConfigOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_set_alt_net_config_output_get_result (
    QmiMessageDmsSetAltNetConfigOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_set_alt_net_config_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetAltNetConfigOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_alt_net_config_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_alt_net_config_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_alt_net_config_output_ref:
 * @self: a #QmiMessageDmsSetAltNetConfigOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetAltNetConfigOutput *
qmi_message_dms_set_alt_net_config_output_ref (QmiMessageDmsSetAltNetConfigOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_alt_net_config_output_unref:
 * @self: a #QmiMessageDmsSetAltNetConfigOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_alt_net_config_output_unref (QmiMessageDmsSetAltNetConfigOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetAltNetConfigOutput, self);
    }
}

static gboolean
qmi_message_dms_set_alt_net_config_input_config_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 1;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Config' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Config' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_alt_net_config_input_config_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG_INPUT_TLV_CONFIG,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_alt_net_config_input_config_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            guint8 tmp;

            /* Read the guint8 variable from the buffer */
            qmi_utils_read_guint8_from_buffer (
                &buffer,
                &buffer_len,
                &tmp);

            g_string_append_printf (printable, "%s", tmp ? "yes" : "no");
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Config' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_alt_net_config_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_alt_net_config_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_alt_net_config_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG_INPUT_TLV_CONFIG:
            tlv_type_str = "Config";
            translated_value = qmi_message_dms_set_alt_net_config_input_config_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_alt_net_config_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Alt Net Config\" (0x004E)\n",
                            line_prefix);

    {
        struct message_set_alt_net_config_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_alt_net_config_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsSetAltNetConfigOutput *
__qmi_message_dms_set_alt_net_config_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsSetAltNetConfigOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG, NULL);

    self = g_slice_new0 (QmiMessageDmsSetAltNetConfigOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_set_alt_net_config_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Get Software Version */


/* --- Input -- */

/* Note: no fields in the Input container */

static QmiMessage *
__qmi_message_dms_get_software_version_request_create (
    guint8 transaction_id,
    guint8 cid,
    gpointer unused,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION);

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsGetSoftwareVersionOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;

    /* Version */
    gboolean arg_version_set;
    gchar *arg_version;
};

#define QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION_OUTPUT_TLV_RESULT 0x02
#define QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION_OUTPUT_TLV_VERSION 0x01

/**
 * qmi_message_dms_get_software_version_output_get_result:
 * @self: a QmiMessageDmsGetSoftwareVersionOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_get_software_version_output_get_result (
    QmiMessageDmsGetSoftwareVersionOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

/**
 * qmi_message_dms_get_software_version_output_get_version:
 * @self: a #QmiMessageDmsGetSoftwareVersionOutput.
 * @version: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Version' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_get_software_version_output_get_version (
    QmiMessageDmsGetSoftwareVersionOutput *self,
    const gchar **version,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_version_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Version' was not found in the message");
        return FALSE;
    }

    if (version)
        *version = self->arg_version;

    return TRUE;
}

GType
qmi_message_dms_get_software_version_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsGetSoftwareVersionOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_get_software_version_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_get_software_version_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_get_software_version_output_ref:
 * @self: a #QmiMessageDmsGetSoftwareVersionOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsGetSoftwareVersionOutput *
qmi_message_dms_get_software_version_output_ref (QmiMessageDmsGetSoftwareVersionOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_get_software_version_output_unref:
 * @self: a #QmiMessageDmsGetSoftwareVersionOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_get_software_version_output_unref (QmiMessageDmsGetSoftwareVersionOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_free (self->arg_version);
        g_slice_free (QmiMessageDmsGetSoftwareVersionOutput, self);
    }
}

static gboolean
qmi_message_dms_get_software_version_output_version_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += buffer_len;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Version' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Version' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_get_software_version_output_version_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION_OUTPUT_TLV_VERSION,
                                      &buffer_len);
    if (buffer && qmi_message_dms_get_software_version_output_version_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar *tmp;

            /* Read the string variable from the buffer */
            qmi_utils_read_string_from_buffer (
                &buffer,
                &buffer_len,
                0,
                0,
                &tmp);

            g_string_append_printf (printable, "%s", tmp);
            g_free (tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Version' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_get_software_version_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_get_software_version_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_get_software_version_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION_OUTPUT_TLV_VERSION:
            tlv_type_str = "Version";
            translated_value = qmi_message_dms_get_software_version_output_version_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_get_software_version_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Get Software Version\" (0x0051)\n",
                            line_prefix);

    {
        struct message_get_software_version_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_get_software_version_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsGetSoftwareVersionOutput *
__qmi_message_dms_get_software_version_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsGetSoftwareVersionOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION, NULL);

    self = g_slice_new0 (QmiMessageDmsGetSoftwareVersionOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_get_software_version_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    do {
        /* Prerequisite.... */
        if (!(self->arg_result.error_status == QMI_STATUS_SUCCESS))
            break;

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION_OUTPUT_TLV_VERSION,
                                              &buffer_len);
            if (buffer && qmi_message_dms_get_software_version_output_version_validate (buffer, buffer_len)) {
                self->arg_version_set = TRUE;

                /* Read the string variable from the buffer */
                qmi_utils_read_string_from_buffer (
                    &buffer,
                    &buffer_len,
                    0,
                    0,
                    &(self->arg_version));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Version' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Version TLV: Not found");
                qmi_message_dms_get_software_version_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* REQUEST/RESPONSE: Qmi Message DMS Set Service Programming Code */


/* --- Input -- */

struct _QmiMessageDmsSetServiceProgrammingCodeInput {
    volatile gint ref_count;

    /* New */
    gboolean arg_new_set;
    gchar arg_new[7];

    /* Current */
    gboolean arg_current_set;
    gchar arg_current[7];
};

#define QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_INPUT_TLV_NEW 0x02
#define QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_INPUT_TLV_CURRENT 0x01

/**
 * qmi_message_dms_set_service_programming_code_input_get_new:
 * @self: a #QmiMessageDmsSetServiceProgrammingCodeInput.
 * @new: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'New' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_service_programming_code_input_get_new (
    QmiMessageDmsSetServiceProgrammingCodeInput *self,
    const gchar **new,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_new_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'New' was not found in the message");
        return FALSE;
    }

    if (new)
        *new = self->arg_new;

    return TRUE;
}

/**
 * qmi_message_dms_set_service_programming_code_input_set_new:
 * @self: a #QmiMessageDmsSetServiceProgrammingCodeInput.
 * @new: a constant string of exactly 6 characters.
 * @error: Return location for error or %NULL.
 *
 * Set the 'New' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_service_programming_code_input_set_new (
    QmiMessageDmsSetServiceProgrammingCodeInput *self,
    const gchar *new,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!new || strlen (new) != 6) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'new' must be 6 characters long");
        return FALSE;
    }
    memcpy (self->arg_new, new, 6);
    self->arg_new[6] = '\0';
    self->arg_new_set = TRUE;

    return TRUE;
}

/**
 * qmi_message_dms_set_service_programming_code_input_get_current:
 * @self: a #QmiMessageDmsSetServiceProgrammingCodeInput.
 * @current: a placeholder for the output constant string, or %NULL if not required.
 * @error: Return location for error or %NULL.
 *
 * Get the 'Current' field from @self.
 *
 * Returns: %TRUE if the field is found, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_service_programming_code_input_get_current (
    QmiMessageDmsSetServiceProgrammingCodeInput *self,
    const gchar **current,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!self->arg_current_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_TLV_NOT_FOUND,
                     "Field 'Current' was not found in the message");
        return FALSE;
    }

    if (current)
        *current = self->arg_current;

    return TRUE;
}

/**
 * qmi_message_dms_set_service_programming_code_input_set_current:
 * @self: a #QmiMessageDmsSetServiceProgrammingCodeInput.
 * @current: a constant string of exactly 6 characters.
 * @error: Return location for error or %NULL.
 *
 * Set the 'Current' field in the message.
 *
 * Returns: %TRUE if @value was successfully set, %FALSE otherwise.
 */
gboolean
qmi_message_dms_set_service_programming_code_input_set_current (
    QmiMessageDmsSetServiceProgrammingCodeInput *self,
    const gchar *current,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    if (!current || strlen (current) != 6) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Input variable 'current' must be 6 characters long");
        return FALSE;
    }
    memcpy (self->arg_current, current, 6);
    self->arg_current[6] = '\0';
    self->arg_current_set = TRUE;

    return TRUE;
}

GType
qmi_message_dms_set_service_programming_code_input_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetServiceProgrammingCodeInput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_service_programming_code_input_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_service_programming_code_input_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_service_programming_code_input_ref:
 * @self: a #QmiMessageDmsSetServiceProgrammingCodeInput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetServiceProgrammingCodeInput *
qmi_message_dms_set_service_programming_code_input_ref (QmiMessageDmsSetServiceProgrammingCodeInput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_service_programming_code_input_unref:
 * @self: a #QmiMessageDmsSetServiceProgrammingCodeInput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_service_programming_code_input_unref (QmiMessageDmsSetServiceProgrammingCodeInput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetServiceProgrammingCodeInput, self);
    }
}

/**
 * qmi_message_dms_set_service_programming_code_input_new:
 *
 * Allocates a new #QmiMessageDmsSetServiceProgrammingCodeInput.
 *
 * Returns: the newly created #QmiMessageDmsSetServiceProgrammingCodeInput. The returned value should be freed with qmi_message_dms_set_service_programming_code_input_unref().
 */
QmiMessageDmsSetServiceProgrammingCodeInput *
qmi_message_dms_set_service_programming_code_input_new (void)
{
    QmiMessageDmsSetServiceProgrammingCodeInput *self;

    self = g_slice_new0 (QmiMessageDmsSetServiceProgrammingCodeInput);
    self->ref_count = 1;
    return self;
}

static QmiMessage *
__qmi_message_dms_set_service_programming_code_request_create (
    guint8 transaction_id,
    guint8 cid,
    QmiMessageDmsSetServiceProgrammingCodeInput *input,
    GError **error)
{
    QmiMessage *self;

    self = qmi_message_new (QMI_SERVICE_DMS,
                            cid,
                            transaction_id,
                            QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE);

    /* There is at least one mandatory TLV, don't allow NULL input */
    if (!input) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Message 'Set Service Programming Code' has mandatory TLVs");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'New' TLV */
    if (input->arg_new_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the fixed-size string variable to the buffer */
        qmi_utils_write_fixed_size_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            6,
            input->arg_new);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_INPUT_TLV_NEW,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the New TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'New' in message 'Set Service Programming Code'");
        qmi_message_unref (self);
        return NULL;
    }

    /* Try to add the 'Current' TLV */
    if (input->arg_current_set) {
        guint8 buffer[1024];
        guint16 buffer_len = 1024;
        guint8 *buffer_aux = buffer;

        /* Write the fixed-size string variable to the buffer */
        qmi_utils_write_fixed_size_string_to_buffer (
            &buffer_aux,
            &buffer_len,
            6,
            input->arg_current);

        if (!qmi_message_add_raw_tlv (self,
                                      (guint8)QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_INPUT_TLV_CURRENT,
                                      buffer,
                                      (1024 - buffer_len),
                                      error)) {
            g_prefix_error (error, "Couldn't set the Current TLV: ");
            qmi_message_unref (self);
            return NULL;
        }
    } else {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_ARGS,
                     "Missing mandatory TLV 'Current' in message 'Set Service Programming Code'");
        qmi_message_unref (self);
        return NULL;
    }

    return self;
}

/* --- Output -- */

struct _QmiMessageDmsSetServiceProgrammingCodeOutput {
    volatile gint ref_count;

    /* Result */
    gboolean arg_result_set;
    QmiMessageResult arg_result;
};

#define QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_OUTPUT_TLV_RESULT 0x02

/**
 * qmi_message_dms_set_service_programming_code_output_get_result:
 * @self: a QmiMessageDmsSetServiceProgrammingCodeOutput.
 * @error: Return location for error or %NULL.
 *
 * Get the result of the QMI operation.
 *
 * Returns: %TRUE if the QMI operation succeeded, %FALSE if @error is set.
 */
gboolean
qmi_message_dms_set_service_programming_code_output_get_result (
    QmiMessageDmsSetServiceProgrammingCodeOutput *self,
    GError **error)
{
    g_return_val_if_fail (self != NULL, FALSE);

    /* We should always have a result set in the response message */
    if (!self->arg_result_set) {
        g_set_error (error,
                     QMI_CORE_ERROR,
                     QMI_CORE_ERROR_INVALID_MESSAGE,
                     "No 'Result' field given in the message");
        return FALSE;
    }

    if (self->arg_result.error_status == QMI_STATUS_SUCCESS) {
        /* Operation succeeded */
        return TRUE;
    }

    /* Report a QMI protocol error */
    g_set_error (error,
                 QMI_PROTOCOL_ERROR,
                 (QmiProtocolError) self->arg_result.error_code,
                 "QMI protocol error (%u): '%s'",
                 self->arg_result.error_code,
                 qmi_protocol_error_get_string ((QmiProtocolError) self->arg_result.error_code));
    return FALSE;
}

GType
qmi_message_dms_set_service_programming_code_output_get_type (void)
{
    static volatile gsize g_define_type_id__volatile = 0;

    if (g_once_init_enter (&g_define_type_id__volatile)) {
        GType g_define_type_id =
            g_boxed_type_register_static (g_intern_static_string ("QmiMessageDmsSetServiceProgrammingCodeOutput"),
                                          (GBoxedCopyFunc) qmi_message_dms_set_service_programming_code_output_ref,
                                          (GBoxedFreeFunc) qmi_message_dms_set_service_programming_code_output_unref);

        g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
    }

    return g_define_type_id__volatile;
}

/**
 * qmi_message_dms_set_service_programming_code_output_ref:
 * @self: a #QmiMessageDmsSetServiceProgrammingCodeOutput.
 *
 * Atomically increments the reference count of @self by one.
 *
 * Returns: the new reference to @self.
 */
QmiMessageDmsSetServiceProgrammingCodeOutput *
qmi_message_dms_set_service_programming_code_output_ref (QmiMessageDmsSetServiceProgrammingCodeOutput *self)
{
    g_return_val_if_fail (self != NULL, NULL);

    g_atomic_int_inc (&self->ref_count);
    return self;
}

/**
 * qmi_message_dms_set_service_programming_code_output_unref:
 * @self: a #QmiMessageDmsSetServiceProgrammingCodeOutput.
 *
 * Atomically decrements the reference count of @self by one.
 * If the reference count drops to 0, @self is completely disposed.
 */
void
qmi_message_dms_set_service_programming_code_output_unref (QmiMessageDmsSetServiceProgrammingCodeOutput *self)
{
    g_return_if_fail (self != NULL);

    if (g_atomic_int_dec_and_test (&self->ref_count)) {
        g_slice_free (QmiMessageDmsSetServiceProgrammingCodeOutput, self);
    }
}

static gboolean
qmi_message_dms_set_service_programming_code_input_new_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 6;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'New' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'New' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_service_programming_code_input_new_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_INPUT_TLV_NEW,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_service_programming_code_input_new_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar tmp[7];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                6,
                &tmp[0]);
            tmp[6] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'New' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

static gboolean
qmi_message_dms_set_service_programming_code_input_current_validate (
    const guint8 *buffer,
    guint16 buffer_len)
{
    guint expected_len = 0;

    expected_len += 6;

    if (buffer_len < expected_len) {
        g_warning ("Cannot read the 'Current' TLV: expected '%u' bytes, but only got '%u' bytes",
                   expected_len, buffer_len);
        return FALSE;
    }

    if (buffer_len > expected_len) {
        g_debug ("Reading the 'Current' TLV: expected '%u' bytes, but got '%u' bytes",
                 expected_len, buffer_len);
        return TRUE;
    }

    return TRUE;
}


static gchar *
qmi_message_dms_set_service_programming_code_input_current_get_printable (
    QmiMessage *message,
    const gchar *line_prefix)
{
    const guint8 *buffer;
    guint16 buffer_len;

    buffer = qmi_message_get_raw_tlv (message,
                                      QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_INPUT_TLV_CURRENT,
                                      &buffer_len);
    if (buffer && qmi_message_dms_set_service_programming_code_input_current_validate (buffer, buffer_len)) {
        GString *printable;

        printable = g_string_new ("");

        {
            gchar tmp[7];

            /* Read the fixed-size string variable from the buffer */
            qmi_utils_read_fixed_size_string_from_buffer (
                &buffer,
                &buffer_len,
                6,
                &tmp[0]);
            tmp[6] = '\0';

            g_string_append_printf (printable, "%s", tmp);
        }

        /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
        if (buffer_len > 0) {
            g_warning ("Left '%u' bytes unread when getting the 'Current' TLV as printable", buffer_len);
        }

        return g_string_free (printable, FALSE);
    }

    return NULL;
}

struct message_set_service_programming_code_context {
    QmiMessage *self;
    const gchar *line_prefix;
    GString *printable;
};

static void
message_set_service_programming_code_get_tlv_printable (
    guint8 type,
    const guint8 *value,
    gsize length,
    struct message_set_service_programming_code_context *ctx)
{
    const gchar *tlv_type_str = NULL;
    gchar *translated_value;

    if (!qmi_message_is_response (ctx->self)) {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_INPUT_TLV_NEW:
            tlv_type_str = "New";
            translated_value = qmi_message_dms_set_service_programming_code_input_new_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        case QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_INPUT_TLV_CURRENT:
            tlv_type_str = "Current";
            translated_value = qmi_message_dms_set_service_programming_code_input_current_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    } else {
        switch (type) {
        case QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_OUTPUT_TLV_RESULT:
            tlv_type_str = "Result";
            translated_value = qmi_message_result_get_printable (
                                   ctx->self,
                                   ctx->line_prefix);
            break;
        default:
            break;
        }
    }

    if (!tlv_type_str) {
        gchar *value_str = NULL;

        value_str = qmi_message_get_tlv_printable (ctx->self,
                                                   ctx->line_prefix,
                                                   type,
                                                   value,
                                                   length);
        g_string_append (ctx->printable, value_str);
        g_free (value_str);
    } else {
        gchar *value_hex;

        value_hex = __qmi_utils_str_hex (value, length, ':');
        g_string_append_printf (ctx->printable,
                                "%sTLV:\n"
                                "%s  type       = \"%s\" (0x%02x)\n"
                                "%s  length     = %" G_GSIZE_FORMAT "\n"
                                "%s  value      = %s\n"
                                "%s  translated = %s\n",
                                ctx->line_prefix,
                                ctx->line_prefix, tlv_type_str, type,
                                ctx->line_prefix, length,
                                ctx->line_prefix, value_hex,
                                ctx->line_prefix, translated_value ? translated_value : "");
        g_free (value_hex);
        g_free (translated_value);
    }
}

static gchar *
message_set_service_programming_code_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    GString *printable;

    printable = g_string_new ("");
    g_string_append_printf (printable,
                            "%s  message     = \"Set Service Programming Code\" (0x0052)\n",
                            line_prefix);

    {
        struct message_set_service_programming_code_context ctx;
        ctx.self = self;
        ctx.line_prefix = line_prefix;
        ctx.printable = printable;
        qmi_message_foreach_raw_tlv (self,
                                     (QmiMessageForeachRawTlvFn)message_set_service_programming_code_get_tlv_printable,
                                     &ctx);
    }

    return g_string_free (printable, FALSE);
}

static QmiMessageDmsSetServiceProgrammingCodeOutput *
__qmi_message_dms_set_service_programming_code_response_parse (
    QmiMessage *message,
    GError **error)
{
    QmiMessageDmsSetServiceProgrammingCodeOutput *self;

    g_return_val_if_fail (qmi_message_get_message_id (message) == QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE, NULL);

    self = g_slice_new0 (QmiMessageDmsSetServiceProgrammingCodeOutput);
    self->ref_count = 1;

    do {
        /* No Prerequisites for field */

        {
            const guint8 *buffer;
            guint16 buffer_len;

            buffer = qmi_message_get_raw_tlv (message,
                                              QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE_OUTPUT_TLV_RESULT,
                                              &buffer_len);
            if (buffer && qmi_message_result_validate (buffer, buffer_len)) {
                self->arg_result_set = TRUE;

                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_status));
                /* Read the guint16 variable from the buffer */
                qmi_utils_read_guint16_from_buffer (
                    &buffer,
                    &buffer_len,
                    QMI_ENDIAN_LITTLE,
                    &(self->arg_result.error_code));

                /* The remaining size of the buffer needs to be 0 if we successfully read the TLV */
                if (buffer_len > 0) {
                    g_warning ("Left '%u' bytes unread when getting the 'Result' TLV", buffer_len);
                }
            } else {
                g_set_error (error,
                             QMI_CORE_ERROR,
                             QMI_CORE_ERROR_TLV_NOT_FOUND,
                             "Couldn't get the Result TLV: Not found");
                qmi_message_dms_set_service_programming_code_output_unref (self);
                return NULL;
            }

        }
    } while (0);

    return self;
}

/*****************************************************************************/
/* Service-specific printable: DMS */


gchar *
__qmi_message_dms_get_printable (
    QmiMessage *self,
    const gchar *line_prefix)
{
    if (qmi_message_is_indication (self)) {
        switch (qmi_message_get_message_id (self)) {
        case QMI_INDICATION_DMS_EVENT_REPORT:
            return indication_event_report_get_printable (self, line_prefix);
         default:
             return NULL;
        }
    } else {
        switch (qmi_message_get_message_id (self)) {
        case QMI_MESSAGE_DMS_RESET:
            return message_reset_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_SET_EVENT_REPORT:
            return message_set_event_report_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_CAPABILITIES:
            return message_get_capabilities_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_MANUFACTURER:
            return message_get_manufacturer_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_MODEL:
            return message_get_model_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_REVISION:
            return message_get_revision_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_MSISDN:
            return message_get_msisdn_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_IDS:
            return message_get_ids_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_POWER_STATE:
            return message_get_power_state_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION:
            return message_uim_set_pin_protection_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_VERIFY_PIN:
            return message_uim_verify_pin_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN:
            return message_uim_unblock_pin_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_CHANGE_PIN:
            return message_uim_change_pin_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS:
            return message_uim_get_pin_status_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_HARDWARE_REVISION:
            return message_get_hardware_revision_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_OPERATING_MODE:
            return message_get_operating_mode_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_SET_OPERATING_MODE:
            return message_set_operating_mode_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_TIME:
            return message_get_time_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_PRL_VERSION:
            return message_get_prl_version_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_ACTIVATION_STATE:
            return message_get_activation_state_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC:
            return message_activate_automatic_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_ACTIVATE_MANUAL:
            return message_activate_manual_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_USER_LOCK_STATE:
            return message_get_user_lock_state_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_SET_USER_LOCK_STATE:
            return message_set_user_lock_state_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_SET_USER_LOCK_CODE:
            return message_set_user_lock_code_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_READ_USER_DATA:
            return message_read_user_data_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_WRITE_USER_DATA:
            return message_write_user_data_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_READ_ERI_FILE:
            return message_read_eri_file_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS:
            return message_restore_factory_defaults_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE:
            return message_validate_service_programming_code_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_GET_ICCID:
            return message_uim_get_iccid_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_GET_CK_STATUS:
            return message_uim_get_ck_status_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION:
            return message_uim_set_ck_protection_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_UNBLOCK_CK:
            return message_uim_unblock_ck_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_GET_IMSI:
            return message_uim_get_imsi_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_UIM_GET_STATE:
            return message_uim_get_state_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES:
            return message_get_band_capabilities_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_FACTORY_SKU:
            return message_get_factory_sku_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE:
            return message_get_firmware_preference_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE:
            return message_set_firmware_preference_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_LIST_STORED_IMAGES:
            return message_list_stored_images_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_DELETE_STORED_IMAGE:
            return message_delete_stored_image_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_SET_TIME:
            return message_set_time_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO:
            return message_get_stored_image_info_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG:
            return message_get_alt_net_config_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG:
            return message_set_alt_net_config_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION:
            return message_get_software_version_get_printable (self, line_prefix);
        case QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE:
            return message_set_service_programming_code_get_printable (self, line_prefix);
         default:
             return NULL;
        }
    }
}

gboolean
__qmi_message_dms_get_version_introduced (
    QmiMessage *self,
    guint *major,
    guint *minor)
{
    switch (qmi_message_get_message_id (self)) {
    case QMI_MESSAGE_DMS_RESET:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_DMS_SET_EVENT_REPORT:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_CAPABILITIES:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_MANUFACTURER:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_MODEL:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_REVISION:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_MSISDN:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_IDS:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_POWER_STATE:
        *major = 1;
        *minor = 0;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_SET_PIN_PROTECTION:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_VERIFY_PIN:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_UNBLOCK_PIN:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_CHANGE_PIN:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_GET_PIN_STATUS:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_HARDWARE_REVISION:
        *major = 1;
        *minor = 2;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_OPERATING_MODE:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_DMS_SET_OPERATING_MODE:
        *major = 1;
        *minor = 1;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_TIME:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_PRL_VERSION:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_ACTIVATION_STATE:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_ACTIVATE_AUTOMATIC:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_ACTIVATE_MANUAL:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_USER_LOCK_STATE:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_SET_USER_LOCK_STATE:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_SET_USER_LOCK_CODE:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_READ_USER_DATA:
        *major = 1;
        *minor = 6;
        return TRUE;
    case QMI_MESSAGE_DMS_WRITE_USER_DATA:
        *major = 1;
        *minor = 6;
        return TRUE;
    case QMI_MESSAGE_DMS_READ_ERI_FILE:
        *major = 1;
        *minor = 6;
        return TRUE;
    case QMI_MESSAGE_DMS_RESTORE_FACTORY_DEFAULTS:
        *major = 1;
        *minor = 6;
        return TRUE;
    case QMI_MESSAGE_DMS_VALIDATE_SERVICE_PROGRAMMING_CODE:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_GET_ICCID:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_GET_CK_STATUS:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_SET_CK_PROTECTION:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_UNBLOCK_CK:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_GET_IMSI:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_UIM_GET_STATE:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_BAND_CAPABILITIES:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_FACTORY_SKU:
        *major = 1;
        *minor = 6;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_FIRMWARE_PREFERENCE:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_SET_FIRMWARE_PREFERENCE:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_LIST_STORED_IMAGES:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_DELETE_STORED_IMAGE:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_SET_TIME:
        *major = 1;
        *minor = 4;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_STORED_IMAGE_INFO:
        *major = 1;
        *minor = 3;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_ALT_NET_CONFIG:
        *major = 1;
        *minor = 6;
        return TRUE;
    case QMI_MESSAGE_DMS_SET_ALT_NET_CONFIG:
        *major = 1;
        *minor = 6;
        return TRUE;
    case QMI_MESSAGE_DMS_GET_SOFTWARE_VERSION:
        *major = 1;
        *minor = 5;
        return TRUE;
    case QMI_MESSAGE_DMS_SET_SERVICE_PROGRAMMING_CODE:
        *major = 1;
        *minor = 5;
        return TRUE;
    default:
        return FALSE;
    }
}

/*****************************************************************************/
/* CLIENT: QMI Client DMS */


/**
 * SECTION: qmi-client-dms
 * @title: QmiClientDms
 * @short_description: #QmiClient for the DMS service.
 *
 * #QmiClient which handles operations in the DMS service.
 */

G_DEFINE_TYPE (QmiClientDms, qmi_client_dms, QMI_TYPE_CLIENT);

enum {
    SIGNAL_EVENT_REPORT,
    SIGNAL_LAST
};

static guint signals[SIGNAL_LAST] = { 0 };

static void
process_indication (QmiClient *self,
                    QmiMessage *message)
{
    switch (qmi_message_get_message_id (message)) {
        case QMI_INDICATION_DMS_EVENT_REPORT: {
            QmiIndicationDmsEventReportOutput *output;
            GError *error = NULL;

            /* Parse indication */
            output = __qmi_indication_dms_event_report_indication_parse (message, &error);
            if (!output) {
                g_warning ("Couldn't parse 'Event Report' indication: %s",
                           error ? error->message : "Unknown error");
                if (error)
                    g_error_free (error);
            } else {
                g_signal_emit (self, signals[SIGNAL_EVENT_REPORT], 0, output);
                qmi_indication_dms_event_report_output_unref (output);
            }
            break;
        }
        default:
            break;
    }
}

static void
qmi_client_dms_init (QmiClientDms *self)
{
}

static void
qmi_client_dms_class_init (QmiClientDmsClass *klass)
{
    QmiClientClass *client_class = QMI_CLIENT_CLASS (klass);

    client_class->process_indication = process_indication;

    /**
     * QmiClientDms::event-report:
     * @object: A #QmiClientDms.
     * @output: A #QmiIndicationDmsEventReportOutput.
     *
     * The ::event-report signal gets emitted when a '<link linkend="libqmi-glib-DMS-Event-Report.top_of_page">Event Report</link>' indication is received.
     */
    signals[SIGNAL_EVENT_REPORT] =
        g_signal_new ("event-report",
                      G_OBJECT_CLASS_TYPE (G_OBJECT_CLASS (klass)),
                      G_SIGNAL_RUN_LAST,
                      0,
                      NULL,
                      NULL,
                      NULL,
                      G_TYPE_NONE,
                      1,
                      QMI_TYPE_INDICATION_DMS_EVENT_REPORT_OUTPUT);
}


/**
 * qmi_client_dms_reset_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_reset().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_reset().
 *
 * Returns: a #QmiMessageDmsResetOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_reset_output_unref().
 */
QmiMessageDmsResetOutput *
qmi_client_dms_reset_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_reset_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
reset_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsResetOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_reset_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_reset_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_reset:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Reset request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_reset_finish() to get the result of the operation.
 */
void
qmi_client_dms_reset (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_reset);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_reset_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)reset_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_set_event_report_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_event_report().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_set_event_report().
 *
 * Returns: a #QmiMessageDmsSetEventReportOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_event_report_output_unref().
 */
QmiMessageDmsSetEventReportOutput *
qmi_client_dms_set_event_report_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_set_event_report_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_event_report_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsSetEventReportOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_set_event_report_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_set_event_report_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_set_event_report:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsSetEventReportInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set Event Report request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_set_event_report_finish() to get the result of the operation.
 */
void
qmi_client_dms_set_event_report (
    QmiClientDms *self,
    QmiMessageDmsSetEventReportInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_set_event_report);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_set_event_report_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_event_report_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_capabilities_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_capabilities().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_capabilities().
 *
 * Returns: a #QmiMessageDmsGetCapabilitiesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_capabilities_output_unref().
 */
QmiMessageDmsGetCapabilitiesOutput *
qmi_client_dms_get_capabilities_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_capabilities_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_capabilities_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetCapabilitiesOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_capabilities_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_capabilities_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_capabilities:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Capabilities request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_capabilities_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_capabilities (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_capabilities);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_capabilities_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_capabilities_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_manufacturer_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_manufacturer().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_manufacturer().
 *
 * Returns: a #QmiMessageDmsGetManufacturerOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_manufacturer_output_unref().
 */
QmiMessageDmsGetManufacturerOutput *
qmi_client_dms_get_manufacturer_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_manufacturer_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_manufacturer_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetManufacturerOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_manufacturer_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_manufacturer_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_manufacturer:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Manufacturer request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_manufacturer_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_manufacturer (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_manufacturer);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_manufacturer_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_manufacturer_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_model_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_model().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_model().
 *
 * Returns: a #QmiMessageDmsGetModelOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_model_output_unref().
 */
QmiMessageDmsGetModelOutput *
qmi_client_dms_get_model_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_model_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_model_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetModelOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_model_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_model_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_model:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Model request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_model_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_model (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_model);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_model_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_model_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_revision_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_revision().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_revision().
 *
 * Returns: a #QmiMessageDmsGetRevisionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_revision_output_unref().
 */
QmiMessageDmsGetRevisionOutput *
qmi_client_dms_get_revision_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_revision_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_revision_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetRevisionOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_revision_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_revision_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_revision:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Revision request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_revision_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_revision (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_revision);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_revision_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_revision_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_msisdn_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_msisdn().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_msisdn().
 *
 * Returns: a #QmiMessageDmsGetMsisdnOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_msisdn_output_unref().
 */
QmiMessageDmsGetMsisdnOutput *
qmi_client_dms_get_msisdn_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_msisdn_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_msisdn_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetMsisdnOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_msisdn_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_msisdn_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_msisdn:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get MSISDN request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_msisdn_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_msisdn (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_msisdn);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_msisdn_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_msisdn_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_ids_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_ids().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_ids().
 *
 * Returns: a #QmiMessageDmsGetIdsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_ids_output_unref().
 */
QmiMessageDmsGetIdsOutput *
qmi_client_dms_get_ids_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_ids_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_ids_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetIdsOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_ids_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_ids_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_ids:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get IDs request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_ids_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_ids (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_ids);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_ids_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_ids_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_power_state_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_power_state().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_power_state().
 *
 * Returns: a #QmiMessageDmsGetPowerStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_power_state_output_unref().
 */
QmiMessageDmsGetPowerStateOutput *
qmi_client_dms_get_power_state_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_power_state_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_power_state_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetPowerStateOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_power_state_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_power_state_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_power_state:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Power State request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_power_state_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_power_state (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_power_state);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_power_state_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_power_state_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_set_pin_protection_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_set_pin_protection().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_set_pin_protection().
 *
 * Returns: a #QmiMessageDmsUimSetPinProtectionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_set_pin_protection_output_unref().
 */
QmiMessageDmsUimSetPinProtectionOutput *
qmi_client_dms_uim_set_pin_protection_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_set_pin_protection_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_set_pin_protection_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimSetPinProtectionOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_set_pin_protection_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_set_pin_protection_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_set_pin_protection:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsUimSetPinProtectionInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Set PIN Protection request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_set_pin_protection_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_set_pin_protection (
    QmiClientDms *self,
    QmiMessageDmsUimSetPinProtectionInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_set_pin_protection);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_set_pin_protection_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_set_pin_protection_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_verify_pin_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_verify_pin().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_verify_pin().
 *
 * Returns: a #QmiMessageDmsUimVerifyPinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_verify_pin_output_unref().
 */
QmiMessageDmsUimVerifyPinOutput *
qmi_client_dms_uim_verify_pin_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_verify_pin_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_verify_pin_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimVerifyPinOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_verify_pin_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_verify_pin_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_verify_pin:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsUimVerifyPinInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Verify PIN request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_verify_pin_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_verify_pin (
    QmiClientDms *self,
    QmiMessageDmsUimVerifyPinInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_verify_pin);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_verify_pin_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_verify_pin_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_unblock_pin_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_unblock_pin().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_unblock_pin().
 *
 * Returns: a #QmiMessageDmsUimUnblockPinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_unblock_pin_output_unref().
 */
QmiMessageDmsUimUnblockPinOutput *
qmi_client_dms_uim_unblock_pin_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_unblock_pin_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_unblock_pin_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimUnblockPinOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_unblock_pin_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_unblock_pin_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_unblock_pin:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsUimUnblockPinInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Unblock PIN request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_unblock_pin_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_unblock_pin (
    QmiClientDms *self,
    QmiMessageDmsUimUnblockPinInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_unblock_pin);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_unblock_pin_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_unblock_pin_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_change_pin_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_change_pin().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_change_pin().
 *
 * Returns: a #QmiMessageDmsUimChangePinOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_change_pin_output_unref().
 */
QmiMessageDmsUimChangePinOutput *
qmi_client_dms_uim_change_pin_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_change_pin_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_change_pin_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimChangePinOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_change_pin_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_change_pin_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_change_pin:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsUimChangePinInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Change PIN request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_change_pin_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_change_pin (
    QmiClientDms *self,
    QmiMessageDmsUimChangePinInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_change_pin);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_change_pin_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_change_pin_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_get_pin_status_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_pin_status().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_get_pin_status().
 *
 * Returns: a #QmiMessageDmsUimGetPinStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_pin_status_output_unref().
 */
QmiMessageDmsUimGetPinStatusOutput *
qmi_client_dms_uim_get_pin_status_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_get_pin_status_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_get_pin_status_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimGetPinStatusOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_get_pin_status_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_get_pin_status_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_get_pin_status:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Get PIN Status request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_get_pin_status_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_get_pin_status (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_get_pin_status);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_get_pin_status_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_get_pin_status_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_hardware_revision_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_hardware_revision().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_hardware_revision().
 *
 * Returns: a #QmiMessageDmsGetHardwareRevisionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_hardware_revision_output_unref().
 */
QmiMessageDmsGetHardwareRevisionOutput *
qmi_client_dms_get_hardware_revision_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_hardware_revision_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_hardware_revision_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetHardwareRevisionOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_hardware_revision_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_hardware_revision_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_hardware_revision:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Hardware Revision request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_hardware_revision_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_hardware_revision (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_hardware_revision);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_hardware_revision_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_hardware_revision_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_operating_mode_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_operating_mode().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_operating_mode().
 *
 * Returns: a #QmiMessageDmsGetOperatingModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_operating_mode_output_unref().
 */
QmiMessageDmsGetOperatingModeOutput *
qmi_client_dms_get_operating_mode_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_operating_mode_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_operating_mode_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetOperatingModeOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_operating_mode_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_operating_mode_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_operating_mode:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Operating Mode request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_operating_mode_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_operating_mode (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_operating_mode);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_operating_mode_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_operating_mode_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_set_operating_mode_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_operating_mode().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_set_operating_mode().
 *
 * Returns: a #QmiMessageDmsSetOperatingModeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_operating_mode_output_unref().
 */
QmiMessageDmsSetOperatingModeOutput *
qmi_client_dms_set_operating_mode_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_set_operating_mode_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_operating_mode_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsSetOperatingModeOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_set_operating_mode_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_set_operating_mode_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_set_operating_mode:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsSetOperatingModeInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set Operating Mode request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_set_operating_mode_finish() to get the result of the operation.
 */
void
qmi_client_dms_set_operating_mode (
    QmiClientDms *self,
    QmiMessageDmsSetOperatingModeInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_set_operating_mode);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_set_operating_mode_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_operating_mode_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_time_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_time().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_time().
 *
 * Returns: a #QmiMessageDmsGetTimeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_time_output_unref().
 */
QmiMessageDmsGetTimeOutput *
qmi_client_dms_get_time_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_time_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_time_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetTimeOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_time_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_time_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_time:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Time request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_time_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_time (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_time);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_time_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_time_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_prl_version_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_prl_version().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_prl_version().
 *
 * Returns: a #QmiMessageDmsGetPrlVersionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_prl_version_output_unref().
 */
QmiMessageDmsGetPrlVersionOutput *
qmi_client_dms_get_prl_version_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_prl_version_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_prl_version_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetPrlVersionOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_prl_version_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_prl_version_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_prl_version:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get PRL Version request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_prl_version_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_prl_version (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_prl_version);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_prl_version_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_prl_version_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_activation_state_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_activation_state().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_activation_state().
 *
 * Returns: a #QmiMessageDmsGetActivationStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_activation_state_output_unref().
 */
QmiMessageDmsGetActivationStateOutput *
qmi_client_dms_get_activation_state_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_activation_state_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_activation_state_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetActivationStateOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_activation_state_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_activation_state_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_activation_state:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Activation State request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_activation_state_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_activation_state (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_activation_state);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_activation_state_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_activation_state_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_activate_automatic_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_activate_automatic().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_activate_automatic().
 *
 * Returns: a #QmiMessageDmsActivateAutomaticOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_activate_automatic_output_unref().
 */
QmiMessageDmsActivateAutomaticOutput *
qmi_client_dms_activate_automatic_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_activate_automatic_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
activate_automatic_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsActivateAutomaticOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_activate_automatic_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_activate_automatic_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_activate_automatic:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsActivateAutomaticInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Activate Automatic request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_activate_automatic_finish() to get the result of the operation.
 */
void
qmi_client_dms_activate_automatic (
    QmiClientDms *self,
    QmiMessageDmsActivateAutomaticInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_activate_automatic);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_activate_automatic_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)activate_automatic_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_activate_manual_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_activate_manual().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_activate_manual().
 *
 * Returns: a #QmiMessageDmsActivateManualOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_activate_manual_output_unref().
 */
QmiMessageDmsActivateManualOutput *
qmi_client_dms_activate_manual_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_activate_manual_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
activate_manual_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsActivateManualOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_activate_manual_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_activate_manual_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_activate_manual:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsActivateManualInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Activate Manual request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_activate_manual_finish() to get the result of the operation.
 */
void
qmi_client_dms_activate_manual (
    QmiClientDms *self,
    QmiMessageDmsActivateManualInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_activate_manual);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_activate_manual_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)activate_manual_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_user_lock_state_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_user_lock_state().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_user_lock_state().
 *
 * Returns: a #QmiMessageDmsGetUserLockStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_user_lock_state_output_unref().
 */
QmiMessageDmsGetUserLockStateOutput *
qmi_client_dms_get_user_lock_state_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_user_lock_state_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_user_lock_state_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetUserLockStateOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_user_lock_state_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_user_lock_state_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_user_lock_state:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get User Lock State request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_user_lock_state_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_user_lock_state (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_user_lock_state);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_user_lock_state_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_user_lock_state_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_set_user_lock_state_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_user_lock_state().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_set_user_lock_state().
 *
 * Returns: a #QmiMessageDmsSetUserLockStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_user_lock_state_output_unref().
 */
QmiMessageDmsSetUserLockStateOutput *
qmi_client_dms_set_user_lock_state_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_set_user_lock_state_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_user_lock_state_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsSetUserLockStateOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_set_user_lock_state_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_set_user_lock_state_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_set_user_lock_state:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsSetUserLockStateInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set User Lock State request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_set_user_lock_state_finish() to get the result of the operation.
 */
void
qmi_client_dms_set_user_lock_state (
    QmiClientDms *self,
    QmiMessageDmsSetUserLockStateInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_set_user_lock_state);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_set_user_lock_state_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_user_lock_state_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_set_user_lock_code_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_user_lock_code().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_set_user_lock_code().
 *
 * Returns: a #QmiMessageDmsSetUserLockCodeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_user_lock_code_output_unref().
 */
QmiMessageDmsSetUserLockCodeOutput *
qmi_client_dms_set_user_lock_code_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_set_user_lock_code_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_user_lock_code_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsSetUserLockCodeOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_set_user_lock_code_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_set_user_lock_code_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_set_user_lock_code:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsSetUserLockCodeInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set User Lock Code request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_set_user_lock_code_finish() to get the result of the operation.
 */
void
qmi_client_dms_set_user_lock_code (
    QmiClientDms *self,
    QmiMessageDmsSetUserLockCodeInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_set_user_lock_code);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_set_user_lock_code_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_user_lock_code_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_read_user_data_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_read_user_data().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_read_user_data().
 *
 * Returns: a #QmiMessageDmsReadUserDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_read_user_data_output_unref().
 */
QmiMessageDmsReadUserDataOutput *
qmi_client_dms_read_user_data_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_read_user_data_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
read_user_data_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsReadUserDataOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_read_user_data_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_read_user_data_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_read_user_data:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Read User Data request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_read_user_data_finish() to get the result of the operation.
 */
void
qmi_client_dms_read_user_data (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_read_user_data);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_read_user_data_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)read_user_data_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_write_user_data_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_write_user_data().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_write_user_data().
 *
 * Returns: a #QmiMessageDmsWriteUserDataOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_write_user_data_output_unref().
 */
QmiMessageDmsWriteUserDataOutput *
qmi_client_dms_write_user_data_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_write_user_data_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
write_user_data_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsWriteUserDataOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_write_user_data_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_write_user_data_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_write_user_data:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsWriteUserDataInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Write User Data request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_write_user_data_finish() to get the result of the operation.
 */
void
qmi_client_dms_write_user_data (
    QmiClientDms *self,
    QmiMessageDmsWriteUserDataInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_write_user_data);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_write_user_data_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)write_user_data_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_read_eri_file_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_read_eri_file().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_read_eri_file().
 *
 * Returns: a #QmiMessageDmsReadEriFileOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_read_eri_file_output_unref().
 */
QmiMessageDmsReadEriFileOutput *
qmi_client_dms_read_eri_file_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_read_eri_file_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
read_eri_file_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsReadEriFileOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_read_eri_file_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_read_eri_file_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_read_eri_file:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Read ERI File request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_read_eri_file_finish() to get the result of the operation.
 */
void
qmi_client_dms_read_eri_file (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_read_eri_file);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_read_eri_file_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)read_eri_file_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_restore_factory_defaults_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_restore_factory_defaults().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_restore_factory_defaults().
 *
 * Returns: a #QmiMessageDmsRestoreFactoryDefaultsOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_restore_factory_defaults_output_unref().
 */
QmiMessageDmsRestoreFactoryDefaultsOutput *
qmi_client_dms_restore_factory_defaults_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_restore_factory_defaults_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
restore_factory_defaults_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsRestoreFactoryDefaultsOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_restore_factory_defaults_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_restore_factory_defaults_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_restore_factory_defaults:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsRestoreFactoryDefaultsInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Restore Factory Defaults request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_restore_factory_defaults_finish() to get the result of the operation.
 */
void
qmi_client_dms_restore_factory_defaults (
    QmiClientDms *self,
    QmiMessageDmsRestoreFactoryDefaultsInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_restore_factory_defaults);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_restore_factory_defaults_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)restore_factory_defaults_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_validate_service_programming_code_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_validate_service_programming_code().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_validate_service_programming_code().
 *
 * Returns: a #QmiMessageDmsValidateServiceProgrammingCodeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_validate_service_programming_code_output_unref().
 */
QmiMessageDmsValidateServiceProgrammingCodeOutput *
qmi_client_dms_validate_service_programming_code_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_validate_service_programming_code_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
validate_service_programming_code_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsValidateServiceProgrammingCodeOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_validate_service_programming_code_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_validate_service_programming_code_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_validate_service_programming_code:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsValidateServiceProgrammingCodeInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Validate Service Programming Code request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_validate_service_programming_code_finish() to get the result of the operation.
 */
void
qmi_client_dms_validate_service_programming_code (
    QmiClientDms *self,
    QmiMessageDmsValidateServiceProgrammingCodeInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_validate_service_programming_code);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_validate_service_programming_code_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)validate_service_programming_code_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_get_iccid_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_iccid().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_get_iccid().
 *
 * Returns: a #QmiMessageDmsUimGetIccidOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_iccid_output_unref().
 */
QmiMessageDmsUimGetIccidOutput *
qmi_client_dms_uim_get_iccid_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_get_iccid_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_get_iccid_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimGetIccidOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_get_iccid_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_get_iccid_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_get_iccid:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Get ICCID request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_get_iccid_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_get_iccid (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_get_iccid);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_get_iccid_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_get_iccid_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_get_ck_status_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_ck_status().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_get_ck_status().
 *
 * Returns: a #QmiMessageDmsUimGetCkStatusOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_ck_status_output_unref().
 */
QmiMessageDmsUimGetCkStatusOutput *
qmi_client_dms_uim_get_ck_status_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_get_ck_status_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_get_ck_status_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimGetCkStatusOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_get_ck_status_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_get_ck_status_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_get_ck_status:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsUimGetCkStatusInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Get CK Status request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_get_ck_status_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_get_ck_status (
    QmiClientDms *self,
    QmiMessageDmsUimGetCkStatusInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_get_ck_status);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_get_ck_status_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_get_ck_status_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_set_ck_protection_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_set_ck_protection().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_set_ck_protection().
 *
 * Returns: a #QmiMessageDmsUimSetCkProtectionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_set_ck_protection_output_unref().
 */
QmiMessageDmsUimSetCkProtectionOutput *
qmi_client_dms_uim_set_ck_protection_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_set_ck_protection_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_set_ck_protection_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimSetCkProtectionOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_set_ck_protection_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_set_ck_protection_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_set_ck_protection:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsUimSetCkProtectionInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Set CK Protection request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_set_ck_protection_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_set_ck_protection (
    QmiClientDms *self,
    QmiMessageDmsUimSetCkProtectionInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_set_ck_protection);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_set_ck_protection_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_set_ck_protection_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_unblock_ck_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_unblock_ck().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_unblock_ck().
 *
 * Returns: a #QmiMessageDmsUimUnblockCkOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_unblock_ck_output_unref().
 */
QmiMessageDmsUimUnblockCkOutput *
qmi_client_dms_uim_unblock_ck_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_unblock_ck_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_unblock_ck_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimUnblockCkOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_unblock_ck_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_unblock_ck_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_unblock_ck:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsUimUnblockCkInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Unblock CK request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_unblock_ck_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_unblock_ck (
    QmiClientDms *self,
    QmiMessageDmsUimUnblockCkInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_unblock_ck);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_unblock_ck_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_unblock_ck_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_get_imsi_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_imsi().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_get_imsi().
 *
 * Returns: a #QmiMessageDmsUimGetImsiOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_imsi_output_unref().
 */
QmiMessageDmsUimGetImsiOutput *
qmi_client_dms_uim_get_imsi_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_get_imsi_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_get_imsi_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimGetImsiOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_get_imsi_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_get_imsi_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_get_imsi:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Get IMSI request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_get_imsi_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_get_imsi (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_get_imsi);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_get_imsi_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_get_imsi_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_uim_get_state_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_uim_get_state().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_uim_get_state().
 *
 * Returns: a #QmiMessageDmsUimGetStateOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_uim_get_state_output_unref().
 */
QmiMessageDmsUimGetStateOutput *
qmi_client_dms_uim_get_state_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_uim_get_state_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
uim_get_state_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsUimGetStateOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_uim_get_state_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_uim_get_state_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_uim_get_state:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a UIM Get State request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_uim_get_state_finish() to get the result of the operation.
 */
void
qmi_client_dms_uim_get_state (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_uim_get_state);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_uim_get_state_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)uim_get_state_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_band_capabilities_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_band_capabilities().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_band_capabilities().
 *
 * Returns: a #QmiMessageDmsGetBandCapabilitiesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_band_capabilities_output_unref().
 */
QmiMessageDmsGetBandCapabilitiesOutput *
qmi_client_dms_get_band_capabilities_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_band_capabilities_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_band_capabilities_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetBandCapabilitiesOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_band_capabilities_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_band_capabilities_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_band_capabilities:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Band Capabilities request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_band_capabilities_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_band_capabilities (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_band_capabilities);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_band_capabilities_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_band_capabilities_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_factory_sku_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_factory_sku().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_factory_sku().
 *
 * Returns: a #QmiMessageDmsGetFactorySkuOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_factory_sku_output_unref().
 */
QmiMessageDmsGetFactorySkuOutput *
qmi_client_dms_get_factory_sku_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_factory_sku_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_factory_sku_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetFactorySkuOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_factory_sku_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_factory_sku_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_factory_sku:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Factory SKU request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_factory_sku_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_factory_sku (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_factory_sku);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_factory_sku_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_factory_sku_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_firmware_preference_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_firmware_preference().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_firmware_preference().
 *
 * Returns: a #QmiMessageDmsGetFirmwarePreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_firmware_preference_output_unref().
 */
QmiMessageDmsGetFirmwarePreferenceOutput *
qmi_client_dms_get_firmware_preference_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_firmware_preference_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_firmware_preference_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetFirmwarePreferenceOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_firmware_preference_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_firmware_preference_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_firmware_preference:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Firmware Preference request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_firmware_preference_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_firmware_preference (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_firmware_preference);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_firmware_preference_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_firmware_preference_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_set_firmware_preference_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_firmware_preference().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_set_firmware_preference().
 *
 * Returns: a #QmiMessageDmsSetFirmwarePreferenceOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_firmware_preference_output_unref().
 */
QmiMessageDmsSetFirmwarePreferenceOutput *
qmi_client_dms_set_firmware_preference_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_set_firmware_preference_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_firmware_preference_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsSetFirmwarePreferenceOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_set_firmware_preference_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_set_firmware_preference_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_set_firmware_preference:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsSetFirmwarePreferenceInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set Firmware Preference request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_set_firmware_preference_finish() to get the result of the operation.
 */
void
qmi_client_dms_set_firmware_preference (
    QmiClientDms *self,
    QmiMessageDmsSetFirmwarePreferenceInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_set_firmware_preference);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_set_firmware_preference_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_firmware_preference_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_list_stored_images_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_list_stored_images().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_list_stored_images().
 *
 * Returns: a #QmiMessageDmsListStoredImagesOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_list_stored_images_output_unref().
 */
QmiMessageDmsListStoredImagesOutput *
qmi_client_dms_list_stored_images_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_list_stored_images_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
list_stored_images_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsListStoredImagesOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_list_stored_images_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_list_stored_images_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_list_stored_images:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a List Stored Images request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_list_stored_images_finish() to get the result of the operation.
 */
void
qmi_client_dms_list_stored_images (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_list_stored_images);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_list_stored_images_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)list_stored_images_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_delete_stored_image_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_delete_stored_image().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_delete_stored_image().
 *
 * Returns: a #QmiMessageDmsDeleteStoredImageOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_delete_stored_image_output_unref().
 */
QmiMessageDmsDeleteStoredImageOutput *
qmi_client_dms_delete_stored_image_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_delete_stored_image_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
delete_stored_image_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsDeleteStoredImageOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_delete_stored_image_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_delete_stored_image_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_delete_stored_image:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsDeleteStoredImageInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Delete Stored Image request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_delete_stored_image_finish() to get the result of the operation.
 */
void
qmi_client_dms_delete_stored_image (
    QmiClientDms *self,
    QmiMessageDmsDeleteStoredImageInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_delete_stored_image);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_delete_stored_image_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)delete_stored_image_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_set_time_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_time().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_set_time().
 *
 * Returns: a #QmiMessageDmsSetTimeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_time_output_unref().
 */
QmiMessageDmsSetTimeOutput *
qmi_client_dms_set_time_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_set_time_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_time_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsSetTimeOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_set_time_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_set_time_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_set_time:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsSetTimeInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set Time request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_set_time_finish() to get the result of the operation.
 */
void
qmi_client_dms_set_time (
    QmiClientDms *self,
    QmiMessageDmsSetTimeInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_set_time);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_set_time_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_time_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_stored_image_info_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_stored_image_info().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_stored_image_info().
 *
 * Returns: a #QmiMessageDmsGetStoredImageInfoOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_stored_image_info_output_unref().
 */
QmiMessageDmsGetStoredImageInfoOutput *
qmi_client_dms_get_stored_image_info_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_stored_image_info_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_stored_image_info_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetStoredImageInfoOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_stored_image_info_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_stored_image_info_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_stored_image_info:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsGetStoredImageInfoInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Stored Image Info request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_stored_image_info_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_stored_image_info (
    QmiClientDms *self,
    QmiMessageDmsGetStoredImageInfoInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_stored_image_info);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_stored_image_info_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_stored_image_info_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_alt_net_config_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_alt_net_config().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_alt_net_config().
 *
 * Returns: a #QmiMessageDmsGetAltNetConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_alt_net_config_output_unref().
 */
QmiMessageDmsGetAltNetConfigOutput *
qmi_client_dms_get_alt_net_config_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_alt_net_config_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_alt_net_config_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetAltNetConfigOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_alt_net_config_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_alt_net_config_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_alt_net_config:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Alt Net Config request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_alt_net_config_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_alt_net_config (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_alt_net_config);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_alt_net_config_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_alt_net_config_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_set_alt_net_config_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_alt_net_config().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_set_alt_net_config().
 *
 * Returns: a #QmiMessageDmsSetAltNetConfigOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_alt_net_config_output_unref().
 */
QmiMessageDmsSetAltNetConfigOutput *
qmi_client_dms_set_alt_net_config_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_set_alt_net_config_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_alt_net_config_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsSetAltNetConfigOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_set_alt_net_config_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_set_alt_net_config_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_set_alt_net_config:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsSetAltNetConfigInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set Alt Net Config request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_set_alt_net_config_finish() to get the result of the operation.
 */
void
qmi_client_dms_set_alt_net_config (
    QmiClientDms *self,
    QmiMessageDmsSetAltNetConfigInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_set_alt_net_config);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_set_alt_net_config_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_alt_net_config_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_get_software_version_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_get_software_version().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_get_software_version().
 *
 * Returns: a #QmiMessageDmsGetSoftwareVersionOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_get_software_version_output_unref().
 */
QmiMessageDmsGetSoftwareVersionOutput *
qmi_client_dms_get_software_version_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_get_software_version_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
get_software_version_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsGetSoftwareVersionOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_get_software_version_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_get_software_version_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_get_software_version:
 * @self: a #QmiClientDms.
 * @unused: %NULL. This message doesn't have any input bundle.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Get Software Version request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_get_software_version_finish() to get the result of the operation.
 */
void
qmi_client_dms_get_software_version (
    QmiClientDms *self,
    gpointer unused,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_get_software_version);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_get_software_version_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  NULL,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)get_software_version_ready,
                        result);
    qmi_message_unref (request);
}


/**
 * qmi_client_dms_set_service_programming_code_finish:
 * @self: a #QmiClientDms.
 * @res: the #GAsyncResult obtained from the #GAsyncReadyCallback passed to qmi_client_dms_set_service_programming_code().
 * @error: Return location for error or %NULL.
 *
 * Finishes an async operation started with qmi_client_dms_set_service_programming_code().
 *
 * Returns: a #QmiMessageDmsSetServiceProgrammingCodeOutput, or %NULL if @error is set. The returned value should be freed with qmi_message_dms_set_service_programming_code_output_unref().
 */
QmiMessageDmsSetServiceProgrammingCodeOutput *
qmi_client_dms_set_service_programming_code_finish (
    QmiClientDms *self,
    GAsyncResult *res,
    GError **error)
{
   if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (res), error))
       return NULL;

   return qmi_message_dms_set_service_programming_code_output_ref (g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res)));
}

static void
set_service_programming_code_ready (
    QmiDevice *device,
    GAsyncResult *res,
    GSimpleAsyncResult *simple)
{
    GError *error = NULL;
    QmiMessage *reply;
    QmiMessageDmsSetServiceProgrammingCodeOutput *output;

    reply = qmi_device_command_finish (device, res, &error);
    if (!reply) {
        g_simple_async_result_take_error (simple, error);
        g_simple_async_result_complete (simple);
        g_object_unref (simple);
        return;
    }

    /* Parse reply */
    output = __qmi_message_dms_set_service_programming_code_response_parse (reply, &error);
    if (!output)
        g_simple_async_result_take_error (simple, error);
    else
        g_simple_async_result_set_op_res_gpointer (simple,
                                                   output,
                                                   (GDestroyNotify)qmi_message_dms_set_service_programming_code_output_unref);
    g_simple_async_result_complete (simple);
    g_object_unref (simple);
    qmi_message_unref (reply);
}

/**
 * qmi_client_dms_set_service_programming_code:
 * @self: a #QmiClientDms.
 * @input: a #QmiMessageDmsSetServiceProgrammingCodeInput.
 * @timeout: maximum time to wait for the method to complete, in seconds.
 * @cancellable: a #GCancellable or %NULL.
 * @callback: a #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: user data to pass to @callback.
 *
 * Asynchronously sends a Set Service Programming Code request to the device.
 *
 * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from.
 *
 * You can then call qmi_client_dms_set_service_programming_code_finish() to get the result of the operation.
 */
void
qmi_client_dms_set_service_programming_code (
    QmiClientDms *self,
    QmiMessageDmsSetServiceProgrammingCodeInput *input,
    guint timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
    GSimpleAsyncResult *result;
    QmiMessage *request;
    GError *error = NULL;
    guint16 transaction_id;

    result = g_simple_async_result_new (G_OBJECT (self),
                                        callback,
                                        user_data,
                                        qmi_client_dms_set_service_programming_code);

    transaction_id = qmi_client_get_next_transaction_id (QMI_CLIENT (self));

    request = __qmi_message_dms_set_service_programming_code_request_create (
                  transaction_id,
                  qmi_client_get_cid (QMI_CLIENT (self)),
                  input,
                  &error);
    if (!request) {
        g_prefix_error (&error, "Couldn't create request message: ");
        g_simple_async_result_take_error (result, error);
        g_simple_async_result_complete_in_idle (result);
        g_object_unref (result);
        return;
    }

    qmi_device_command (QMI_DEVICE (qmi_client_peek_device (QMI_CLIENT (self))),
                        request,
                        timeout,
                        cancellable,
                        (GAsyncReadyCallback)set_service_programming_code_ready,
                        result);
    qmi_message_unref (request);
}

